[{"title":"Golang 源码阅读 - 等待队列","url":"http://localhost:4000/2020/01/17/go-sudog/","content":"<p>在学习 Golang 并发模型底层实现的过程，会经常碰到一个名为 <code>sudog</code> 的结构体，比如在 <code>channel</code> 中，或者 <code>sync</code>  包中，<code>sudog</code> 表示一个在等待队列的中的 goroutine，它的分配在一个特殊的池子中进行。</p>\n<h3 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> sudog <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tg *g</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 是否处于 select 结构中</span></span><br><span class=\"line\">\tisSelect <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tnext     *sudog</span><br><span class=\"line\">\tprev     *sudog</span><br><span class=\"line\">  <span class=\"comment\">// 数据地址，比如 channel 中要发送或接收的数据，或者锁实现用到的信号量</span></span><br><span class=\"line\">\telem     unsafe.Pointer</span><br><span class=\"line\">  </span><br><span class=\"line\">\tacquiretime <span class=\"keyword\">int64</span></span><br><span class=\"line\">\treleasetime <span class=\"keyword\">int64</span></span><br><span class=\"line\">\tticket      <span class=\"keyword\">uint32</span></span><br><span class=\"line\">\tparent      *sudog <span class=\"comment\">// semaRoot binary tree</span></span><br><span class=\"line\">\twaitlink    *sudog <span class=\"comment\">// g.waiting list or semaRoot</span></span><br><span class=\"line\">\twaittail    *sudog <span class=\"comment\">// semaRoot</span></span><br><span class=\"line\">\tc           *hchan <span class=\"comment\">// channel</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象池\"><a href=\"#对象池\" class=\"headerlink\" title=\"对象池\"></a>对象池</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">acquireSudog</span><span class=\"params\">()</span> *<span class=\"title\">sudog</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Delicate dance: the semaphore implementation calls</span></span><br><span class=\"line\">\t<span class=\"comment\">// acquireSudog, acquireSudog calls new(sudog),</span></span><br><span class=\"line\">\t<span class=\"comment\">// new calls malloc, malloc can call the garbage collector,</span></span><br><span class=\"line\">\t<span class=\"comment\">// and the garbage collector calls the semaphore implementation</span></span><br><span class=\"line\">\t<span class=\"comment\">// in stopTheWorld.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Break the cycle by doing acquirem/releasem around new(sudog).</span></span><br><span class=\"line\">\t<span class=\"comment\">// The acquirem/releasem increments m.locks during new(sudog),</span></span><br><span class=\"line\">\t<span class=\"comment\">// which keeps the garbage collector from being invoked.</span></span><br><span class=\"line\">\tmp := acquirem()</span><br><span class=\"line\">\tpp := mp.p.ptr()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(pp.sudogcache) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlock(&amp;sched.sudoglock)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 从全局 cache 链表中获取</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(pp.sudogcache) &lt; <span class=\"built_in\">cap</span>(pp.sudogcache)/<span class=\"number\">2</span> &amp;&amp; sched.sudogcache != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\ts := sched.sudogcache</span><br><span class=\"line\">\t\t\tsched.sudogcache = s.next</span><br><span class=\"line\">\t\t\ts.next = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\tpp.sudogcache = <span class=\"built_in\">append</span>(pp.sudogcache, s)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tunlock(&amp;sched.sudoglock)</span><br><span class=\"line\">\t\t<span class=\"comment\">// If the central cache is empty, allocate a new one.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(pp.sudogcache) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tpp.sudogcache = <span class=\"built_in\">append</span>(pp.sudogcache, <span class=\"built_in\">new</span>(sudog))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(pp.sudogcache)</span><br><span class=\"line\">\ts := pp.sudogcache[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">\tpp.sudogcache[n<span class=\"number\">-1</span>] = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tpp.sudogcache = pp.sudogcache[:n<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.elem != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"acquireSudog: found s.elem != nil in cache\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treleasem(mp)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">releaseSudog</span><span class=\"params\">(s *sudog)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.elem != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime: sudog with non-nil elem\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.isSelect &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime: sudog with non-false isSelect\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime: sudog with non-nil next\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.prev != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime: sudog with non-nil prev\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.waitlink != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime: sudog with non-nil waitlink\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.c != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime: sudog with non-nil c\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgp := getg()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gp.param != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime: releaseSudog with non-nil gp.param\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmp := acquirem() <span class=\"comment\">// avoid rescheduling to another P</span></span><br><span class=\"line\">\tpp := mp.p.ptr()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(pp.sudogcache) == <span class=\"built_in\">cap</span>(pp.sudogcache) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 本地缓存满了，把一半放入全局缓存链表</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> first, last *sudog</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(pp.sudogcache) &gt; <span class=\"built_in\">cap</span>(pp.sudogcache)/<span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t\tn := <span class=\"built_in\">len</span>(pp.sudogcache)</span><br><span class=\"line\">\t\t\tp := pp.sudogcache[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t\tpp.sudogcache[n<span class=\"number\">-1</span>] = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\tpp.sudogcache = pp.sudogcache[:n<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> first == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tfirst = p</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tlast.next = p</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tlast = p</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlock(&amp;sched.sudoglock)</span><br><span class=\"line\">\t\tlast.next = sched.sudogcache</span><br><span class=\"line\">\t\tsched.sudogcache = first</span><br><span class=\"line\">\t\tunlock(&amp;sched.sudoglock)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpp.sudogcache = <span class=\"built_in\">append</span>(pp.sudogcache, s)</span><br><span class=\"line\">\treleasem(mp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"等待队列\"><a href=\"#等待队列\" class=\"headerlink\" title=\"等待队列\"></a>等待队列</h3><p>等待队列的实现在不同的场景下实现不同</p>\n<p><strong>channel</strong> 中的 <strong>waitq</strong> 实现是一个简单的双向链表操作</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> waitq <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tfirst *sudog</span><br><span class=\"line\">\tlast  *sudog</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加入链表尾部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *waitq)</span> <span class=\"title\">enqueue</span><span class=\"params\">(sgp *sudog)</span></span> &#123;</span><br><span class=\"line\">\tsgp.next = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tx := q.last</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tsgp.prev = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\tq.first = sgp</span><br><span class=\"line\">\t\tq.last = sgp</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsgp.prev = x</span><br><span class=\"line\">\tx.next = sgp</span><br><span class=\"line\">\tq.last = sgp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取链表头部数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *waitq)</span> <span class=\"title\">dequeue</span><span class=\"params\">()</span> *<span class=\"title\">sudog</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tsgp := q.first</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sgp == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ty := sgp.next</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> y == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tq.first = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\tq.last = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\ty.prev = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\tq.first = y</span><br><span class=\"line\">\t\t\tsgp.next = <span class=\"literal\">nil</span> <span class=\"comment\">// mark as removed (see dequeueSudog)</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sgp.isSelect &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !atomic.Cas(&amp;sgp.g.selectDone, <span class=\"number\">0</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sgp</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>互斥锁中使用的 <strong>semaRoot</strong> 实现相对复杂些，是一个树堆结构</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// semaRoot 持有一棵不同信号量地址的 sudog(s.elem) 的平衡树，</span></span><br><span class=\"line\"><span class=\"comment\">// 树里的每个 sudog 通过 waitlink 又形成一个同信号量地址链表</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> semaRoot <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tlock  mutex</span><br><span class=\"line\">\ttreap *sudog <span class=\"comment\">// root of balanced tree of unique waiters.</span></span><br><span class=\"line\">\tnwait <span class=\"keyword\">uint32</span> <span class=\"comment\">// Number of waiters. Read w/o the lock.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 sudog 添加到树堆上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(root *semaRoot)</span> <span class=\"title\">queue</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>, s *sudog, lifo <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\ts.g = getg()</span><br><span class=\"line\">\ts.elem = unsafe.Pointer(addr)</span><br><span class=\"line\">\ts.next = <span class=\"literal\">nil</span></span><br><span class=\"line\">\ts.prev = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> last *sudog</span><br><span class=\"line\">\tpt := &amp;root.treap</span><br><span class=\"line\">  <span class=\"comment\">// 树堆查找信号量，相当于二叉搜索树，时间复杂度是 O(log n)</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> t := *pt; t != <span class=\"literal\">nil</span>; t = *pt &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找到同信号量的 sudog，进行链表处理</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.elem == unsafe.Pointer(addr) &#123; </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> lifo &#123; <span class=\"comment\">// 加入到等待队列头部</span></span><br><span class=\"line\">\t\t\t\t*pt = s</span><br><span class=\"line\">        <span class=\"comment\">// 用 s 代替 t 的位置</span></span><br><span class=\"line\">\t\t\t\ts.ticket = t.ticket</span><br><span class=\"line\">\t\t\t\ts.acquiretime = t.acquiretime</span><br><span class=\"line\">\t\t\t\ts.parent = t.parent</span><br><span class=\"line\">\t\t\t\ts.prev = t.prev</span><br><span class=\"line\">\t\t\t\ts.next = t.next</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> s.prev != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\ts.prev.parent = s</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> s.next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\ts.next.parent = s</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Add t first in s's wait list.</span></span><br><span class=\"line\">\t\t\t\ts.waitlink = t</span><br><span class=\"line\">\t\t\t\ts.waittail = t.waittail</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> s.waittail == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\ts.waittail = t</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tt.parent = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t\tt.prev = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t\tt.next = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t\tt.waittail = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 加到等待队列尾部</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> t.waittail == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tt.waitlink = s</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tt.waittail.waitlink = s</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tt.waittail = s</span><br><span class=\"line\">\t\t\t\ts.waitlink = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlast = t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">uintptr</span>(unsafe.Pointer(addr)) &lt; <span class=\"keyword\">uintptr</span>(t.elem) &#123;</span><br><span class=\"line\">\t\t\tpt = &amp;t.prev</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tpt = &amp;t.next</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 执行到此处，树中未找到同信号量的链表，将 s 作为树的新节点插入进去</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 加入随机的 ticket</span></span><br><span class=\"line\">\ts.ticket = fastrand() | <span class=\"number\">1</span></span><br><span class=\"line\">\ts.parent = last</span><br><span class=\"line\">\t*pt = s</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 按照 ticket 旋转，形成最小堆，也就是要随机平衡二叉树</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以，这个树堆结构以 elem 来看，是一个二叉搜索树</span></span><br><span class=\"line\">  <span class=\"comment\">// 以 ticket 来看，又是个最小堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> s.parent != <span class=\"literal\">nil</span> &amp;&amp; s.parent.ticket &gt; s.ticket &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.parent.prev == s &#123;</span><br><span class=\"line\">\t\t\troot.rotateRight(s.parent)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> s.parent.next != s &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"semaRoot queue\"</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\troot.rotateLeft(s.parent)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回阻塞在 addr 链表上的首个 goroutine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(root *semaRoot)</span> <span class=\"title\">dequeue</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>)</span> <span class=\"params\">(found *sudog, now <span class=\"keyword\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">\tps := &amp;root.treap</span><br><span class=\"line\">\ts := *ps</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; s != <span class=\"literal\">nil</span>; s = *ps &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.elem == unsafe.Pointer(addr) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> Found</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">uintptr</span>(unsafe.Pointer(addr)) &lt; <span class=\"keyword\">uintptr</span>(s.elem) &#123;</span><br><span class=\"line\">\t\t\tps = &amp;s.prev</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tps = &amp;s.next</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">Found:</span><br><span class=\"line\">\tnow = <span class=\"keyword\">int64</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.acquiretime != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tnow = cputicks()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t := s.waitlink; t != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 移除链表首个 sudog</span></span><br><span class=\"line\">\t\t*ps = t</span><br><span class=\"line\">\t\tt.ticket = s.ticket</span><br><span class=\"line\">\t\tt.parent = s.parent</span><br><span class=\"line\">\t\tt.prev = s.prev</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.prev != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tt.prev.parent = t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tt.next = s.next</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tt.next.parent = t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.waitlink != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tt.waittail = s.waittail</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tt.waittail = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tt.acquiretime = now</span><br><span class=\"line\">\t\ts.waitlink = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\ts.waittail = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 在树堆结构中移除节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> s.next != <span class=\"literal\">nil</span> || s.prev != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> s.next == <span class=\"literal\">nil</span> || s.prev != <span class=\"literal\">nil</span> &amp;&amp; s.prev.ticket &lt; s.next.ticket &#123;</span><br><span class=\"line\">\t\t\t\troot.rotateRight(s)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\troot.rotateLeft(s)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Remove s, now a leaf.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.parent != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> s.parent.prev == s &#123;</span><br><span class=\"line\">\t\t\t\ts.parent.prev = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\ts.parent.next = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\troot.treap = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts.parent = <span class=\"literal\">nil</span></span><br><span class=\"line\">\ts.elem = <span class=\"literal\">nil</span></span><br><span class=\"line\">\ts.next = <span class=\"literal\">nil</span></span><br><span class=\"line\">\ts.prev = <span class=\"literal\">nil</span></span><br><span class=\"line\">\ts.ticket = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s, now</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sync.Cond 中使用的 <strong>notifyList</strong> 的实现是一个单向链表</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> notifyList <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\twait <span class=\"keyword\">uint32</span></span><br><span class=\"line\">\tnotify <span class=\"keyword\">uint32</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// List of parked waiters.</span></span><br><span class=\"line\">\tlock mutex</span><br><span class=\"line\">\thead *sudog</span><br><span class=\"line\">\ttail *sudog</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">notifyListWait</span><span class=\"params\">(l *notifyList, t <span class=\"keyword\">uint32</span>)</span></span> &#123;</span><br><span class=\"line\">\tlock(&amp;l.lock)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> less(t, l.notify) &#123;</span><br><span class=\"line\">\t\tunlock(&amp;l.lock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ts := acquireSudog()</span><br><span class=\"line\">\ts.g = getg()</span><br><span class=\"line\">\ts.ticket = t</span><br><span class=\"line\">\ts.releasetime = <span class=\"number\">0</span></span><br><span class=\"line\">\tt0 := <span class=\"keyword\">int64</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> blockprofilerate &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tt0 = cputicks()</span><br><span class=\"line\">\t\ts.releasetime = <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 单向链表的添加</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> l.tail == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tl.head = s</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tl.tail.next = s</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tl.tail = s</span><br><span class=\"line\">\tgoparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class=\"number\">3</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t0 != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tblockevent(s.releasetime-t0, <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treleaseSudog(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">notifyListNotifyAll</span><span class=\"params\">(l *notifyList)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlock(&amp;l.lock)</span><br><span class=\"line\">\ts := l.head</span><br><span class=\"line\">\tl.head = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tl.tail = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tatomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class=\"line\">\tunlock(&amp;l.lock)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> s != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tnext := s.next</span><br><span class=\"line\">\t\ts.next = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\treadyWithTime(s, <span class=\"number\">4</span>)</span><br><span class=\"line\">\t\ts = next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - sync","url":"http://localhost:4000/2020/01/16/go-sync/","content":"<p>Go 语言的 sync 包提供一些基本的同步原语，如互斥锁 Mutex，读写锁 RWMutex 等，我们会在下面依次介绍它们的实现原理。但在介绍它们之前需要了解 Go 语言中几个同步信号量的操作。</p>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p>主要先了解 <code>runtime_SemacquireMutex</code> 和 <code>runtime_Semrelease</code> 两个函数，具体源码在 runtime/sema.go 文件中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将信号量 -1，结果为负阻塞当前 goroutine，相当于 P 操作</span></span><br><span class=\"line\"><span class=\"comment\">//go:linkname sync_runtime_SemacquireMutex sync.runtime_SemacquireMutex</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sync_runtime_SemacquireMutex</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>, lifo <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\tsemacquire1(addr, lifo, semaBlockProfile|semaMutexProfile)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将信号量 +1，如存在阻塞的 goroutine，唤醒一个，相当于 V 操作</span></span><br><span class=\"line\"><span class=\"comment\">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sync_runtime_Semrelease</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>, handoff <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\tsemrelease1(addr, handoff)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了信号量的处理，Go 语言还给信号量绑定了一个结构体 <code>semaRoot</code>，这是一个平衡树，里面存储着陷入等待的 goroutine。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> semaRoot <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tlock  mutex  <span class=\"comment\">// 需要一个互斥锁保护链表，mutex 只是内部使用的一个简单版本</span></span><br><span class=\"line\">\ttreap *sudog <span class=\"comment\">// root of balanced tree of unique waiters.</span></span><br><span class=\"line\">\tnwait <span class=\"keyword\">uint32</span> <span class=\"comment\">// Number of waiters. Read w/o the lock.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// addr 表示信号量</span></span><br><span class=\"line\"><span class=\"comment\">// lifo 当当前 goroutine 需要阻塞等待时，值为 true 将其添加到队列头部，反之添加到尾部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">semacquire1</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>, lifo <span class=\"keyword\">bool</span>, profile semaProfileFlags)</span></span> &#123;</span><br><span class=\"line\">\tgp := getg()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gp != gp.m.curg &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"semacquire not on the G stack\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 低成本 P 操作，成功直接返回</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cansemacquire(addr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 高成本:</span></span><br><span class=\"line\">\t<span class=\"comment\">//\t增加 waiter 数量</span></span><br><span class=\"line\">\t<span class=\"comment\">//\t再尝试一次低成本操作，如果成功直接返回</span></span><br><span class=\"line\">\t<span class=\"comment\">//\t没成功就把自己作为一个 waiter 加入队列</span></span><br><span class=\"line\">\t<span class=\"comment\">//\tsleep</span></span><br><span class=\"line\">\t<span class=\"comment\">//\t(waiter descriptor is dequeued by signaler)</span></span><br><span class=\"line\">\ts := acquireSudog()</span><br><span class=\"line\">  <span class=\"comment\">// 获取信号量对应的 semaRoot</span></span><br><span class=\"line\">\troot := semroot(addr)</span><br><span class=\"line\">\tt0 := <span class=\"keyword\">int64</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">\ts.releasetime = <span class=\"number\">0</span></span><br><span class=\"line\">\ts.acquiretime = <span class=\"number\">0</span></span><br><span class=\"line\">\ts.ticket = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tlock(&amp;root.lock)</span><br><span class=\"line\">\t\t<span class=\"comment\">// Add ourselves to nwait to disable \"easy case\" in semrelease.</span></span><br><span class=\"line\">\t\tatomic.Xadd(&amp;root.nwait, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// Check cansemacquire to avoid missed wakeup.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> cansemacquire(addr) &#123;</span><br><span class=\"line\">\t\t\tatomic.Xadd(&amp;root.nwait, <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t\tunlock(&amp;root.lock)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Any semrelease after the cansemacquire knows we're waiting</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// (we set nwait above), so go to sleep.</span></span><br><span class=\"line\">\t\troot.queue(addr, s, lifo)</span><br><span class=\"line\">    <span class=\"comment\">// 休眠等待唤醒</span></span><br><span class=\"line\">\t\tgoparkunlock(&amp;root.lock, waitReasonSemacquire, traceEvGoBlockSync, <span class=\"number\">4</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.ticket != <span class=\"number\">0</span> || cansemacquire(addr) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.releasetime &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tblockevent(s.releasetime-t0, <span class=\"number\">3</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treleaseSudog(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// addr 信号量</span></span><br><span class=\"line\"><span class=\"comment\">// handoff 表示是否需要直接移交信号量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">semrelease1</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>, handoff <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\troot := semroot(addr)</span><br><span class=\"line\">\tatomic.Xadd(addr, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 低成本情况: 没有 waiter</span></span><br><span class=\"line\">\t<span class=\"comment\">// This check must happen after the xadd, to avoid a missed wakeup</span></span><br><span class=\"line\">\t<span class=\"comment\">// (see loop in semacquire).</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;root.nwait) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 高成本情况: 搜索 waiter 并唤醒它</span></span><br><span class=\"line\">\tlock(&amp;root.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;root.nwait) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// The count is already consumed by another goroutine,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// so no need to wake up another goroutine.</span></span><br><span class=\"line\">\t\tunlock(&amp;root.lock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts, t0 := root.dequeue(addr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tatomic.Xadd(&amp;root.nwait, <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tunlock(&amp;root.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s != <span class=\"literal\">nil</span> &#123; <span class=\"comment\">// May be slow, so unlock first</span></span><br><span class=\"line\">\t\tacquiretime := s.acquiretime</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> acquiretime != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tmutexevent(t0-acquiretime, <span class=\"number\">3</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.ticket != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"corrupted semaphore ticket\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 直接将信号量移交给需要唤醒的 goroutine，在互斥锁的饥饿模式中使用</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> handoff &amp;&amp; cansemacquire(addr) &#123;</span><br><span class=\"line\">\t\t\ts.ticket = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treadyWithTime(s, <span class=\"number\">5</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Mutex\"><a href=\"#Mutex\" class=\"headerlink\" title=\"Mutex\"></a>Mutex</h3><p>互斥锁 Mutex 由两个字段 <code>state</code> 和 <code>sema</code> 组成，<code>state</code> 表示当前锁的状态，<code>sema</code>  表示控制锁状态的信号量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Mutex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  state <span class=\"keyword\">int32</span>   <span class=\"comment\">// 32位，[29(等待 goroutine 数)][饥饿模式][唤醒状态][锁状态]</span></span><br><span class=\"line\">\tsema  <span class=\"keyword\">uint32</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>锁的状态用 int32 表示，最低三位分别表示 <code>mutexLocked</code> <code>mutexWoken</code> <code>mutexStarving</code>，剩下的位置用来表示当前有多少个 goroutine 等待互斥锁被释放。</p>\n<p>Mutex 初始化后，所有的状态都为 0 ，当被锁定时 <code>mutexLocked</code> 被置为 1，当锁在正常模式下被唤醒时 <code>mutexWoken</code> 被置为 1，<code>mutexStarving</code> 为 1 表示锁处于饥饿模式。</p>\n<p>互斥锁的饥饿模式是 Go 在 1.9 版本加入的新特性，是为了保证锁获取的公平性。在正常模式下，所有需要获取锁的 goroutine 都会按照 FIFO 顺序获取锁，但是如果一个刚被唤醒的 goroutine 在获取锁时，遇到一个新创建的 goroutine 也要获取锁时，大概率拿不到，为了减少这种情况的出现，防止 goroutine 饿死，一旦 goroutine 超过 1m 没拿到锁，那么互斥锁就会切换至饥饿模式。</p>\n<p>在饥饿模式中，互斥锁会被直接交给等待队列最前面的 goroutine，新的 goroutine 会被放置在队列末尾等待，如果一个 goroutine 得到了互斥锁并且它时等待队列的最后一个，或者它获取锁的时间小于 1m，那么当前锁会被切换至正常模式。</p>\n<p>正常模式相比饥饿模式会有更好的性能，饥饿模式主要作用就是避免一些 goroutine 陷入等待后无法获取锁而造成较高的尾延迟。</p>\n<h4 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a>加锁</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Mutex)</span> <span class=\"title\">Lock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 当锁的状态为 0 时，直接拿到锁并将状态置为 1，然后返回</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class=\"number\">0</span>, mutexLocked) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// goroutine 等待时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> waitStartTime <span class=\"keyword\">int64</span></span><br><span class=\"line\">  <span class=\"comment\">// goroutine 是否处于饥饿状态</span></span><br><span class=\"line\">\tstarving := <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\">// goroutine 是否被唤醒</span></span><br><span class=\"line\">\tawoke := <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\">// 自旋次数</span></span><br><span class=\"line\">\titer := <span class=\"number\">0</span></span><br><span class=\"line\">\told := m.state</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断 goroutine 是否能进入自旋状态等待锁的释放</span></span><br><span class=\"line\">    <span class=\"comment\">// 第一个条件是 state 已锁，但不是处于饥饿模式，饥饿模式自旋没用，锁直接给等待队列第一个</span></span><br><span class=\"line\">    <span class=\"comment\">// 第二个条件 runtime_canSpin 方法会根据 CPU 核数，自旋的次数，P 的运行队列状态判断当前 goroutine 是否可以进入自旋</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 设置唤醒状态</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class=\"number\">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t\tatomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class=\"line\">\t\t\t\tawoke = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 进入自旋状态，最后调用的是 runtime.procyield 方法，会执行 30 次 PAUSE 指令</span></span><br><span class=\"line\">\t\t\truntime_doSpin()</span><br><span class=\"line\">\t\t\titer++</span><br><span class=\"line\">\t\t\told = m.state</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 此处，state 状态可能是：</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 已锁，处于正常模式</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 已锁，处于饥饿模式</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 未锁，处于正常模式</span></span><br><span class=\"line\">    <span class=\"comment\">// 4. 未锁，处于饥饿模式</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// old 表示当前锁的状态</span></span><br><span class=\"line\">    <span class=\"comment\">// new 用来设置新的状态</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">new</span> := old</span><br><span class=\"line\">\t\t<span class=\"comment\">// old 处于正常模式下，给 new 上锁，后面会尝试通过 CAS 获取锁</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> old&amp;mutexStarving == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">new</span> |= mutexLocked</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将等待队列+1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> old&amp;(mutexLocked|mutexStarving) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">new</span> += <span class=\"number\">1</span> &lt;&lt; mutexWaiterShift</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前 goroutine 是饥饿状态，并且 old 已被锁，将 new 设置为饥饿模式</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">new</span> |= mutexStarving</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> awoke &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">new</span>&amp;mutexWoken == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tthrow(<span class=\"string\">\"sync: inconsistent mutex state\"</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">new</span> &amp;^= mutexWoken</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 同 CAS 修改互斥锁的状态</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class=\"built_in\">new</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果 old 是未被锁，并且不是饥饿模式，表明抢锁成功，跳出循环</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> old&amp;(mutexLocked|mutexStarving) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">      <span class=\"comment\">// false，新的 goroutine，放入队列尾部</span></span><br><span class=\"line\">      <span class=\"comment\">// true，唤醒的 goroutine，放入队列头部</span></span><br><span class=\"line\">\t\t\tqueueLifo := waitStartTime != <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> waitStartTime == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\twaitStartTime = runtime_nanotime()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 获取信号量，没获取到调用 goparkunlock 休眠</span></span><br><span class=\"line\">\t\t\truntime_SemacquireMutex(&amp;m.sema, queueLifo)</span><br><span class=\"line\">\t\t\tstarving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class=\"line\">\t\t\told = m.state</span><br><span class=\"line\">      <span class=\"comment\">// 当前的 state 已经是饥饿状态</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> old&amp;mutexStarving != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> old&amp;(mutexLocked|mutexWoken) != <span class=\"number\">0</span> || old&gt;&gt;mutexWaiterShift == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tthrow(<span class=\"string\">\"sync: inconsistent mutex state\"</span>)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tdelta := <span class=\"keyword\">int32</span>(mutexLocked - <span class=\"number\">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class=\"line\">        <span class=\"comment\">// 如果本 goroutine 是最后一个等待者，或者它并不处于饥饿状态，</span></span><br><span class=\"line\">        <span class=\"comment\">// 那么我们需要把锁的 state 状态设置为正常模式.</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tdelta -= mutexStarving</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 设置新state, 因为已经获得了锁，退出、返回</span></span><br><span class=\"line\">\t\t\t\tatomic.AddInt32(&amp;m.state, delta)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果当前的锁是正常模式，本goroutine被唤醒，自旋次数清零，从for循环开始处重新开始</span></span><br><span class=\"line\">\t\t\tawoke = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\titer = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\told = m.state</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"解锁\"><a href=\"#解锁\" class=\"headerlink\" title=\"解锁\"></a>解锁</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Mutex)</span> <span class=\"title\">Unlock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 解锁，如果之前 state 未锁，panic</span></span><br><span class=\"line\">\t<span class=\"built_in\">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">new</span>+mutexLocked)&amp;mutexLocked == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"sync: unlock of unlocked mutex\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 释放了锁，还要通知其他等待的 goroutine</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 锁处于正常模式</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">new</span>&amp;mutexStarving == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\told := <span class=\"built_in\">new</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 没有等待的 goroutine，或者已经解锁，返回</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> old&gt;&gt;mutexWaiterShift == <span class=\"number\">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将等待的goroutine数减一，并设置woken标识</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">new</span> = (old - <span class=\"number\">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 设置新的state, 这里通过信号量会唤醒一个阻塞的 goroutine 去获取锁.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class=\"built_in\">new</span>) &#123;</span><br><span class=\"line\">\t\t\t\truntime_Semrelease(&amp;m.sema, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\told = m.state</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 锁处于饥饿模式，直接将锁的拥有权给等待队列的第一个</span></span><br><span class=\"line\">\t\truntime_Semrelease(&amp;m.sema, <span class=\"literal\">true</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RWMutex\"><a href=\"#RWMutex\" class=\"headerlink\" title=\"RWMutex\"></a>RWMutex</h3><p>如果我们有个服务对资源的读取操作远大于更改操作，那么使用读写锁能很大程度的提高性能，读写锁不限制对资源的并发读取，但是读写、写写、写读的操作无法并发执行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> RWMutex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tw           Mutex  <span class=\"comment\">// held if there are pending writers</span></span><br><span class=\"line\">\twriterSem   <span class=\"keyword\">uint32</span> <span class=\"comment\">// semaphore for writers to wait for completing readers</span></span><br><span class=\"line\">\treaderSem   <span class=\"keyword\">uint32</span> <span class=\"comment\">// semaphore for readers to wait for completing writers</span></span><br><span class=\"line\">\treaderCount <span class=\"keyword\">int32</span>  <span class=\"comment\">// 读锁数量</span></span><br><span class=\"line\">\treaderWait  <span class=\"keyword\">int32</span>  <span class=\"comment\">// 获取写锁时需要等待的读锁释放数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rw *RWMutex)</span> <span class=\"title\">RLock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// readerCount+1，如果返回负数，说明当前有个 goroutine 获得了写锁或等待获取写锁</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 进入休眠，等待写锁释放</span></span><br><span class=\"line\">\t\truntime_SemacquireMutex(&amp;rw.readerSem, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rw *RWMutex)</span> <span class=\"title\">RUnlock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// readerCount-1，如果返回负数，说明当前有个 goroutine 获得了写锁或等待获取写锁</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class=\"number\">-1</span>); r &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 未获得读锁去释放，panic</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> r+<span class=\"number\">1</span> == <span class=\"number\">0</span> || r+<span class=\"number\">1</span> == -rwmutexMaxReaders &#123;</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"sync: RUnlock of unlocked RWMutex\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// readerWait -1 ，直到等于0，表示没有未释放的读锁了</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class=\"number\">-1</span>) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通过 writerSem 信号量通知等待的 goroutine 获取写锁</span></span><br><span class=\"line\">\t\t\truntime_Semrelease(&amp;rw.writerSem, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rw *RWMutex)</span> <span class=\"title\">Lock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 互斥锁，处理多个写并发情况</span></span><br><span class=\"line\">\trw.w.Lock()</span><br><span class=\"line\">\t<span class=\"comment\">// 将 readerCount 减去一个大数，变成一个大负数，r 等于原来的 readerCount</span></span><br><span class=\"line\">\tr := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class=\"line\">\t<span class=\"comment\">// r !=0 表示还有 r 个 goroutine 得到了读锁，将 readerWait 加上 r，表示需要等待这么多个读锁释放</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r != <span class=\"number\">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 没办法获取到写锁，休眠等待所有读锁的释放</span></span><br><span class=\"line\">\t\truntime_SemacquireMutex(&amp;rw.writerSem, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(rw *RWMutex)</span> <span class=\"title\">Unlock</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 恢复之前的 readerCount</span></span><br><span class=\"line\">\tr := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"sync: Unlock of unlocked RWMutex\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 唤醒等待获取读锁的 goroutine.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">int</span>(r); i++ &#123;</span><br><span class=\"line\">\t\truntime_Semrelease(&amp;rw.readerSem, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 释放写的互斥锁</span></span><br><span class=\"line\">\trw.w.Unlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"WaitGroup\"><a href=\"#WaitGroup\" class=\"headerlink\" title=\"WaitGroup\"></a>WaitGroup</h3><p>在批量执行一些任务，或者调用多个外部服务的场景下常常会用到 WaitGroup 来并发执行任务，在所有的并发任务都结束后，继续执行其他代码。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requests := []*Request&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">wg.Add(<span class=\"built_in\">len</span>(requests))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, request := <span class=\"keyword\">range</span> requests &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(r *Request)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// res, err := service.call(r)</span></span><br><span class=\"line\">    &#125;(request)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wg.Wait()</span><br></pre></td></tr></table></figure>\n<h4 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> WaitGroup <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tnoCopy noCopy <span class=\"comment\">// 保证结构体首次使用后不会被复制，编译期间检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 12 字节，存储未执行结束 goroutine 数量，等待者数量，及信号量</span></span><br><span class=\"line\">\tstate1 [<span class=\"number\">3</span>]<span class=\"keyword\">uint32</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回状态及信号量</span></span><br><span class=\"line\"><span class=\"comment\">// 因为在下方对 statep 进行64为原子操作时，需要8字节对齐，所以在32位操作系统上，前4字节为信号量</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;32bit- counter &#125;&#123;32bit- waiter &#125;&#123;32bit- sema &#125; // 64位</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;32bit- sema &#125;&#123;32bit- counter &#125;&#123;32bit- waiter &#125; // 32位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(wg *WaitGroup)</span> <span class=\"title\">state</span><span class=\"params\">()</span> <span class=\"params\">(statep *<span class=\"keyword\">uint64</span>, semap *<span class=\"keyword\">uint32</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"keyword\">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class=\"number\">8</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (*<span class=\"keyword\">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class=\"number\">2</span>]</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (*<span class=\"keyword\">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class=\"number\">1</span>])), &amp;wg.state1[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Add\"><a href=\"#Add\" class=\"headerlink\" title=\"Add\"></a>Add</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(wg *WaitGroup)</span> <span class=\"title\">Add</span><span class=\"params\">(delta <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tstatep, semap := wg.state()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 执行的 goroutine 数量 + delta</span></span><br><span class=\"line\">\tstate := atomic.AddUint64(statep, <span class=\"keyword\">uint64</span>(delta)&lt;&lt;<span class=\"number\">32</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 执行的 goroutine 数量</span></span><br><span class=\"line\">\tv := <span class=\"keyword\">int32</span>(state &gt;&gt; <span class=\"number\">32</span>)</span><br><span class=\"line\"> \t<span class=\"comment\">// waiter 数量</span></span><br><span class=\"line\">  w := <span class=\"keyword\">uint32</span>(state)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"sync: negative WaitGroup counter\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> w != <span class=\"number\">0</span> &amp;&amp; delta &gt; <span class=\"number\">0</span> &amp;&amp; v == <span class=\"keyword\">int32</span>(delta) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"sync: WaitGroup misuse: Add called concurrently with Wait\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v &gt; <span class=\"number\">0</span> || w == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 此时 v==0 并且 w&gt;0，说明所有 goroutine 执行完毕，需要唤醒 waiter</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> *statep != state &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"sync: WaitGroup misuse: Add called concurrently with Wait\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Reset waiters count to 0.</span></span><br><span class=\"line\">\t*statep = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; w != <span class=\"number\">0</span>; w-- &#123;</span><br><span class=\"line\">\t\truntime_Semrelease(semap, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(wg *WaitGroup)</span> <span class=\"title\">Done</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\twg.Add(<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Wait\"><a href=\"#Wait\" class=\"headerlink\" title=\"Wait\"></a>Wait</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(wg *WaitGroup)</span> <span class=\"title\">Wait</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tstatep, semap := wg.state()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tstate := atomic.LoadUint64(statep)</span><br><span class=\"line\">\t\tv := <span class=\"keyword\">int32</span>(state &gt;&gt; <span class=\"number\">32</span>)</span><br><span class=\"line\">\t\tw := <span class=\"keyword\">uint32</span>(state)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Counter is 0, no need to wait.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Increment waiters count.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 休眠等待唤醒</span></span><br><span class=\"line\">\t\t\truntime_Semacquire(semap)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> *statep != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"sync: WaitGroup is reused before previous Wait has returned\"</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h3><p>保证程序在运行期间 Once 对应的代码块只执行一次，实现原理很简单</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Once <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tm    Mutex  </span><br><span class=\"line\">\tdone <span class=\"keyword\">uint32</span>  <span class=\"comment\">// 是否执行过</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(o *Once)</span> <span class=\"title\">Do</span><span class=\"params\">(f <span class=\"keyword\">func</span>()</span>)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.LoadUint32(&amp;o.done) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Slow-path.</span></span><br><span class=\"line\">\to.m.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> o.m.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> o.done == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> atomic.StoreUint32(&amp;o.done, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tf()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cond\"><a href=\"#Cond\" class=\"headerlink\" title=\"Cond\"></a>Cond</h3><p>实现了一种条件变量，可以使用在多个 goroutine 等待共享资源准备就绪的场景。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Cond <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tnoCopy noCopy</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 条件变量需要锁保护</span></span><br><span class=\"line\">\tL Locker  </span><br><span class=\"line\"></span><br><span class=\"line\">\tnotify  notifyList   <span class=\"comment\">//等待的 goroutine 链表</span></span><br><span class=\"line\">\tchecker copyChecker  <span class=\"comment\">//存储字段地址，运行时检测是否被拷贝过</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> notifyList <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\twait <span class=\"keyword\">uint32</span></span><br><span class=\"line\">\tnotify <span class=\"keyword\">uint32</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// List of parked waiters.</span></span><br><span class=\"line\">\tlock mutex</span><br><span class=\"line\">\thead *sudog</span><br><span class=\"line\">\ttail *sudog</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Wait-1\"><a href=\"#Wait-1\" class=\"headerlink\" title=\"Wait\"></a>Wait</h4><p>使用 Wait 方法前必须加锁保护条件变量，处理完成后解锁</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//    c.L.Lock()</span></span><br><span class=\"line\"><span class=\"comment\">//    for !condition() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        c.Wait()</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    ... make use of condition ...</span></span><br><span class=\"line\"><span class=\"comment\">//    c.L.Unlock()</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cond)</span> <span class=\"title\">Wait</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc.checker.check()</span><br><span class=\"line\">  <span class=\"comment\">// 通知数量加 1</span></span><br><span class=\"line\">\tt := runtime_notifyListAdd(&amp;c.notify)</span><br><span class=\"line\">\tc.L.Unlock()</span><br><span class=\"line\">  <span class=\"comment\">// 进入休眠，将当前 goroutine 加入通知链表</span></span><br><span class=\"line\">\truntime_notifyListWait(&amp;c.notify, t)</span><br><span class=\"line\">\tc.L.Lock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Notify\"><a href=\"#Notify\" class=\"headerlink\" title=\"Notify\"></a>Notify</h4><p>共有两个方法，一个唤醒队列最前的 goroutine，一个唤醒所有的 goroutine</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cond)</span> <span class=\"title\">Signal</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc.checker.check()</span><br><span class=\"line\">\truntime_notifyListNotifyOne(&amp;c.notify)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cond)</span> <span class=\"title\">Broadcast</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc.checker.check()</span><br><span class=\"line\">\truntime_notifyListNotifyAll(&amp;c.notify)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个非常好的使用 Cond 的例子， k8s 里的 <a href=\"https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/fifo.go\" target=\"_blank\" rel=\"noopener\">FIFO</a></p>\n<p>###Pool</p>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - timer","url":"http://localhost:4000/2019/11/02/go-timer/","content":"<p>Golang 里的定时功能主要是这两个结构体 <code>Timer</code> 和 <code>Ticker</code>，使用方法就不赘述了，直接来看具体实现吧。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Timer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tC &lt;-<span class=\"keyword\">chan</span> Time</span><br><span class=\"line\">\tr runtimeTimer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewTimer</span><span class=\"params\">(d Duration)</span> *<span class=\"title\">Timer</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> Time, <span class=\"number\">1</span>)</span><br><span class=\"line\">\tt := &amp;Timer&#123;</span><br><span class=\"line\">\t\tC: c,</span><br><span class=\"line\">\t\tr: runtimeTimer&#123;</span><br><span class=\"line\">\t\t\twhen: when(d),</span><br><span class=\"line\">\t\t\tf:    sendTime, <span class=\"comment\">// 触发后执行的函数</span></span><br><span class=\"line\">\t\t\targ:  c,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstartTimer(&amp;t.r)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将当前时间放入 channel 中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendTime</span><span class=\"params\">(c <span class=\"keyword\">interface</span>&#123;&#125;, seq <span class=\"keyword\">uintptr</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> c.(<span class=\"keyword\">chan</span> Time) &lt;- Now():</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Timer)</span> <span class=\"title\">Stop</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t.r.f == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"time: Stop called on uninitialized Timer\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stopTimer(&amp;t.r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Timer)</span> <span class=\"title\">Reset</span><span class=\"params\">(d Duration)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t.r.f == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"time: Reset called on uninitialized Timer\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tw := when(d)</span><br><span class=\"line\">\tactive := stopTimer(&amp;t.r)</span><br><span class=\"line\">\tt.r.when = w</span><br><span class=\"line\">\tstartTimer(&amp;t.r)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> active</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Timer</code> 的结构很简单，可以看到具体的实现都是对 runtimeTimer 结构体进行操作，<code>Ticker</code> 与 <code>Timer</code> 本质区别仅仅在于多设置了一个 period 字段。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewTicker</span><span class=\"params\">(d Duration)</span> *<span class=\"title\">Ticker</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> d &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(errors.New(<span class=\"string\">\"non-positive interval for NewTicker\"</span>))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> Time, <span class=\"number\">1</span>)</span><br><span class=\"line\">\tt := &amp;Ticker&#123;</span><br><span class=\"line\">\t\tC: c,</span><br><span class=\"line\">\t\tr: runtimeTimer&#123;</span><br><span class=\"line\">\t\t\twhen:   when(d),</span><br><span class=\"line\">\t\t\tperiod: <span class=\"keyword\">int64</span>(d),</span><br><span class=\"line\">\t\t\tf:      sendTime,</span><br><span class=\"line\">\t\t\targ:    c,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstartTimer(&amp;t.r)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来看下 <code>runtimeTimer</code> 的结构</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> runtimeTimer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\ttb *timersBucket   <span class=\"comment\">// 所在的 timersBucket，是个四叉小顶堆</span></span><br><span class=\"line\">\ti  <span class=\"keyword\">int</span>             <span class=\"comment\">// 堆里的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">\twhen   <span class=\"keyword\">int64</span>       <span class=\"comment\">// 触发时间</span></span><br><span class=\"line\">\tperiod <span class=\"keyword\">int64</span>       <span class=\"comment\">// 周期</span></span><br><span class=\"line\">\tf      <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"keyword\">uintptr</span>)</span> // 触发后执行的函数</span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"title\">arg</span>    <span class=\"title\">interface</span></span>&#123;&#125; <span class=\"comment\">// 上面 f 的第一个参数</span></span><br><span class=\"line\">\tseq    <span class=\"keyword\">uintptr</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>早期的 timersBucket 是个全局对象，操作需要加锁，多核心会出现竞争锁导致性能低下的问题，1.10 后将数量提高至 64 个，基本实现 per-P，但是如果 P 的个数大于 64 个，那么会出现多个 P 共用一个 bucket。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> timersLen = <span class=\"number\">64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> timers [timersLen]<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\ttimersBucket</span><br><span class=\"line\">\t<span class=\"comment\">// 填充 struct 到 cacheline 的整数倍，以避免在不同的 P 之间发生 false sharing</span></span><br><span class=\"line\">\tpad [cpu.CacheLinePadSize - unsafe.Sizeof(timersBucket&#123;&#125;)%cpu.CacheLinePadSize]<span class=\"keyword\">byte</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> timersBucket <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tlock         mutex</span><br><span class=\"line\">\tgp           *g</span><br><span class=\"line\">\tcreated      <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tsleeping     <span class=\"keyword\">bool</span></span><br><span class=\"line\">\trescheduling <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tsleepUntil   <span class=\"keyword\">int64</span></span><br><span class=\"line\">\twaitnote     note</span><br><span class=\"line\">\tt            []*timer  <span class=\"comment\">// 四叉小顶堆</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取 timer 所属的 timersBucket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *timer)</span> <span class=\"title\">assignBucket</span><span class=\"params\">()</span> *<span class=\"title\">timersBucket</span></span> &#123;</span><br><span class=\"line\">\tid := <span class=\"keyword\">uint8</span>(getg().m.p.ptr().id) % timersLen</span><br><span class=\"line\">\tt.tb = &amp;timers[id].timersBucket</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t.tb</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><p>创建了一个 <code>Timer</code> 或 <code>Ticker</code> 后，就会调用 <code>startTimer</code> 方法将 timer 添加至小顶堆里</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startTimer</span><span class=\"params\">(t *timer)</span></span> &#123;</span><br><span class=\"line\">\taddtimer(t)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addtimer</span><span class=\"params\">(t *timer)</span></span> &#123;</span><br><span class=\"line\">\ttb := t.assignBucket()</span><br><span class=\"line\">\tlock(&amp;tb.lock)</span><br><span class=\"line\">\tok := tb.addtimerLocked(t)</span><br><span class=\"line\">\tunlock(&amp;tb.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\tbadTimer()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向时间堆里添加一个 timer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(tb *timersBucket)</span> <span class=\"title\">addtimerLocked</span><span class=\"params\">(t *timer)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// when 必须大于 0，否则会在计算 delta 的时候溢出并导致其它的 runtime timer 永远没法过期</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t.when &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tt.when = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">63</span> - <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tt.i = <span class=\"built_in\">len</span>(tb.t)</span><br><span class=\"line\">\ttb.t = <span class=\"built_in\">append</span>(tb.t, t)</span><br><span class=\"line\">  <span class=\"comment\">// 维持小顶堆结构</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !siftupTimer(tb.t, t.i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t.i == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 新的 timer 在堆里最先超时，唤醒 timerproc，重新调整时间</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> tb.sleeping &amp;&amp; tb.sleepUntil &gt; t.when &#123;</span><br><span class=\"line\">\t\t\ttb.sleeping = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\tnotewakeup(&amp;tb.waitnote)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// gopark 休眠的需要 goready 唤醒</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> tb.rescheduling &#123;</span><br><span class=\"line\">\t\t\ttb.rescheduling = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\tgoready(tb.gp, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 首次创建 timerBucket，启动一个 goroutine 用于循环触发时间堆</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !tb.created &#123;</span><br><span class=\"line\">\t\t\ttb.created = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">go</span> timerproc(tb)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"触发\"><a href=\"#触发\" class=\"headerlink\" title=\"触发\"></a>触发</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">timerproc</span><span class=\"params\">(tb *timersBucket)</span></span> &#123;</span><br><span class=\"line\">\ttb.gp = getg()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tlock(&amp;tb.lock)</span><br><span class=\"line\">\t\ttb.sleeping = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\tnow := nanotime()</span><br><span class=\"line\">\t\tdelta := <span class=\"keyword\">int64</span>(<span class=\"number\">-1</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// bucket 里无 timer 跳出循环，休眠等待唤醒</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(tb.t) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tdelta = <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tt := tb.t[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\tdelta = t.when - now</span><br><span class=\"line\">      <span class=\"comment\">// 最近的 timer 还没到触发时间，跳出循环等待</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> delta &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tok := <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> t.period &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// Ticker 重新计算超时时间并加入堆中</span></span><br><span class=\"line\">\t\t\t\tt.when += t.period * (<span class=\"number\">1</span> + -delta/t.period)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> !siftdownTimer(tb.t, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tok = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 非 Ticker 从堆中删除</span></span><br><span class=\"line\">\t\t\t\tlast := <span class=\"built_in\">len</span>(tb.t) - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> last &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\ttb.t[<span class=\"number\">0</span>] = tb.t[last]</span><br><span class=\"line\">\t\t\t\t\ttb.t[<span class=\"number\">0</span>].i = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\ttb.t[last] = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t\ttb.t = tb.t[:last]</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> last &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> !siftdownTimer(tb.t, <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tok = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tt.i = <span class=\"number\">-1</span> <span class=\"comment\">// mark as removed</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 开始触发，调用触发函数 f</span></span><br><span class=\"line\">\t\t\tf := t.f</span><br><span class=\"line\">\t\t\targ := t.arg</span><br><span class=\"line\">\t\t\tseq := t.seq</span><br><span class=\"line\">\t\t\tunlock(&amp;tb.lock)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\tbadTimer()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tf(arg, seq)</span><br><span class=\"line\">\t\t\tlock(&amp;tb.lock)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 堆里无 timer，使用 gopark 休眠</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> delta &lt; <span class=\"number\">0</span> || faketime &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\ttb.rescheduling = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\tgoparkunlock(&amp;tb.lock, waitReasonTimerGoroutineIdle, traceEvGoBlock, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 堆里有 timer，设置休眠时间，到点后唤醒</span></span><br><span class=\"line\">    <span class=\"comment\">// 内部使用了 futex sleep</span></span><br><span class=\"line\">\t\ttb.sleeping = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\ttb.sleepUntil = now + delta</span><br><span class=\"line\">\t\tnoteclear(&amp;tb.waitnote)</span><br><span class=\"line\">\t\tunlock(&amp;tb.lock)</span><br><span class=\"line\">\t\tnotetsleepg(&amp;tb.waitnote, delta)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>stopTimer 就是简单的将 timer 从堆中移除，就不详细说明了</p>\n<h4 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h4><p><code>time.After</code> 和 <code>time.AfterFunc</code> 就是对 Timer 简单包装，<code>time.Sleep</code>  方法实现有点意思</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">timeSleep</span><span class=\"params\">(ns <span class=\"keyword\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ns &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgp := getg()</span><br><span class=\"line\">\tt := gp.timer</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tt = <span class=\"built_in\">new</span>(timer)</span><br><span class=\"line\">\t\tgp.timer = t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 构造内部使用的 timer</span></span><br><span class=\"line\">\t*t = timer&#123;&#125;</span><br><span class=\"line\">\tt.when = nanotime() + ns   <span class=\"comment\">// 设置休眠时间</span></span><br><span class=\"line\">\tt.f = goroutineReady       <span class=\"comment\">// 触发函数为 goready</span></span><br><span class=\"line\">\tt.arg = gp                 <span class=\"comment\">// 参数为当前的 goroutine</span></span><br><span class=\"line\">\ttb := t.assignBucket()</span><br><span class=\"line\">\tlock(&amp;tb.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !tb.addtimerLocked(t) &#123;</span><br><span class=\"line\">\t\tunlock(&amp;tb.lock)</span><br><span class=\"line\">\t\tbadTimer()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将当前 goroutine 陷入休眠</span></span><br><span class=\"line\">\tgoparkunlock(&amp;tb.lock, waitReasonSleep, traceEvGoSleep, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">goroutineReady</span><span class=\"params\">(arg <span class=\"keyword\">interface</span>&#123;&#125;, seq <span class=\"keyword\">uintptr</span>)</span></span> &#123;</span><br><span class=\"line\">\tgoready(arg.(*g), <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>Golang 的定时器目前在大多数情况能够正常且高效的完成任务，但是遇到极端情况，比如并发上万个且触发时间只有毫秒级别的定时器时，会有非常明显的误差。这是因为设置 timer 休眠超时后自动唤醒属于系统调用，会将 M 和 P 进行解绑，调用结束后又重新绑定，一旦操作过于频繁，因为锁的竞争性能会急剧下降。</p>\n<p>在目前的 1.14 beta 版本中，Go 修改了 timer 的实现，超时处理使用 netpoll 触发，每个 timer 堆都绑定在一个 P 上，避免了唤醒 timer 时的 M/P 切换，大幅缩减了锁的竞争，具体实现之后有机会了再分享。</p>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - netpoll","url":"http://localhost:4000/2019/10/20/go-netpoll/","content":"<p>Golang 的 netpoll 在不同的操作系统底层使用的 I/O 多路复用技术不同，比如在 Linux 下使用的 epoll，Windows 下使用 iocp 等，本次源码分析主要是针对 Linux 平台进行的。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>分析源码前首先需要了解下现有 I/O 流程和模型，对于一次 I/O 访问，以 read 为例，数据会先被拷贝到操作系统内核缓冲区中，然后才会从内核缓冲区中拷贝到用户空间，也就是应用程序的地址空间。所以说，当一个 read 操作发生时，它会经历两个阶段：</p>\n<ol>\n<li>等待数据准备就绪，也就是说数据已被拷贝到操作系统的内核缓冲区</li>\n<li>将数据从内核拷贝到应用程序进程中</li>\n</ol>\n<p>正是由于这两个步骤，产生了 5 种 I/O 模型：</p>\n<ul>\n<li>阻塞 I/O </li>\n<li>非阻塞 I/O </li>\n<li>I/O 多路复用</li>\n<li>异步 I/O</li>\n<li>信号驱动 I/O</li>\n</ul>\n<p>判断一个 I/O 模型是同步还是异步，主要是看上面的第二步操作，数据在用户空间和内核空间复制的时候会不会阻塞当前进程，如果会就是同步 I/O，否则就是异步 I/O。根据这个原则，除了上面明确标示是异步 I/O 模型的其他都是同步 I/O。</p>\n<p>这里可能会有个疑惑是非阻塞 I/O 为什么是同步 I/O，而非异步的。我们这里要明确一下非阻塞的概念，当使用非阻塞 I/O 模型进行 I/O 操作时，如果内核数据没有准备就绪，那么它不会阻塞当前线程，而是立即返回一个 error。从用户进程角度来看，我发起了一个 I/O 操作，不需等待，直接拿到个结果，这就是非阻塞，然后根据结果来判断数据目前的状态，通过多次的 I/O 操作直到数据准备就绪，将数据从内核拷贝到用户内存中，这个拷贝的过程中用户进程时被阻塞的，所以说它是同步 I/O。</p>\n<p>I/O 多路复用指的是 select/poll/epoll 这一系列的多路选择器，支持单个线程同时监听多个 fd，阻塞等待，并在其中某个 fd 可读可写时收到通知。I/O 复用是复用的线程，让一个线程能够处理多个 I/O 事件。I/O 的读写还是需要用户进程自己负责，读写的过程是阻塞的，所以 I/O 多路复用也属于同步 I/O。</p>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>select 和 poll 这里不多介绍，主要说明下 epoll，epoll 和前面两个的区别是，不用每次监听时都把全部要监听的 fd 集合从用户态拷贝到内核态，事件触发后不会线性扫描 fd 集合查找触发的 fd。</p>\n<p>epoll 的 API 非常简洁，只有3个</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个 epoll 句柄，返回一个 fd</span></span><br><span class=\"line\"><span class=\"comment\">// size 不是限制能够监听的最大数量，只是对内核初始化分配内部数据结构对一个建议</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对指定 fd 进行相关操作</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// epfd :上面的创建的 epoll fd</span></span><br><span class=\"line\"><span class=\"comment\">// op :增加、删除、修改</span></span><br><span class=\"line\"><span class=\"comment\">// fd :需要监听的 fd</span></span><br><span class=\"line\"><span class=\"comment\">// event :告诉内核需要监听什么事</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, <span class=\"keyword\">int</span> op, <span class=\"keyword\">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待 epfd 上的 I/O 事件</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// events :内核将就绪事件拷贝到此处</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_wait</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, struct epoll_event * events, <span class=\"keyword\">int</span> maxevents, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>大致的工作原理如下：</p>\n<ol>\n<li>初始化一个 epoll ，返回一个 fd</li>\n<li>通过 epoll_ctl 添加或删除需要监听的 fd，内部使用红黑树来存储，并且会与相应的设备建立回调关系，也就是在内核中断处理程序为它注册一个回调函数，在 fd 相应的事件触发（中断）之后（设备就绪了），内核就会调用这个回调函数，该回调函数在内核中被称为  <code>ep_poll_callback</code></li>\n<li><code>ep_poll_callback</code> 被调用说明 epoll 某个 fd 有事件发生，然后把这个 fd 添加到 rdllist 双向链表中 (就绪链表)，如果处于 epoll_wait 阻塞状态，还是通过 <em>wake_up_locked</em> 将其唤醒</li>\n<li>通过 epoll_wait 检查 rdllist，如果为空挂起线程，否则调用 <em>ep_send_events</em> 将 rdllist 返回给用户态</li>\n</ol>\n<h3 id=\"netpoll\"><a href=\"#netpoll\" class=\"headerlink\" title=\"netpoll\"></a>netpoll</h3><p>Golang 的原生网络模型 netpoll 就是基于 epoll 和非阻塞 I/O 实现的，再借助于 scheduler 的调度可以使用同步编程达到异步执行的效果。下面我们来通过源码了解下整个 netpoll 的运行流程。</p>\n<h4 id=\"listen\"><a href=\"#listen\" class=\"headerlink\" title=\"listen\"></a>listen</h4><p>首先来看看 TCP 相关结构，然后一步步往底层去分析</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TCPListener <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tfd *netFD</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// listen 方法会生成一个 TCPListener 对象</span></span><br><span class=\"line\"><span class=\"comment\">// 底层会调用 socket 方法创建一个 fd，并初始化 netFd 并监听端口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sl *sysListener)</span> <span class=\"title\">listenTCP</span><span class=\"params\">(ctx context.Context, laddr *TCPAddr)</span> <span class=\"params\">(*TCPListener, error)</span></span> &#123;</span><br><span class=\"line\">\tfd, err := internetSocket(ctx, sl.network, laddr, <span class=\"literal\">nil</span>, syscall.SOCK_STREAM, <span class=\"number\">0</span>, <span class=\"string\">\"listen\"</span>, sl.ListenConfig.Control)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;TCPListener&#123;fd&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过 netFd 返回一个 connNetFd，包装成 connection</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ln *TCPListener)</span> <span class=\"title\">accept</span><span class=\"params\">()</span> <span class=\"params\">(*TCPConn, error)</span></span> &#123;</span><br><span class=\"line\">\tfd, err := ln.fd.accept()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newTCPConn(fd), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> conn <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tfd *netFD</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *conn)</span> <span class=\"title\">Read</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !c.ok() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, syscall.EINVAL</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn, err := c.fd.Read(b)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class=\"line\">\t\terr = &amp;OpError&#123;Op: <span class=\"string\">\"read\"</span>, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *conn)</span> <span class=\"title\">Write</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !c.ok() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>, syscall.EINVAL</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn, err := c.fd.Write(b)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\terr = &amp;OpError&#123;Op: <span class=\"string\">\"write\"</span>, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到所有相关操作都是通过 netFd 进行的，netFd  中包含一个 poll.FD 结构，而 poll.FD 中又包含两个重要的数据结构 Sysfd 和 pollDesc，前者是真正的系统文件描述符，后者是对 epoll 的封装，所有的读写超时等操作都是通过它实现的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> netFD <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tpfd poll.FD</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// immutable until Close</span></span><br><span class=\"line\">\tfamily      <span class=\"keyword\">int</span></span><br><span class=\"line\">\tsotype      <span class=\"keyword\">int</span></span><br><span class=\"line\">\tisConnected <span class=\"keyword\">bool</span> <span class=\"comment\">// handshake completed or use of association with peer</span></span><br><span class=\"line\">\tnet         <span class=\"keyword\">string</span></span><br><span class=\"line\">\tladdr       Addr</span><br><span class=\"line\">\traddr       Addr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 listen 后会通过 socket 创建系统 fd，然后初始化 netFd，最后绑定端口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newFD</span><span class=\"params\">(sysfd, family, sotype <span class=\"keyword\">int</span>, net <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*netFD, error)</span></span> &#123;</span><br><span class=\"line\">\tret := &amp;netFD&#123;</span><br><span class=\"line\">\t\tpfd: poll.FD&#123;</span><br><span class=\"line\">\t\t\tSysfd:         sysfd,</span><br><span class=\"line\">\t\t\tIsStream:      sotype == syscall.SOCK_STREAM,</span><br><span class=\"line\">\t\t\tZeroReadIsEOF: sotype != syscall.SOCK_DGRAM &amp;&amp; sotype != syscall.SOCK_RAW,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tfamily: family,</span><br><span class=\"line\">\t\tsotype: sotype,</span><br><span class=\"line\">\t\tnet:    net,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化 pfd 里的 pollDesc，也就是底层的 epoll</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(fd *netFD)</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fd.pfd.Init(fd.net, <span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 listenTCP 后面整个初始化顺序是：</p>\n<ol>\n<li>进入 internetSocket -&gt; socket 里<ul>\n<li>sysSocket 创建系统 fd，会设置为非阻塞</li>\n<li>调用 newFD 初始化</li>\n<li>调用 listenStream 绑定 fd 和端口，里面调用 init 函数初始化 epoll 实例，并将 fd 加入 epoll 事件队列</li>\n</ul>\n</li>\n<li>初始化 TCPListener 对象</li>\n</ol>\n<p>重点来看下 init 函数，里面会调用 poll.FD 的 init，再调用 pollDesc 的 init 方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FD <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tfdmu fdMutex</span><br><span class=\"line\">\tSysfd <span class=\"keyword\">int</span></span><br><span class=\"line\">\tpd pollDesc  <span class=\"comment\">// I/O poller.</span></span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(fd *FD)</span> <span class=\"title\">Init</span><span class=\"params\">(net <span class=\"keyword\">string</span>, pollable <span class=\"keyword\">bool</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> net == <span class=\"string\">\"file\"</span> &#123;</span><br><span class=\"line\">\t\tfd.isFile = <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !pollable &#123;</span><br><span class=\"line\">\t\tfd.isBlocking = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 调用 pollDesc 的 init 方法</span></span><br><span class=\"line\">\terr := fd.pd.init(fd)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfd.isBlocking = <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> pollDesc <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\truntimeCtx <span class=\"keyword\">uintptr</span> <span class=\"comment\">// 指向的是内部一个 pollDesc 对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pd *pollDesc)</span> <span class=\"title\">init</span><span class=\"params\">(fd *FD)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化 epoll 实例，全局只有一个</span></span><br><span class=\"line\">\tserverInit.Do(runtime_pollServerInit)</span><br><span class=\"line\">  <span class=\"comment\">// 将 listener fd 注册到 epoll 实例上，并初始化一个内部的 pollDesc 返回</span></span><br><span class=\"line\">\tctx, errno := runtime_pollOpen(<span class=\"keyword\">uintptr</span>(fd.Sysfd))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> errno != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ctx != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\truntime_pollUnblock(ctx)</span><br><span class=\"line\">\t\t\truntime_pollClose(ctx)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> syscall.Errno(errno)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpd.runtimeCtx = ctx</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续看 runtime 里的实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> pollDesc <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tlink *pollDesc  <span class=\"comment\">// in pollcache, protected by pollcache.lock</span></span><br><span class=\"line\">\tlock    mutex   <span class=\"comment\">// protects the following fields</span></span><br><span class=\"line\">\tfd      <span class=\"keyword\">uintptr</span></span><br><span class=\"line\">\tclosing <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tuser    <span class=\"keyword\">uint32</span>  <span class=\"comment\">// user settable cookie</span></span><br><span class=\"line\">\trseq    <span class=\"keyword\">uintptr</span> <span class=\"comment\">// protects from stale read timers</span></span><br><span class=\"line\">\trg      <span class=\"keyword\">uintptr</span> <span class=\"comment\">// pdReady, pdWait, G waiting for read or nil</span></span><br><span class=\"line\">\trt      timer   <span class=\"comment\">// read deadline timer (set if rt.f != nil)</span></span><br><span class=\"line\">\trd      <span class=\"keyword\">int64</span>   <span class=\"comment\">// read deadline</span></span><br><span class=\"line\">\twseq    <span class=\"keyword\">uintptr</span> <span class=\"comment\">// protects from stale write timers</span></span><br><span class=\"line\">\twg      <span class=\"keyword\">uintptr</span> <span class=\"comment\">// pdReady, pdWait, G waiting for write or nil</span></span><br><span class=\"line\">\twt      timer   <span class=\"comment\">// write deadline timer</span></span><br><span class=\"line\">\twd      <span class=\"keyword\">int64</span>   <span class=\"comment\">// write deadline</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tepfd <span class=\"keyword\">int32</span> = <span class=\"number\">-1</span> <span class=\"comment\">// epoll descriptor</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">poll_runtime_pollServerInit</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tnetpollinit()</span><br><span class=\"line\">\tatomic.Store(&amp;netpollInited, <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对应上面的 runtime_pollOpen</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">poll_runtime_pollOpen</span><span class=\"params\">(fd <span class=\"keyword\">uintptr</span>)</span> <span class=\"params\">(*pollDesc, <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tpd := pollcache.alloc() <span class=\"comment\">// pollDesc 在堆外内存分配</span></span><br><span class=\"line\">\tlock(&amp;pd.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> pd.wg != <span class=\"number\">0</span> &amp;&amp; pd.wg != pdReady &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime: blocked write on free polldesc\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> pd.rg != <span class=\"number\">0</span> &amp;&amp; pd.rg != pdReady &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime: blocked read on free polldesc\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpd.fd = fd</span><br><span class=\"line\">\tpd.closing = <span class=\"literal\">false</span></span><br><span class=\"line\">\tpd.rseq++</span><br><span class=\"line\">\tpd.rg = <span class=\"number\">0</span></span><br><span class=\"line\">\tpd.rd = <span class=\"number\">0</span></span><br><span class=\"line\">\tpd.wseq++</span><br><span class=\"line\">\tpd.wg = <span class=\"number\">0</span></span><br><span class=\"line\">\tpd.wd = <span class=\"number\">0</span></span><br><span class=\"line\">\tunlock(&amp;pd.lock)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> errno <span class=\"keyword\">int32</span></span><br><span class=\"line\">\terrno = netpollopen(fd, pd)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pd, <span class=\"keyword\">int</span>(errno)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化 epoll 实例，调用的 epoll 的 create 方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">netpollinit</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tepfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> epfd &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tepfd = epollcreate(<span class=\"number\">1024</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> epfd &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tcloseonexec(epfd)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">println</span>(<span class=\"string\">\"runtime: epollcreate failed with\"</span>, -epfd)</span><br><span class=\"line\">\tthrow(<span class=\"string\">\"runtime: netpollinit failed\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 listener 的 fd 注册到 epoll 实例上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">netpollopen</span><span class=\"params\">(fd <span class=\"keyword\">uintptr</span>, pd *pollDesc)</span> <span class=\"title\">int32</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> ev epollevent</span><br><span class=\"line\">\tev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class=\"line\">  <span class=\"comment\">// 将 pd 放入 event 中</span></span><br><span class=\"line\">\t*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class=\"keyword\">int32</span>(fd), &amp;ev)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，完成了整个 listen 的过程，下面来分析 accept 的流程</p>\n<h4 id=\"accept\"><a href=\"#accept\" class=\"headerlink\" title=\"accept\"></a>accept</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(fd *netFD)</span> <span class=\"title\">accept</span><span class=\"params\">()</span> <span class=\"params\">(netfd *netFD, err error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用 poll.FD 的 Accept 方法接受新的 socket 链接并返回 socket 的 fd</span></span><br><span class=\"line\">\td, rsa, errcall, err := fd.pfd.Accept()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> errcall != <span class=\"string\">\"\"</span> &#123;</span><br><span class=\"line\">\t\t\terr = wrapSyscallError(errcall, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 以返回的 fd 构建一个新的 netFD，后面会包装成 connection</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tpoll.CloseFunc(d)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 注册到 epoll 实例上</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err = netfd.init(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfd.Close()</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlsa, _ := syscall.Getsockname(netfd.pfd.Sysfd)</span><br><span class=\"line\">\tnetfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> netfd, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// poll.FD</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(fd *FD)</span> <span class=\"title\">Accept</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">int</span>, syscall.Sockaddr, <span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := fd.readLock(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, <span class=\"string\">\"\"</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> fd.readUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := fd.pd.prepareRead(fd.isFile); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, <span class=\"string\">\"\"</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用系统 accept 方法接受新连接，</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为 listener 的 fd 在初始化时已经设置非阻塞，所以这个方法会直接返回，不管有没有连接</span></span><br><span class=\"line\">\t\ts, rsa, errcall, err := accept(fd.Sysfd)</span><br><span class=\"line\">    <span class=\"comment\">// err 为 nil，表示正常建立了新连接，直接放回新 socket 的 fd，内部已经设置为非阻塞</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> s, rsa, <span class=\"string\">\"\"</span>, err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> err &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> syscall.EAGAIN: <span class=\"comment\">// 未准备就绪，调用 waitRead 方法进入休眠</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> fd.pd.pollable() &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> syscall.ECONNABORTED:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, errcall, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>pollDesc.waitRead</code> 主要是检测对应的 fd 有没有事件发生，如果没有将当前 goroutine 陷入休眠，直到有事件发生后唤醒。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">poll_runtime_pollWait</span><span class=\"params\">(pd *pollDesc, mode <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\terr := netpollcheckerr(pd, <span class=\"keyword\">int32</span>(mode))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> GOOS == <span class=\"string\">\"solaris\"</span> || GOOS == <span class=\"string\">\"aix\"</span> &#123;</span><br><span class=\"line\">\t\tnetpollarm(pd, mode)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断是否有 I/O 事件发生</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> !netpollblock(pd, <span class=\"keyword\">int32</span>(mode), <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">\t\terr = netpollcheckerr(pd, <span class=\"keyword\">int32</span>(mode))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">netpollblock</span><span class=\"params\">(pd *pollDesc, mode <span class=\"keyword\">int32</span>, waitio <span class=\"keyword\">bool</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\tgpp := &amp;pd.rg</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mode == <span class=\"string\">'w'</span> &#123;</span><br><span class=\"line\">\t\tgpp = &amp;pd.wg</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// set the gpp semaphore to WAIT</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\told := *gpp</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> old == pdReady &#123;</span><br><span class=\"line\">\t\t\t*gpp = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> old != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"runtime: double wait\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> atomic.Casuintptr(gpp, <span class=\"number\">0</span>, pdWait) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> waitio || netpollcheckerr(pd, mode) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将当前 goroutine 设为休眠，通过 netpollblockcommit 设置 pd 的 gpp 为当前 goroutine</span></span><br><span class=\"line\">\t\tgopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class=\"number\">5</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// be careful to not lose concurrent READY notification</span></span><br><span class=\"line\">\told := atomic.Xchguintptr(gpp, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> old &gt; pdWait &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime: corrupted polldesc\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> old == pdReady</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Accept 获取的 netFD 包装成 connection 后，它的 Read/Write 方法内部实现原理和 Accept 差不多，都是非阻塞调用，如果无事件发生通过 runtime_pollWait 进入休眠等待唤醒。</p>\n<h4 id=\"唤醒\"><a href=\"#唤醒\" class=\"headerlink\" title=\"唤醒\"></a>唤醒</h4><p>前面通过源码分析了 netpoll 在无事件发生时将当前 goroutine 设为休眠，那么当 I/O 事件发生后，谁来将它唤醒的？答案就是上面未曾用到的 epoll_wait 方法，使用这个方法的函数是 netpoll，他内部调用了 epoll_wait 获取就绪的 fd 列表，并将每个 fd 对应的 goroutine 添加到 gList 链表返回。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">netpoll</span><span class=\"params\">(block <span class=\"keyword\">bool</span>)</span> <span class=\"title\">gList</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> epfd == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> gList&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twaitms := <span class=\"keyword\">int32</span>(<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !block &#123;</span><br><span class=\"line\">\t\twaitms = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> events [<span class=\"number\">128</span>]epollevent</span><br><span class=\"line\">retry:</span><br><span class=\"line\">  <span class=\"comment\">// 获取就绪的 fd 列表</span></span><br><span class=\"line\">  <span class=\"comment\">// waitms=0 非阻塞立即返回，无论有没有事件</span></span><br><span class=\"line\">  <span class=\"comment\">// waitms=-1 无事件进入休眠，等待事件发生时唤醒</span></span><br><span class=\"line\">\tn := epollwait(epfd, &amp;events[<span class=\"number\">0</span>], <span class=\"keyword\">int32</span>(<span class=\"built_in\">len</span>(events)), waitms)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n != -_EINTR &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">println</span>(<span class=\"string\">\"runtime: epollwait on fd\"</span>, epfd, <span class=\"string\">\"failed with\"</span>, -n)</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"runtime: netpoll failed\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> retry</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// toRun 是需要唤醒的 goroutine 链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> toRun gList</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>); i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\tev := &amp;events[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ev.events == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> mode <span class=\"keyword\">int32</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tmode += <span class=\"string\">'r'</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tmode += <span class=\"string\">'w'</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> mode != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tpd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通过 fd 的 pollDesc 获取对应的 goroutine</span></span><br><span class=\"line\">\t\t\tnetpollready(&amp;toRun, pd, mode)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> block &amp;&amp; toRun.empty() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> retry</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> toRun</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对应的 goroutine 是进入休眠时，通过回调函数 netpollblockcommit 设置到 pollDesc 对象上的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">netpollready</span><span class=\"params\">(toRun *gList, pd *pollDesc, mode <span class=\"keyword\">int32</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> rg, wg *g</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mode == <span class=\"string\">'r'</span> || mode == <span class=\"string\">'r'</span>+<span class=\"string\">'w'</span> &#123;</span><br><span class=\"line\">\t\trg = netpollunblock(pd, <span class=\"string\">'r'</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mode == <span class=\"string\">'w'</span> || mode == <span class=\"string\">'r'</span>+<span class=\"string\">'w'</span> &#123;</span><br><span class=\"line\">\t\twg = netpollunblock(pd, <span class=\"string\">'w'</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> rg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\ttoRun.push(rg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> wg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\ttoRun.push(wg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Go 在多种场景下都可能会调用 netpoll 来获取就绪的 goroutine，将它们加入调度队列等待运行。</p>\n<p>首先在正常的调度循环 schedule 里的 findrunnable 函数中执行</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findrunnable</span><span class=\"params\">()</span> <span class=\"params\">(gp *g, inheritTime <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\">top:</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class=\"number\">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先先用非阻塞方式获取就绪的 goroutine</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> list := netpoll(<span class=\"literal\">false</span>); !list.empty() &#123;</span><br><span class=\"line\">\t\t\tgp := list.pop()</span><br><span class=\"line\">\t\t\tinjectglist(&amp;list) <span class=\"comment\">// 将链表其余的 goroutine 加入等待运行队列</span></span><br><span class=\"line\">\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\t\t\ttraceGoUnpark(gp, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> gp, <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">stop:</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class=\"number\">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class=\"number\">0</span>) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"findrunnable: netpoll with p\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.spinning &#123;</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"findrunnable: netpoll with spinning\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlist := netpoll(<span class=\"literal\">true</span>) <span class=\"comment\">// 阻塞调用，直到有 I/O 事件触发唤醒 epoll 实例</span></span><br><span class=\"line\">\t\tatomic.Store64(&amp;sched.lastpoll, <span class=\"keyword\">uint64</span>(nanotime()))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !list.empty() &#123;</span><br><span class=\"line\">\t\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t\t_p_ = pidleget()</span><br><span class=\"line\">\t\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> _p_ != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tacquirep(_p_)</span><br><span class=\"line\">\t\t\t\tgp := list.pop()</span><br><span class=\"line\">\t\t\t\tinjectglist(&amp;list)</span><br><span class=\"line\">\t\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\t\t\t\ttraceGoUnpark(gp, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> gp, <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tinjectglist(&amp;list)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstopm()</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> top</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外，sysmon 系统监控里也会调用 netpoll 检查有没有就绪的事件，GC 过程中的 startTheWorldWithSema 后也会调用，这两个调用都是非阻塞调用。</p>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - context","url":"http://localhost:4000/2019/08/14/go-context/","content":"<p>context 是用来解决一组相关联的 goroutine 的同步退出及元数据传递的功能。</p>\n<h4 id=\"Context-接口\"><a href=\"#Context-接口\" class=\"headerlink\" title=\"Context 接口\"></a>Context 接口</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接口定义的四个方法都是幂等的</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 返回当前 context 截止日期</span></span><br><span class=\"line\">\tDeadline() (deadline time.Time, ok <span class=\"keyword\">bool</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回一个 channel，当 context 被取消或到截止日期后，channel 会被关闭</span></span><br><span class=\"line\">\tDone() &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 在 Done 关闭后，返回取消原因</span></span><br><span class=\"line\">\tErr() error</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取 key 对应的 value</span></span><br><span class=\"line\">\tValue(key <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>包中定义了一个空结构体 emptyCtx 实现了 context 接口，这个空的 context 永远不会 cancel，background 和 todo 都是此结构体。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tbackground = <span class=\"built_in\">new</span>(emptyCtx)</span><br><span class=\"line\">\ttodo       = <span class=\"built_in\">new</span>(emptyCtx)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"canceler-接口\"><a href=\"#canceler-接口\" class=\"headerlink\" title=\"canceler 接口\"></a>canceler 接口</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现了 canceler 接口的 context 表明是可以被取消的</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> canceler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tcancel(removeFromParent <span class=\"keyword\">bool</span>, err error)</span><br><span class=\"line\">\tDone() &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>cancelCtx 结构体实现了 canceler 接口，这是一个可以取消的 context</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> cancelCtx <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tContext</span><br><span class=\"line\"></span><br><span class=\"line\">\tmu       sync.Mutex            <span class=\"comment\">// protects following fields</span></span><br><span class=\"line\">\tdone     <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;         <span class=\"comment\">// created lazily, closed by first cancel call</span></span><br><span class=\"line\">\tchildren <span class=\"keyword\">map</span>[canceler]<span class=\"keyword\">struct</span>&#123;&#125; <span class=\"comment\">// set to nil by the first cancel call</span></span><br><span class=\"line\">\terr      error                 <span class=\"comment\">// set to non-nil by the first cancel call</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// c.done 只有调用 Done() 方法时才会被创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cancelCtx)</span> <span class=\"title\">Done</span><span class=\"params\">()</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">struct</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">\tc.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.done == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.done = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\td := c.done</span><br><span class=\"line\">\tc.mu.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> d</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cancelCtx)</span> <span class=\"title\">cancel</span><span class=\"params\">(removeFromParent <span class=\"keyword\">bool</span>, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"context: internal error: missing cancel error\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.mu.Unlock()</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"comment\">// 已经被其他 goroutine 取消</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.err = err</span><br><span class=\"line\">  <span class=\"comment\">// 关闭 done，通知监听的 goroutine</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.done == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.done = closedchan</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(c.done)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 取消所有子节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> child := <span class=\"keyword\">range</span> c.children &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// <span class=\"doctag\">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class=\"line\">\t\tchild.cancel(<span class=\"literal\">false</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.children = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tc.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 从父节点中移除自己</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> removeFromParent &#123;</span><br><span class=\"line\">\t\tremoveChild(c.Context, c)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面来看下如何创建一个可以取消的 context</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithCancel</span><span class=\"params\">(parent Context)</span> <span class=\"params\">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class=\"line\">\tc := newCancelCtx(parent)</span><br><span class=\"line\">\tpropagateCancel(parent, &amp;c)</span><br><span class=\"line\">  <span class=\"comment\">// CancelFunc 被调用时会调用 c.cancel 取消自己</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;c, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; c.cancel(<span class=\"literal\">true</span>, Canceled) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入父 context，返回一个新的可被取消的 context</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newCancelCtx</span><span class=\"params\">(parent Context)</span> <span class=\"title\">cancelCtx</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">propagateCancel</span><span class=\"params\">(parent Context, child canceler)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> parent.Done() == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"comment\">// parent is never canceled</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 找到可以取消的父节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class=\"line\">\t\tp.mu.Lock()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> p.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 父节点已被取消，子节点也要取消</span></span><br><span class=\"line\">\t\t\tchild.cancel(<span class=\"literal\">false</span>, p.err)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 挂载到父节点的 child 上</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> p.children == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tp.children = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[canceler]<span class=\"keyword\">struct</span>&#123;&#125;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tp.children[child] = <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp.mu.Unlock()</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果未找到可以取消的父节点，新启动一个 goroutine 监听父节点或子节点的取消信号</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> &lt;-parent.Done():</span><br><span class=\"line\">\t\t\t\tchild.cancel(<span class=\"literal\">false</span>, parent.Err())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> &lt;-child.Done():</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>timerCtx</strong> 基于 cancelCtx，多了一个 timer 和 deadline，timer 会在 deadline 到来时，取消 context</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> timerCtx <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tcancelCtx</span><br><span class=\"line\">\ttimer *time.Timer <span class=\"comment\">// Under cancelCtx.mu.</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tdeadline time.Time</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *timerCtx)</span> <span class=\"title\">cancel</span><span class=\"params\">(removeFromParent <span class=\"keyword\">bool</span>, err error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 直接调用 cancelCtx cancel 方法</span></span><br><span class=\"line\">\tc.cancelCtx.cancel(<span class=\"literal\">false</span>, err)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> removeFromParent &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Remove this timerCtx from its parent cancelCtx's children.</span></span><br><span class=\"line\">\t\tremoveChild(c.cancelCtx.Context, c)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.mu.Lock()</span><br><span class=\"line\">  <span class=\"comment\">// 关闭 timer</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.timer != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.timer.Stop()</span><br><span class=\"line\">\t\tc.timer = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.mu.Unlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建 timerCtx 有两个函数 <code>WithTimeOut</code> 和 <code>WithDeadline</code> </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithTimeout</span><span class=\"params\">(parent Context, timeout time.Duration)</span> <span class=\"params\">(Context, CancelFunc)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithDeadline</span><span class=\"params\">(parent Context, d time.Time)</span> <span class=\"params\">(Context, CancelFunc)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// The current deadline is already sooner than the new one.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> WithCancel(parent)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := &amp;timerCtx&#123;</span><br><span class=\"line\">\t\tcancelCtx: newCancelCtx(parent),</span><br><span class=\"line\">\t\tdeadline:  d,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpropagateCancel(parent, c)</span><br><span class=\"line\">  <span class=\"comment\">// 计算剩余时间</span></span><br><span class=\"line\">\tdur := time.Until(d)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> dur &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 直接取消</span></span><br><span class=\"line\">\t\tc.cancel(<span class=\"literal\">true</span>, DeadlineExceeded) <span class=\"comment\">// deadline has already passed</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; c.cancel(<span class=\"literal\">false</span>, Canceled) &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> c.mu.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 时间到后取消</span></span><br><span class=\"line\">\t\tc.timer = time.AfterFunc(dur, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\tc.cancel(<span class=\"literal\">true</span>, DeadlineExceeded)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; c.cancel(<span class=\"literal\">true</span>, Canceled) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"valueCtx\"><a href=\"#valueCtx\" class=\"headerlink\" title=\"valueCtx\"></a>valueCtx</h4><p><code>WithValue</code> 函数能从父上下文中创建一个子上下文 valueCtx，包含 key 和 value</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> valueCtx <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tContext</span><br><span class=\"line\">\tkey, val <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithValue</span><span class=\"params\">(parent Context, key, val <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Context</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> key == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"nil key\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 对 key 的要求是可以比较</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !reflect.TypeOf(key).Comparable() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"key is not comparable\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 递归查找 key 对应的 value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *valueCtx)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.key == key &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c.val</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.Context.Value(key)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，Go 语言的 context 主要作用还是在多个 goroutine 中同步取消信号已减少对资源的消耗和长时间占用，避免资源浪费，在使用传值的功能时还需谨慎，因为你根本不知道取的值是从哪个 context 里来的，会不会之前被覆盖过，因为返回的结果只有一个，比较常见的使用场景是传递请求对应用户的认证 token 或者用于分布式追踪的请求 ID。</p>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - unsafe","url":"http://localhost:4000/2019/06/21/go-unsafe/","content":"<p>Go 的指针相比于 C 语言指针的灵活，多了一些限制</p>\n<ul>\n<li><p>Go 的指针不能进行数学运算</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := <span class=\"number\">1</span></span><br><span class=\"line\">b := &amp;a</span><br><span class=\"line\">b++</span><br></pre></td></tr></table></figure>\n<p>上面的代码不能通过编译，错误为 <code>invalid operation</code> </p>\n</li>\n<li><p>不同类型的指针不能相互转换</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := <span class=\"keyword\">int</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> f *<span class=\"keyword\">float64</span></span><br><span class=\"line\">f = &amp;a</span><br></pre></td></tr></table></figure>\n<p>也会报编译错误 <code>cannot use &amp;a (type *int) as type *float64 in assignment</code></p>\n</li>\n<li><p>不同类型的指针不能使用 == 或 != 比较</p>\n</li>\n<li><p>不同类型的指针变量不能相互赋值</p>\n</li>\n</ul>\n<h4 id=\"unsafe\"><a href=\"#unsafe\" class=\"headerlink\" title=\"unsafe\"></a>unsafe</h4><p>Go 的指针类型是安全的，但也有非类型安全的指针，这就是 <code>unsafe.Pointer</code> 。由于可以直接操作内存，在某些情况下会使代码更高效，当然也更危险。</p>\n<p>unsafe 包里有两个类型和三个函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ArbitraryType <span class=\"keyword\">int</span>        <span class=\"comment\">//表示任意类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Pointer *ArbitraryType   <span class=\"comment\">//指向任意类型的指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sizeof</span><span class=\"params\">(x ArbitraryType)</span> <span class=\"title\">uintptr</span>    //返回 <span class=\"title\">x</span> 所占字节数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Offsetof</span><span class=\"params\">(x ArbitraryType)</span> <span class=\"title\">uintptr</span>  //返回结构体成员偏移字节数，所传参数必须是结构体的成员。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">Alignof</span><span class=\"params\">(x ArbitraryType)</span> <span class=\"title\">uintptr</span>   //返回参数类型的对齐值</span></span><br></pre></td></tr></table></figure>\n<p>综上所述，usnafe 包提供两种非常重要的能力：</p>\n<ul>\n<li>unsafe.Pointer 可以和 普通指针 进行相互转换</li>\n<li>unsafe.Pointer 可以和 uintptr 进行相互转换</li>\n</ul>\n<p>unsafe.Pointer 不能进行数学运算，但可以转成 uintptr 进行运算。里面的三个函数都在在编译期间执行完毕。</p>\n<h4 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname <span class=\"keyword\">string</span></span><br><span class=\"line\">\tage  <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tp := Person&#123;<span class=\"string\">\"张三\"</span>, <span class=\"number\">20</span>&#125;</span><br><span class=\"line\">\tfmt.Println(p)</span><br><span class=\"line\">\tname := (*<span class=\"keyword\">string</span>)(unsafe.Pointer(&amp;p))</span><br><span class=\"line\">\t*name = <span class=\"string\">\"李四\"</span></span><br><span class=\"line\">\tage := (*<span class=\"keyword\">int</span>)(unsafe.Pointer(<span class=\"keyword\">uintptr</span>(unsafe.Pointer(&amp;p)) + unsafe.Offsetof(p.age)))</span><br><span class=\"line\">\t*age = <span class=\"number\">30</span></span><br><span class=\"line\">\tfmt.Println(p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;张三 <span class=\"number\">20</span>&#125;</span><br><span class=\"line\">&#123;李四 <span class=\"number\">30</span>&#125;</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - reflect","url":"http://localhost:4000/2019/06/17/go-reflect/","content":"<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>reflect 实现了 Golang 运行时的反射能力，能够让程序操作不同类型的对象。包中有两对非常重要的函数和类型，他们的对应关系如下：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TypeOf</td>\n<td>Type</td>\n</tr>\n<tr>\n<td>ValueOf</td>\n<td>Value</td>\n</tr>\n</tbody>\n</table>\n<p>类型 Type 是一个接口，我们可以通过 TypeOf 方法获取任意变量的类型，通过类型接口方法可以获取到变量类型的相关数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Type <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tAlign() <span class=\"keyword\">int</span></span><br><span class=\"line\">\tFieldAlign() <span class=\"keyword\">int</span></span><br><span class=\"line\">\tMethod(<span class=\"keyword\">int</span>) Method</span><br><span class=\"line\">\tMethodByName(<span class=\"keyword\">string</span>) (Method, <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">\tNumMethod() <span class=\"keyword\">int</span></span><br><span class=\"line\">\tName() <span class=\"keyword\">string</span></span><br><span class=\"line\">\tPkgPath() <span class=\"keyword\">string</span></span><br><span class=\"line\">\tSize() <span class=\"keyword\">uintptr</span></span><br><span class=\"line\">\tString() <span class=\"keyword\">string</span></span><br><span class=\"line\">\tKind() Kind</span><br><span class=\"line\">\tImplements(u Type) <span class=\"keyword\">bool</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类型 Value 与 Type 不同，是个结构体，这个结构体没有任何对外暴露的成员变量，但提供了一些方法让我们读取或写入 Value 里存储的数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Value <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\ttyp *rtype</span><br><span class=\"line\">\tptr unsafe.Pointer</span><br><span class=\"line\">\tflag</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Value)</span> <span class=\"title\">SetInt</span><span class=\"params\">(x <span class=\"keyword\">int64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(v Value)</span> <span class=\"title\">Int</span><span class=\"params\">()</span> <span class=\"title\">int64</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(v Value)</span> <span class=\"title\">Addr</span><span class=\"params\">()</span> <span class=\"title\">Value</span></span></span><br><span class=\"line\"><span class=\"function\">...</span></span><br></pre></td></tr></table></figure>\n<p>reflect 通过 TypeOf 和 ValueOf 将普通变量转变成 Type 和 Value，再使用其提供的方法对变量进行复杂的操作。</p>\n<h3 id=\"反射三定律\"><a href=\"#反射三定律\" class=\"headerlink\" title=\"反射三定律\"></a>反射三定律</h3><ol>\n<li><p>从接口值可以反射出反射对象</p>\n<p>上面提到的两个函数 TypeOf 和 ValueOf 的入参都为 interface{} 类型</p>\n<p><code>普通变量 -&gt; interface{} -&gt; 反射对象</code></p>\n</li>\n<li><p>从反射对象可以得到接口值</p>\n<p>是第一定律的逆过程 <code>反射对象 -&gt; interface{}</code></p>\n</li>\n<li><p>当反射对象所存的值是可设置时，反射对象才可修改</p>\n<p>比如一下代码，运行会导致 panic: reflect: reflect.flag.mustBeAssignable using unaddressable value</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    i := <span class=\"number\">1</span></span><br><span class=\"line\">    v := reflect.ValueOf(i)</span><br><span class=\"line\">    v.SetInt(<span class=\"number\">10</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为 Golang 函数调用都是拷贝方式传值的，所以得到的反射对象与原始变量无任何关系，没有任何变量持有反射对象，对其修改会导致 panic。</p>\n<p>想要修改原始变量，需要传入变量指针，然后通过 <code>Elem</code> 方法获取指针指向变量并调用 <code>Set</code> 方法更新变量值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    i := <span class=\"number\">1</span></span><br><span class=\"line\">    v := reflect.ValueOf(&amp;i)</span><br><span class=\"line\">    v.Elem().SetInt(<span class=\"number\">10</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p>之前在 <a href=\"../go-interface\">interface</a> 那里说过，Golang 里空接口在内部都是以 eface 结构来表示，反射包里的 emptyInterface 结构和 runtime 里的 eface 一样。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> emptyInterface <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    typ  *rtype</span><br><span class=\"line\">    word unsafe.Pointer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用于获取变量类型的 TypeOf 方法将空接口变量 i 强转成 emptyInterface，然后获取变量类型 rtype，retype 就是一个实现了 Type 接口的结构体。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TypeOf</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Type</span></span> &#123;</span><br><span class=\"line\">    eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> toType(eface.typ)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toType</span><span class=\"params\">(t *rtype)</span> <span class=\"title\">Type</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用于获取接口值的 ValueOf 方法也差不多，将 i 强转成 emptyInterface ，将值及值类型包装成 Value 结构体返回</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ValueOf</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Value</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Value&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// <span class=\"doctag\">TODO:</span> Maybe allow contents of a Value to live on the stack.</span></span><br><span class=\"line\">\t<span class=\"comment\">// For now we make the contents always escape to the heap. It</span></span><br><span class=\"line\">\t<span class=\"comment\">// makes life easier in a few places (see chanrecv/mapassign</span></span><br><span class=\"line\">\t<span class=\"comment\">// comment below).</span></span><br><span class=\"line\">\tescapes(i)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> unpackEface(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">unpackEface</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Value</span></span> &#123;</span><br><span class=\"line\">\te := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class=\"line\">\t<span class=\"comment\">// <span class=\"doctag\">NOTE:</span> don't read e.word until we know whether it is really a pointer or not.</span></span><br><span class=\"line\">\tt := e.typ</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Value&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf := flag(t.Kind())</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ifaceIndir(t) &#123;</span><br><span class=\"line\">\t\tf |= flagIndir</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Value&#123;t, e.word, f&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - for range","url":"http://localhost:4000/2019/06/17/go-range/","content":"<p>Golang 里除了经典的三段式 for 循环外，还引入了关键字 <code>range</code>  帮我们快速遍历数组，哈希表等元素。下面我们会分析两种循环在运行时的结构和它们实现的原理。</p>\n<p>经典 for 循环及编译后的汇编</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x001d 00029 (main.go:4)        MOVQ    $0, &quot;&quot;.i+8(SP)        # 1.设置变量 i 初始值为 0</span><br><span class=\"line\">0x0026 00038 (main.go:4)        JMP     40                    # 2.跳转至 40 行</span><br><span class=\"line\">0x0028 00040 (main.go:4)        CMPQ    &quot;&quot;.i+8(SP), $10       # 3.比较 i 与 10</span><br><span class=\"line\">0x002e 00046 (main.go:4)        JLT     50                    # 4.结果真跳转至 50 行</span><br><span class=\"line\">0x0030 00048 (main.go:4)        JMP     91                    #   结果假跳转至 91 行</span><br><span class=\"line\">0x0032 00050 (main.go:5)        CALL    runtime.printlock(SB) # 5.开始执行循环体</span><br><span class=\"line\">0x0037 00055 (main.go:5)        MOVQ    &quot;&quot;.i+8(SP), AX</span><br><span class=\"line\">0x003c 00060 (main.go:5)        MOVQ    AX, (SP)</span><br><span class=\"line\">0x0040 00064 (main.go:5)        CALL    runtime.printint(SB)</span><br><span class=\"line\">0x0045 00069 (main.go:5)        CALL    runtime.printunlock(SB)</span><br><span class=\"line\">0x004a 00074 (main.go:5)        JMP     76</span><br><span class=\"line\">0x004c 00076 (main.go:4)        MOVQ    &quot;&quot;.i+8(SP), AX</span><br><span class=\"line\">0x0051 00081 (main.go:4)        INCQ    AX                    # 6.变量 i 自增1</span><br><span class=\"line\">0x0054 00084 (main.go:4)        MOVQ    AX, &quot;&quot;.i+8(SP)</span><br><span class=\"line\">0x0059 00089 (main.go:4)        JMP     40                    # 7.跳转至 40 行继续比较</span><br><span class=\"line\">0x005b 00091 (&lt;unknown line number&gt;)    PCDATA  $2, $-2</span><br></pre></td></tr></table></figure>\n<p>for range 循环及编译后的汇编</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(i, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x002f 00047 (main.go:4)        LEAQ    &quot;&quot;..autotmp_5+48(SP), AX</span><br><span class=\"line\">0x0034 00052 (main.go:4)        PCDATA  $0, $1</span><br><span class=\"line\">0x0034 00052 (main.go:4)        MOVQ    AX, &quot;&quot;..autotmp_4+80(SP)</span><br><span class=\"line\">0x0039 00057 (main.go:4)        PCDATA  $2, $0</span><br><span class=\"line\">0x0039 00057 (main.go:4)        TESTB   AL, (AX)</span><br><span class=\"line\">0x003b 00059 (main.go:4)        MOVUPS  &quot;&quot;.statictmp_0(SB), X0</span><br><span class=\"line\">0x0042 00066 (main.go:4)        MOVUPS  X0, &quot;&quot;..autotmp_5+48(SP)</span><br><span class=\"line\">0x0047 00071 (main.go:4)        MOVUPS  &quot;&quot;.statictmp_0+16(SB), X0</span><br><span class=\"line\">0x004e 00078 (main.go:4)        MOVUPS  X0, &quot;&quot;..autotmp_5+64(SP)</span><br><span class=\"line\">0x0053 00083 (main.go:4)        PCDATA  $2, $1</span><br><span class=\"line\">0x0053 00083 (main.go:4)        PCDATA  $0, $0</span><br><span class=\"line\">0x0053 00083 (main.go:4)        MOVQ    &quot;&quot;..autotmp_4+80(SP), AX</span><br><span class=\"line\">0x0058 00088 (main.go:4)        TESTB   AL, (AX)</span><br><span class=\"line\">0x005a 00090 (main.go:4)        JMP     92</span><br><span class=\"line\">0x005c 00092 (main.go:4)        MOVQ    AX, &quot;&quot;.a+88(SP)           # 切片 a 的数组指针</span><br><span class=\"line\">0x0061 00097 (main.go:4)        MOVQ    $4, &quot;&quot;.a+96(SP)           # 切片 a 的 length</span><br><span class=\"line\">0x006a 00106 (main.go:4)        MOVQ    $4, &quot;&quot;.a+104(SP)          # 切片 a 的 cap，从开始到这都是在初始化切片 a</span><br><span class=\"line\">0x0073 00115 (main.go:6)        PCDATA  $2, $0</span><br><span class=\"line\">0x0073 00115 (main.go:6)        PCDATA  $0, $2</span><br><span class=\"line\">0x0073 00115 (main.go:6)        MOVQ    AX, &quot;&quot;..autotmp_3+112(SP)</span><br><span class=\"line\">0x0078 00120 (main.go:6)        MOVQ    $4, &quot;&quot;..autotmp_3+120(SP)</span><br><span class=\"line\">0x0081 00129 (main.go:6)        MOVQ    $4, &quot;&quot;..autotmp_3+128(SP) # 复制切片 a 然后处理</span><br><span class=\"line\">0x008d 00141 (main.go:6)        MOVQ    $0, &quot;&quot;..autotmp_6+40(SP)  # 设置临时变量6并置 0</span><br><span class=\"line\">0x0096 00150 (main.go:6)        MOVQ    &quot;&quot;..autotmp_3+120(SP), AX </span><br><span class=\"line\">0x009b 00155 (main.go:6)        MOVQ    AX, &quot;&quot;..autotmp_7+32(SP)  </span><br><span class=\"line\">0x00a0 00160 (main.go:6)        JMP     162</span><br><span class=\"line\">0x00a2 00162 (main.go:6)        MOVQ    &quot;&quot;..autotmp_7+32(SP), AX  # 设置临时变量7，值为数组大小</span><br><span class=\"line\">0x00a7 00167 (main.go:6)        CMPQ    &quot;&quot;..autotmp_6+40(SP), AX  # 比较</span><br><span class=\"line\">0x00ac 00172 (main.go:6)        JLT     176                       # 结果真，跳转至 176 行</span><br><span class=\"line\">0x00ae 00174 (main.go:6)        JMP     273                       # 结果假，跳转至 273 行</span><br><span class=\"line\">0x00b0 00176 (main.go:6)        MOVQ    &quot;&quot;..autotmp_6+40(SP), AX  </span><br><span class=\"line\">0x00b5 00181 (main.go:6)        SHLQ    $3, AX                    # 索引左移3位，相当于*8</span><br><span class=\"line\">0x00b9 00185 (main.go:6)        PCDATA  $2, $1</span><br><span class=\"line\">0x00b9 00185 (main.go:6)        ADDQ    &quot;&quot;..autotmp_3+112(SP), AX # 数组起始位置加偏移取址</span><br><span class=\"line\">0x00be 00190 (main.go:6)        PCDATA  $2, $0</span><br><span class=\"line\">0x00be 00190 (main.go:6)        MOVQ    (AX), AX                  # 取值</span><br><span class=\"line\">0x00c1 00193 (main.go:6)        MOVQ    AX, &quot;&quot;..autotmp_8+24(SP)</span><br><span class=\"line\">0x00c6 00198 (main.go:6)        MOVQ    &quot;&quot;..autotmp_6+40(SP), AX</span><br><span class=\"line\">0x00cb 00203 (main.go:6)        MOVQ    AX, &quot;&quot;.i+16(SP)           # 将临时变量6的值赋予变量i</span><br><span class=\"line\">0x00d0 00208 (main.go:6)        MOVQ    &quot;&quot;..autotmp_8+24(SP), AX</span><br><span class=\"line\">0x00d5 00213 (main.go:6)        MOVQ    AX, &quot;&quot;.v+8(SP)            # 将临时变量8的值赋予变量v</span><br><span class=\"line\">0x00da 00218 (main.go:7)        CALL    runtime.printlock(SB)</span><br><span class=\"line\">0x00df 00223 (main.go:7)        MOVQ    &quot;&quot;.i+16(SP), AX</span><br><span class=\"line\">0x00e4 00228 (main.go:7)        MOVQ    AX, (SP)</span><br><span class=\"line\">0x00e8 00232 (main.go:7)        CALL    runtime.printint(SB)</span><br><span class=\"line\">0x00ed 00237 (main.go:7)        MOVQ    &quot;&quot;.v+8(SP), AX</span><br><span class=\"line\">0x00f2 00242 (main.go:7)        MOVQ    AX, (SP)</span><br><span class=\"line\">0x00f6 00246 (main.go:7)        CALL    runtime.printint(SB)</span><br><span class=\"line\">0x00fb 00251 (main.go:7)        CALL    runtime.printunlock(SB)</span><br><span class=\"line\">0x0100 00256 (main.go:7)        JMP     258</span><br><span class=\"line\">0x0102 00258 (main.go:6)        MOVQ    &quot;&quot;..autotmp_6+40(SP), AX</span><br><span class=\"line\">0x0107 00263 (main.go:6)        INCQ    AX                       # 将临时变量6自增1</span><br><span class=\"line\">0x010a 00266 (main.go:6)        MOVQ    AX, &quot;&quot;..autotmp_6+40(SP)</span><br><span class=\"line\">0x010f 00271 (main.go:6)        JMP     162                      # 跳转至162</span><br><span class=\"line\">0x0111 00273 (&lt;unknown line number&gt;)    PCDATA  $0, $0</span><br><span class=\"line\">0x0111 00273 (&lt;unknown line number&gt;)    MOVQ    136(SP), BP</span><br></pre></td></tr></table></figure>\n<p>通过汇编可以看到 range 里的变量 v，在每次循环都是同一个地址，会被拷贝赋值，所以一些 range 循环里使用 v 的地址会出现一些<a href=\"/2018/04/18/golang-forRang/\">问题</a>，比如下面</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tb := []*<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">\t\tb = <span class=\"built_in\">append</span>(b, &amp;v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> b &#123;</span><br><span class=\"line\">\t\tfmt.Print(*v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># <span class=\"number\">4</span> <span class=\"number\">4</span> <span class=\"number\">4</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - interface","url":"http://localhost:4000/2019/06/17/go-interface/","content":"<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>Go 语言中的接口类型会根据 <strong>是否包含一组方法</strong> 被分成两种不同的类型，包含方法的接口被实现成 <code>iface</code> 结构体，不包含方法的接口类型底层是 <code>eface</code> 结构体。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> iface <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\ttab  *itab</span><br><span class=\"line\">\tdata unsafe.Pointer  <span class=\"comment\">//指向原始数据的指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> eface <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t_type *_type         <span class=\"comment\">//指向类型的指针</span></span><br><span class=\"line\">\tdata  unsafe.Pointer <span class=\"comment\">//指向原始数据的指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> itab <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tinter *interfacetype <span class=\"comment\">// interface 类型指针</span></span><br><span class=\"line\">\t_type *_type         <span class=\"comment\">// 实际类型指针</span></span><br><span class=\"line\">\thash  <span class=\"keyword\">uint32</span> <span class=\"comment\">// copy of _type.hash. Used for type switches.</span></span><br><span class=\"line\">\t_     [<span class=\"number\">4</span>]<span class=\"keyword\">byte</span></span><br><span class=\"line\">\tfun   [<span class=\"number\">1</span>]<span class=\"keyword\">uintptr</span> <span class=\"comment\">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> _type <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tsize       <span class=\"keyword\">uintptr</span></span><br><span class=\"line\">\tptrdata    <span class=\"keyword\">uintptr</span> <span class=\"comment\">// size of memory prefix holding all pointers</span></span><br><span class=\"line\">\thash       <span class=\"keyword\">uint32</span></span><br><span class=\"line\">\ttflag      tflag</span><br><span class=\"line\">\talign      <span class=\"keyword\">uint8</span></span><br><span class=\"line\">\tfieldalign <span class=\"keyword\">uint8</span></span><br><span class=\"line\">\tkind       <span class=\"keyword\">uint8</span></span><br><span class=\"line\">\talg        *typeAlg</span><br><span class=\"line\">\t<span class=\"comment\">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class=\"line\">\t<span class=\"comment\">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class=\"line\">\tgcdata    *<span class=\"keyword\">byte</span></span><br><span class=\"line\">\tstr       nameOff</span><br><span class=\"line\">\tptrToThis typeOff</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p>通过汇编来看看 <code>eface</code> 结构的实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> b <span class=\"keyword\">interface</span>&#123;&#125; = a</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(main.go:4)        MOVQ    $1, &quot;&quot;.a+16(SP)           # 1.初始化 a 变量</span><br><span class=\"line\">(main.go:5)        MOVQ    $1, &quot;&quot;..autotmp_2+24(SP)  # 2.复制数据至栈上临时空间</span><br><span class=\"line\">(main.go:5)        PCDATA  $2, $1</span><br><span class=\"line\">(main.go:5)        PCDATA  $0, $1</span><br><span class=\"line\">(main.go:5)        LEAQ    type.int(SB), AX          # 3.获取 int 类型指针并放到 AX 寄存器上</span><br><span class=\"line\">(main.go:5)        PCDATA  $2, $0</span><br><span class=\"line\">(main.go:5)        MOVQ    AX, &quot;&quot;.b+32(SP)           # 4.将 int 类型指针传送到栈上 32(SP)</span><br><span class=\"line\">(main.go:5)        PCDATA  $2, $1 </span><br><span class=\"line\">(main.go:5)        LEAQ    &quot;&quot;..autotmp_2+24(SP), AX  # 5.将数据指针放到 AX 寄存器</span><br><span class=\"line\">(main.go:5)        PCDATA  $2, $0</span><br><span class=\"line\">(main.go:5)        MOVQ    AX, &quot;&quot;.b+40(SP)           # 6.将数据指针传送到栈上 40(SP)，b 初始化完成，共计占用 16 字节，前8类型指针，后8数据指针</span><br></pre></td></tr></table></figure>\n<p>再来看看 <code>iface</code> 结构的实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> A <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tHello()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> B <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b B)</span> <span class=\"title\">Hello</span><span class=\"params\">()</span></span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a A = B&#123;&#125;</span><br><span class=\"line\">\ta.Hello()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;&quot;.main STEXT size=92 args=0x0 locals=0x28</span><br><span class=\"line\">...</span><br><span class=\"line\">  (main.go:12)       LEAQ    go.itab.&quot;&quot;.B,&quot;&quot;.A(SB), AX # 1.将编译生成 itab 地址放入 AX 寄存器中</span><br><span class=\"line\">  (main.go:12)       PCDATA  $2, $0</span><br><span class=\"line\">  (main.go:12)       MOVQ    AX, &quot;&quot;.a+16(SP)           # 2.将 itab 地址放入栈上</span><br><span class=\"line\">  (main.go:12)       PCDATA  $2, $1</span><br><span class=\"line\">  (main.go:12)       LEAQ    runtime.zerobase(SB), AX  # 3.Golang中长度为0的对象都指向zerobase，这里初始化 a 的地址就是 zerobase 的地址</span><br><span class=\"line\">  (main.go:12)       PCDATA  $2, $0</span><br><span class=\"line\">  (main.go:12)       MOVQ    AX, &quot;&quot;.a+24(SP)           # 4.将 a 的地址放入栈上</span><br><span class=\"line\">  (main.go:13)       MOVQ    &quot;&quot;.a+16(SP), AX           # 5.将 itab 地址传送到 AX 上方便操作</span><br><span class=\"line\">  (main.go:13)       TESTB   AL, (AX) </span><br><span class=\"line\">  (main.go:13)       MOVQ    24(AX), AX                # 5.将 itab 偏移24字节地址也就是 B 的 Hello 函数地址传送到 AX 寄存器</span><br><span class=\"line\">  (main.go:13)       PCDATA  $2, $2</span><br><span class=\"line\">  (main.go:13)       PCDATA  $0, $0</span><br><span class=\"line\">  (main.go:13)       MOVQ    &quot;&quot;.a+24(SP), CX           </span><br><span class=\"line\">  (main.go:13)       PCDATA  $2, $0</span><br><span class=\"line\">  (main.go:13)       MOVQ    CX, (SP)                  # 6.将 a 的地址传送到栈顶</span><br><span class=\"line\">  (main.go:13)       CALL    AX                        # 7.调用 b.Hello()</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译时生成</span><br><span class=\"line\">go.itab.&quot;&quot;.B,&quot;&quot;.A SRODATA dupok size=32</span><br><span class=\"line\">       0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class=\"line\">       0x0010 50 5a d7 29 00 00 00 00 00 00 00 00 00 00 00 00  PZ.)............</span><br><span class=\"line\">       rel 0+8 t=1 type.&quot;&quot;.A+0      # 前8位存储 type.&quot;&quot;.A 地址，对应的字段 inter</span><br><span class=\"line\">       rel 8+8 t=1 type.&quot;&quot;.B+0      # 8-16 位存储 type.&quot;&quot;.B 地址，对应的字段 _type</span><br><span class=\"line\">       rel 24+8 t=1 &quot;&quot;.(*B).Hello+0 # 24-32 存储 B.Hello() 的地址</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - channel","url":"http://localhost:4000/2019/05/27/go-select/","content":"<p>在 Golang 中，select 可以让一个 goroutine 同时等待多个 channel 达到准备状态。select 和 switch 很像，不同的是 case 表达式必须与 channel 的操作相关，也就是 channel 的读写操作。</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>select 不存在任何结构体表示，case 使用了 scase 结构体表示</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> scase <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tc           *hchan         <span class=\"comment\">// chan</span></span><br><span class=\"line\">\telem        unsafe.Pointer <span class=\"comment\">// data element</span></span><br><span class=\"line\">\tkind        <span class=\"keyword\">uint16</span>         </span><br><span class=\"line\">\tpc          <span class=\"keyword\">uintptr</span> <span class=\"comment\">// race pc (for race detector / msan)</span></span><br><span class=\"line\">\treleasetime <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// scase 里的 kind，共四种</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tcaseNil = <span class=\"literal\">iota</span></span><br><span class=\"line\">\tcaseRecv</span><br><span class=\"line\">\tcaseSend</span><br><span class=\"line\">\tcaseDefault</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>当我们在使用 select 时，会遇到两个有趣的现象</p>\n<ol>\n<li>select 控制结构中包含 default 表达式，那么这个 select 不会等待其他 channel 准备就绪</li>\n<li>同时有多个 case 准备就绪后，会随机选择一个执行</li>\n</ol>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>select 在编译期间被转换成 OSELECT 节点，该节点持有一系例的 OCASE 节点，如果 OCASE 节点的条件为空，意味这是一个 default 节点。OCASE 节点既包含了执行条件也包含了满足条件后的执行代码。</p>\n<ul>\n<li>当 select 结构中不包含任何的 case 时，会变转换成 block 函数调用，直接阻塞当前 goroutine</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">walkselectcases</span><span class=\"params\">(cases *Nodes)</span> []*<span class=\"title\">Node</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []*Node&#123;mkcall(<span class=\"string\">\"block\"</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>)&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">block</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    gopark(<span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, waitReasonSelectNoCases, traceEvGoStop, <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当 select 只包含一个 case，编译器会将 select 结构转成 if 条件语句</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// if ch == nil &#123; block() &#125;; n;</span></span><br><span class=\"line\">a := nod(OIF, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">a.Left = nod(OEQ, ch, nodnil())</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当 select 包含两个 case ，其中一个为 default 时，为非阻塞操作，转换为 if/else 结构</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送数组转换为 selectnbsend 函数调用</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//\tselect &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\tcase c &lt;- v:</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t... foo</span></span><br><span class=\"line\"><span class=\"comment\">//\tdefault:</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t... bar</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// as</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//\tif selectnbsend(c, v) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t... foo</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t... bar</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">selectnbsend</span><span class=\"params\">(c *hchan, elem unsafe.Pointer)</span> <span class=\"params\">(selected <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> chansend(c, elem, <span class=\"literal\">false</span>, getcallerpc())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接受根据返回值的多少转化为 selectnbrecv 或 selectnbrecv2</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//\tselect &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\tcase v = &lt;-c:</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t... foo</span></span><br><span class=\"line\"><span class=\"comment\">//\tdefault:</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t... bar</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// as</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//\tif selectnbrecv(&amp;v, c) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t... foo</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t... bar</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">selectnbrecv</span><span class=\"params\">(elem unsafe.Pointer, c *hchan)</span> <span class=\"params\">(selected <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\tselected, _ = chanrecv(c, elem, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">selectnbrecv2</span><span class=\"params\">(elem unsafe.Pointer, received *<span class=\"keyword\">bool</span>, c *hchan)</span> <span class=\"params\">(selected <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// TODO(khr): just return 2 values from this function, now that it is in Go.</span></span><br><span class=\"line\">\tselected, *received = chanrecv(c, elem, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这三个函数在运行时都是非阻塞的 channel 操作</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>其他情况，将所有的 case 转换成 scase 结构体，调用运行时函数 selectgo 获取 scase 索引，然后执行相应代码块</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">selectgo</span><span class=\"params\">(cas0 *scase, order0 *<span class=\"keyword\">uint16</span>, ncases <span class=\"keyword\">int</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\tcas1 := (*[<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">16</span>]scase)(unsafe.Pointer(cas0))</span><br><span class=\"line\">\torder1 := (*[<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">17</span>]<span class=\"keyword\">uint16</span>)(unsafe.Pointer(order0))</span><br><span class=\"line\"></span><br><span class=\"line\">\tscases := cas1[:ncases:ncases]</span><br><span class=\"line\">  <span class=\"comment\">// order1[0-ncases] 给 pollorder 使用</span></span><br><span class=\"line\">\tpollorder := order1[:ncases:ncases]</span><br><span class=\"line\">  <span class=\"comment\">// order1[ncases-2ncases] 给 lockorder 使用</span></span><br><span class=\"line\">\tlockorder := order1[ncases:][:ncases:ncases]</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Replace send/receive cases involving nil channels with</span></span><br><span class=\"line\">\t<span class=\"comment\">// caseNil so logic below can assume non-nil channel.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> scases &#123;</span><br><span class=\"line\">\t\tcas := &amp;scases[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> cas.c == <span class=\"literal\">nil</span> &amp;&amp; cas.kind != caseDefault &#123;</span><br><span class=\"line\">\t\t\t*cas = scase&#123;&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t0 <span class=\"keyword\">int64</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> blockprofilerate &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tt0 = cputicks()</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; ncases; i++ &#123;</span><br><span class=\"line\">\t\t\tscases[i].releasetime = <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// 打乱轮训的顺序</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; ncases; i++ &#123;</span><br><span class=\"line\">\t\tj := fastrandn(<span class=\"keyword\">uint32</span>(i + <span class=\"number\">1</span>))</span><br><span class=\"line\">\t\tpollorder[i] = pollorder[j]</span><br><span class=\"line\">\t\tpollorder[j] = <span class=\"keyword\">uint16</span>(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 按照 channel 内存地址大小构建最大堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; ncases; i++ &#123;</span><br><span class=\"line\">\t\tj := i</span><br><span class=\"line\">\t\t<span class=\"comment\">// Start with the pollorder to permute cases on the same channel.</span></span><br><span class=\"line\">\t\tc := scases[pollorder[i]].c</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j &gt; <span class=\"number\">0</span> &amp;&amp; scases[lockorder[(j<span class=\"number\">-1</span>)/<span class=\"number\">2</span>]].c.sortkey() &lt; c.sortkey() &#123;</span><br><span class=\"line\">\t\t\tk := (j - <span class=\"number\">1</span>) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t\tlockorder[j] = lockorder[k]</span><br><span class=\"line\">\t\t\tj = k</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlockorder[j] = pollorder[i]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 堆排序</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := ncases - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\to := lockorder[i]</span><br><span class=\"line\">\t\tc := scases[o].c</span><br><span class=\"line\">\t\tlockorder[i] = lockorder[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tj := <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\tk := j*<span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> k &gt;= i &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> k+<span class=\"number\">1</span> &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+<span class=\"number\">1</span>]].c.sortkey() &#123;</span><br><span class=\"line\">\t\t\t\tk++</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> c.sortkey() &lt; scases[lockorder[k]].c.sortkey() &#123;</span><br><span class=\"line\">\t\t\t\tlockorder[j] = lockorder[k]</span><br><span class=\"line\">\t\t\t\tj = k</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlockorder[j] = o</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 按照顺序给 select 中所有的 channel 加锁，防止发生死锁</span></span><br><span class=\"line\">\tsellock(scases, lockorder)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> (</span><br><span class=\"line\">\t\tgp     *g</span><br><span class=\"line\">\t\tsg     *sudog</span><br><span class=\"line\">\t\tc      *hchan</span><br><span class=\"line\">\t\tk      *scase</span><br><span class=\"line\">\t\tsglist *sudog</span><br><span class=\"line\">\t\tsgnext *sudog</span><br><span class=\"line\">\t\tqp     unsafe.Pointer</span><br><span class=\"line\">\t\tnextp  **sudog</span><br><span class=\"line\">\t)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进入主循环</span></span><br><span class=\"line\">loop:</span><br><span class=\"line\">\t<span class=\"comment\">// pass 1 - case 中有可以执行的 channel，或者存在 default</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> dfli <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> dfl *scase</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> casi <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> cas *scase</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> recvOK <span class=\"keyword\">bool</span></span><br><span class=\"line\">  <span class=\"comment\">// 根据生成的随机顺序遍历 case 查找已等待执行的 channel</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; ncases; i++ &#123;</span><br><span class=\"line\">\t\tcasi = <span class=\"keyword\">int</span>(pollorder[i])</span><br><span class=\"line\">\t\tcas = &amp;scases[casi]</span><br><span class=\"line\">\t\tc = cas.c</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> cas.kind &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> caseNil:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> caseRecv:</span><br><span class=\"line\">      <span class=\"comment\">// 从等待的发送队列获取 sudog，如存在跳转至 recv</span></span><br><span class=\"line\">\t\t\tsg = c.sendq.dequeue()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> sg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> recv</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果缓冲区有数据，跳转 bufrecv</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> c.qcount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> bufrecv</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果 channel 已关闭，跳转 rclose</span></span><br><span class=\"line\">      <span class=\"comment\">// 可以看出来，如果我们关闭了一个 channel，在关闭之后还是可以把缓冲区的数据取出来</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> c.closed != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> rclose</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> caseSend:</span><br><span class=\"line\">      <span class=\"comment\">// 判断 channel 是否关闭</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> c.closed != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> sclose</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 从等待的接受队列获取 sudog，如存在跳转 send</span></span><br><span class=\"line\">\t\t\tsg = c.recvq.dequeue()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> sg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> send</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 缓冲区有空余位置，跳转至 bufsend</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> bufsend</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> caseDefault:</span><br><span class=\"line\">\t\t\tdfli = casi</span><br><span class=\"line\">\t\t\tdfl = cas</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 运行到此处说明所有的 case 都无法直接获取或发送数据，需阻塞等待某个 goroutine 就绪</span></span><br><span class=\"line\">  <span class=\"comment\">// 但是如果存在 default 分支，不需等待，直接执行 default 代码块</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> dfl != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tselunlock(scases, lockorder)</span><br><span class=\"line\">\t\tcasi = dfli</span><br><span class=\"line\">\t\tcas = dfl</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> retc</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// pass 2 - 执行到次数，所有的 case 都需要等待，并且无 default 分支</span></span><br><span class=\"line\">\tgp = getg()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gp.waiting != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"gp.waiting != nil\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnextp = &amp;gp.waiting</span><br><span class=\"line\">  <span class=\"comment\">// 按照加锁顺序，给每个 case 创建相应的 sudog 放入对应 channel 的 recvq 或 sendq 队列中</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, casei := <span class=\"keyword\">range</span> lockorder &#123;</span><br><span class=\"line\">\t\tcasi = <span class=\"keyword\">int</span>(casei)</span><br><span class=\"line\">\t\tcas = &amp;scases[casi]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> cas.kind == caseNil &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tc = cas.c</span><br><span class=\"line\">\t\tsg := acquireSudog()</span><br><span class=\"line\">\t\tsg.g = gp</span><br><span class=\"line\">\t\tsg.isSelect = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// No stack splits between assigning elem and enqueuing</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// sg on gp.waiting where copystack can find it.</span></span><br><span class=\"line\">\t\tsg.elem = cas.elem</span><br><span class=\"line\">\t\tsg.releasetime = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t0 != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tsg.releasetime = <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsg.c = c</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将 sudog 串成链表附着在当前的 goroutine 上</span></span><br><span class=\"line\">\t\t*nextp = sg</span><br><span class=\"line\">\t\tnextp = &amp;sg.waitlink</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> cas.kind &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> caseRecv:</span><br><span class=\"line\">\t\t\tc.recvq.enqueue(sg)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> caseSend:</span><br><span class=\"line\">\t\t\tc.sendq.enqueue(sg)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// wait for someone to wake us up</span></span><br><span class=\"line\">\tgp.param = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tgopark(selparkcommit, <span class=\"literal\">nil</span>, waitReasonSelect, traceEvGoBlockSelect, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 被唤醒，此时有个 goroutine 在接受或者发送数据，并且已经完成操作，后续就是一些收尾工作</span></span><br><span class=\"line\">\tsellock(scases, lockorder)</span><br><span class=\"line\"></span><br><span class=\"line\">\tgp.selectDone = <span class=\"number\">0</span></span><br><span class=\"line\">\tsg = (*sudog)(gp.param)</span><br><span class=\"line\">\tgp.param = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// pass 3 - dequeue from unsuccessful chans</span></span><br><span class=\"line\">\t<span class=\"comment\">// otherwise they stack up on quiet channels</span></span><br><span class=\"line\">\t<span class=\"comment\">// record the successful case, if any.</span></span><br><span class=\"line\">\t<span class=\"comment\">// We singly-linked up the SudoGs in lock order.</span></span><br><span class=\"line\">\tcasi = <span class=\"number\">-1</span></span><br><span class=\"line\">\tcas = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tsglist = gp.waiting</span><br><span class=\"line\">\t<span class=\"comment\">// Clear all elem before unlinking from gp.waiting.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> sg1 := gp.waiting; sg1 != <span class=\"literal\">nil</span>; sg1 = sg1.waitlink &#123;</span><br><span class=\"line\">\t\tsg1.isSelect = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\tsg1.elem = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\tsg1.c = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgp.waiting = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, casei := <span class=\"keyword\">range</span> lockorder &#123;</span><br><span class=\"line\">\t\tk = &amp;scases[casei]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> k.kind == caseNil &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sglist.releasetime &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tk.releasetime = sglist.releasetime</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sg == sglist &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// sg has already been dequeued by the G that woke us up.</span></span><br><span class=\"line\">\t\t\tcasi = <span class=\"keyword\">int</span>(casei)</span><br><span class=\"line\">\t\t\tcas = k</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 把其他还在等待的sudog从等待队列中移除</span></span><br><span class=\"line\">\t\t\tc = k.c</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> k.kind == caseSend &#123;</span><br><span class=\"line\">\t\t\t\tc.sendq.dequeueSudoG(sglist)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tc.recvq.dequeueSudoG(sglist)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsgnext = sglist.waitlink</span><br><span class=\"line\">\t\tsglist.waitlink = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\treleaseSudog(sglist)</span><br><span class=\"line\">\t\tsglist = sgnext</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cas == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// We can wake up with gp.param == nil (so cas == nil)</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// when a channel involved in the select has been closed.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// It is easiest to loop and re-run the operation;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// we'll see that it's now closed.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Maybe some day we can signal the close explicitly,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// but we'd have to distinguish close-on-reader from close-on-writer.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// It's easiest not to duplicate the code and just recheck above.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// We know that something closed, and things never un-close,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// so we won't block again.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> loop</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tc = cas.c</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cas.kind == caseRecv &#123;</span><br><span class=\"line\">\t\trecvOK = <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tselunlock(scases, lockorder)</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> retc</span><br><span class=\"line\"></span><br><span class=\"line\">bufrecv:</span><br><span class=\"line\">\t<span class=\"comment\">// can receive from buffer</span></span><br><span class=\"line\">\trecvOK = <span class=\"literal\">true</span></span><br><span class=\"line\">\tqp = chanbuf(c, c.recvx)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cas.elem != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\ttypedmemmove(c.elemtype, cas.elem, qp)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttypedmemclr(c.elemtype, qp)</span><br><span class=\"line\">\tc.recvx++</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class=\"line\">\t\tc.recvx = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.qcount--</span><br><span class=\"line\">\tselunlock(scases, lockorder)</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> retc</span><br><span class=\"line\"></span><br><span class=\"line\">bufsend:</span><br><span class=\"line\">\t<span class=\"comment\">// can send to buffer</span></span><br><span class=\"line\">\ttypedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class=\"line\">\tc.sendx++</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class=\"line\">\t\tc.sendx = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.qcount++</span><br><span class=\"line\">\tselunlock(scases, lockorder)</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> retc</span><br><span class=\"line\"></span><br><span class=\"line\">recv:</span><br><span class=\"line\">\t<span class=\"comment\">// can receive from sleeping sender (sg)</span></span><br><span class=\"line\">\trecv(c, sg, cas.elem, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class=\"number\">2</span>)</span><br><span class=\"line\">\trecvOK = <span class=\"literal\">true</span></span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> retc</span><br><span class=\"line\"></span><br><span class=\"line\">rclose:</span><br><span class=\"line\">\t<span class=\"comment\">// read at end of closed channel</span></span><br><span class=\"line\">\tselunlock(scases, lockorder)</span><br><span class=\"line\">\trecvOK = <span class=\"literal\">false</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cas.elem != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\ttypedmemclr(c.elemtype, cas.elem)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> retc</span><br><span class=\"line\"></span><br><span class=\"line\">send:</span><br><span class=\"line\">\t<span class=\"comment\">// can send to a sleeping receiver (sg)</span></span><br><span class=\"line\">\tsend(c, sg, cas.elem, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class=\"number\">2</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> debugSelect &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">\"syncsend: cas0=\"</span>, cas0, <span class=\"string\">\" c=\"</span>, c, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> retc</span><br><span class=\"line\"></span><br><span class=\"line\">retc:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cas.releasetime &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tblockevent(cas.releasetime-t0, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> casi, recvOK</span><br><span class=\"line\"></span><br><span class=\"line\">sclose:</span><br><span class=\"line\">\t<span class=\"comment\">// send on closed channel</span></span><br><span class=\"line\">\tselunlock(scases, lockorder)</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(plainError(<span class=\"string\">\"send on closed channel\"</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中相关的接受和发送操作和 channel 的实现原理一样，只是由于 select 多了个 default 关键字所以会出现非阻塞收发操作。</p>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - channel","url":"http://localhost:4000/2019/05/24/go-channel/","content":"<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>在 Golang 中 channel 都是以 hchan 结构体形式存在</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hchan <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tqcount   <span class=\"keyword\">uint</span>           <span class=\"comment\">// total data in the queue</span></span><br><span class=\"line\">\tdataqsiz <span class=\"keyword\">uint</span>           <span class=\"comment\">// size of the circular queue</span></span><br><span class=\"line\">\tbuf      unsafe.Pointer <span class=\"comment\">// points to an array of dataqsiz elements</span></span><br><span class=\"line\">\telemsize <span class=\"keyword\">uint16</span></span><br><span class=\"line\">\tclosed   <span class=\"keyword\">uint32</span></span><br><span class=\"line\">\telemtype *_type <span class=\"comment\">// element type</span></span><br><span class=\"line\">\tsendx    <span class=\"keyword\">uint</span>   <span class=\"comment\">// send index</span></span><br><span class=\"line\">\trecvx    <span class=\"keyword\">uint</span>   <span class=\"comment\">// receive index</span></span><br><span class=\"line\">\trecvq    waitq  <span class=\"comment\">// list of recv waiters</span></span><br><span class=\"line\">\tsendq    waitq  <span class=\"comment\">// list of send waiters</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// lock protects all fields in hchan, as well as several</span></span><br><span class=\"line\">\t<span class=\"comment\">// fields in sudogs blocked on this channel.</span></span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"comment\">// Do not change another G's status while holding this lock</span></span><br><span class=\"line\">\t<span class=\"comment\">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class=\"line\">\t<span class=\"comment\">// with stack shrinking.</span></span><br><span class=\"line\">\tlock mutex</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><p>我们在使用 channel 是，能够执行的操作也就只有创建、发送、接受和关闭四种。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">ch &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">&lt;-ch</span><br><span class=\"line\"><span class=\"built_in\">close</span>(ch)</span><br></pre></td></tr></table></figure>\n<p>我们下面就介绍这四种操作的实现原理，及调用过程。</p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>Golang 中所有 make(xxx) 在编译期间会转换成 OMAKE 节点，随后的类型检查阶段发现 make 的第一个参数是 chan 时会将 OMAKE 转换成 OMAKECHAN。</p>\n<p>OMAKECHAN 类型的节点最终会转换成 makechan 或者 makechan64 的函数调用，这两个函数都是 Go 语言运行时方法，方法的作用就是创建上面所说的 hchan 结构体。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makechan</span><span class=\"params\">(t *chantype, size <span class=\"keyword\">int</span>)</span> *<span class=\"title\">hchan</span></span> &#123;</span><br><span class=\"line\">\telem := t.elem</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// compiler checks this but be safe.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> elem.size &gt;= <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"makechan: invalid channel element type\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> hchanSize%maxAlign != <span class=\"number\">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"makechan: bad alignment\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmem, overflow := math.MulUintptr(elem.size, <span class=\"keyword\">uintptr</span>(size))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(plainError(<span class=\"string\">\"makechan: size out of range\"</span>))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class=\"line\">\t<span class=\"comment\">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class=\"line\">\t<span class=\"comment\">// SudoG's are referenced from their owning thread so they can't be collected.</span></span><br><span class=\"line\">\t<span class=\"comment\">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> c *hchan</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> mem == <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">// Queue or element size is zero.</span></span><br><span class=\"line\">\t\tc = (*hchan)(mallocgc(hchanSize, <span class=\"literal\">nil</span>, <span class=\"literal\">true</span>))</span><br><span class=\"line\">\t\t<span class=\"comment\">// Race detector uses this location for synchronization.</span></span><br><span class=\"line\">\t\tc.buf = c.raceaddr()</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> elem.kind&amp;kindNoPointers != <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">// Elements do not contain pointers.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Allocate hchan and buf in one call.</span></span><br><span class=\"line\">\t\tc = (*hchan)(mallocgc(hchanSize+mem, <span class=\"literal\">nil</span>, <span class=\"literal\">true</span>))</span><br><span class=\"line\">\t\tc.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">// Elements contain pointers.</span></span><br><span class=\"line\">\t\tc = <span class=\"built_in\">new</span>(hchan)</span><br><span class=\"line\">\t\tc.buf = mallocgc(mem, elem, <span class=\"literal\">true</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tc.elemsize = <span class=\"keyword\">uint16</span>(elem.size)</span><br><span class=\"line\">\tc.elemtype = elem</span><br><span class=\"line\">\tc.dataqsiz = <span class=\"keyword\">uint</span>(size)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> debugChan &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">\"makechan: chan=\"</span>, c, <span class=\"string\">\"; elemsize=\"</span>, elem.size, <span class=\"string\">\"; elemalg=\"</span>, elem.alg, <span class=\"string\">\"; dataqsiz=\"</span>, size, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会根据 channel 中的元素类型和缓冲区大小来为 hchan 结构体创建用户缓冲的底层循环数组</p>\n<ul>\n<li>如果 size=0 ，只会为 hchan 分配一段内存空间</li>\n<li>如果元素类型非指针类型，会分配一段连续的内存空间</li>\n<li>其他情况会单独分配内存</li>\n</ul>\n<h4 id=\"发送\"><a href=\"#发送\" class=\"headerlink\" title=\"发送\"></a>发送</h4><p><code>ch &lt;- i</code> 表达式会在编译期间解析成 OSEND 节点，之后再被转换成 chansend1 函数调用，chansend1 调用了 chansend 并传入 channel 和需要发送的数据，还传入了 block=true，标示当前发送操作是一个阻塞操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">chansend1</span><span class=\"params\">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class=\"line\">\tchansend(c, elem, <span class=\"literal\">true</span>, getcallerpc())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">chansend</span><span class=\"params\">(c *hchan, ep unsafe.Pointer, block <span class=\"keyword\">bool</span>, callerpc <span class=\"keyword\">uintptr</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 在不获取锁的情况下，快速检测失败的非阻塞操作</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !block &amp;&amp; c.closed == <span class=\"number\">0</span> &amp;&amp; ((c.dataqsiz == <span class=\"number\">0</span> &amp;&amp; c.recvq.first == <span class=\"literal\">nil</span>) ||</span><br><span class=\"line\">\t\t(c.dataqsiz &gt; <span class=\"number\">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t0 <span class=\"keyword\">int64</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> blockprofilerate &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tt0 = cputicks()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 发送前为 channel 加锁</span></span><br><span class=\"line\">\tlock(&amp;c.lock)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 向已经关闭的 channel 发送数据会出发 panic</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.closed != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tunlock(&amp;c.lock)</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(plainError(<span class=\"string\">\"send on closed channel\"</span>))</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>直接发送</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 如果目标 channel 有处于等待的 goroutine，那么会直接拿到最先陷入等待的 goroutine，调用下面的 send 方法向它发送数据，并移除队列</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> sg := c.recvq.dequeue(); sg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class=\"line\">\t\tsend(c, sg, ep, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class=\"number\">3</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span><span class=\"params\">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class=\"keyword\">func</span>()</span>, <span class=\"title\">skip</span> <span class=\"title\">int</span>)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sg.elem != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tsendDirect(c.elemtype, sg, ep)</span><br><span class=\"line\">\t\tsg.elem = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgp := sg.g</span><br><span class=\"line\">\tunlockf()</span><br><span class=\"line\">\tgp.param = unsafe.Pointer(sg)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sg.releasetime != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tsg.releasetime = cputicks()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将接受数据的 goroutine 标记成 Grunnable 并把它放到发送方所在的 P 上等待执行</span></span><br><span class=\"line\">\tgoready(gp, skip+<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将要发送的消息直接拷贝到接收方持有的目标内存地址上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendDirect</span><span class=\"params\">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class=\"line\">\tdst := sg.elem</span><br><span class=\"line\">\ttypeBitsBulkBarrier(t, <span class=\"keyword\">uintptr</span>(dst), <span class=\"keyword\">uintptr</span>(src), t.size)</span><br><span class=\"line\">\tmemmove(dst, src, t.size)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>缓冲区发送</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//如果存在缓冲区并且有空闲余量</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 计算出放置消息的缓冲区内存地址</span></span><br><span class=\"line\">   qp := chanbuf(c, c.sendx)</span><br><span class=\"line\">   <span class=\"comment\">// 将发送的消息拷贝到缓冲区</span></span><br><span class=\"line\">\ttypedmemmove(c.elemtype, qp, ep)</span><br><span class=\"line\">   <span class=\"comment\">// 发送索引加1，值==缓冲区大小，重置为0</span></span><br><span class=\"line\">\tc.sendx++</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class=\"line\">\t\tc.sendx = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">   <span class=\"comment\">// 缓冲区消息数量加1</span></span><br><span class=\"line\">\tc.qcount++</span><br><span class=\"line\">\tunlock(&amp;c.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>阻塞发送</strong></p>\n<p>上面两种情况都不满足，进行阻塞发送</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">if</span> !block &#123;</span><br><span class=\"line\">\tunlock(&amp;c.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取当前操作的 goroutine</span></span><br><span class=\"line\">gp := getg()</span><br><span class=\"line\"> <span class=\"comment\">// 获取一个 sudog 结构体，并设置此次阻塞发送的相关信息</span></span><br><span class=\"line\">mysg := acquireSudog()</span><br><span class=\"line\">mysg.releasetime = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> t0 != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\tmysg.releasetime = <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mysg.elem = ep</span><br><span class=\"line\">mysg.waitlink = <span class=\"literal\">nil</span></span><br><span class=\"line\">mysg.g = gp</span><br><span class=\"line\">mysg.isSelect = <span class=\"literal\">false</span></span><br><span class=\"line\">mysg.c = c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 sudog 置于当前 goroutine 的 waiting 上</span></span><br><span class=\"line\">gp.waiting = mysg</span><br><span class=\"line\">gp.param = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 将 sudog 置于 sendq 等待队列</span></span><br><span class=\"line\">c.sendq.enqueue(mysg)</span><br><span class=\"line\"> <span class=\"comment\">// 将当前的 g 置于等待状态并解锁，可以被 goready 再次唤醒</span></span><br><span class=\"line\">goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">KeepAlive(ep)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后面就是唤醒后的收尾工作</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> mysg != gp.waiting &#123;</span><br><span class=\"line\">\tthrow(<span class=\"string\">\"G waiting list is corrupted\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">gp.waiting = <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> gp.param == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.closed == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"chansend: spurious wakeup\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(plainError(<span class=\"string\">\"send on closed channel\"</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">gp.param = <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> mysg.releasetime &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\tblockevent(mysg.releasetime-t0, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mysg.c = <span class=\"literal\">nil</span></span><br><span class=\"line\">releaseSudog(mysg)</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"接受\"><a href=\"#接受\" class=\"headerlink\" title=\"接受\"></a>接受</h4><p>从 channel 接受数据有两种方式 <code>i &lt;- ch</code> 和 <code>i,ok &lt;- ch</code> ，这两种方式在编译时都会转换成 ORECV 类型的节点，但是后者会在类型检查阶段转换成 OAS2RECV 节点，最终两种方式都会被转换成 <code>chanrecv1</code> 和 <code>chanrecv2</code> 的函数调用，这两函数最终调用 <code>chanrecv</code> 方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">chanrecv1</span><span class=\"params\">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class=\"line\">\tchanrecv(c, elem, <span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">chanrecv2</span><span class=\"params\">(c *hchan, elem unsafe.Pointer)</span> <span class=\"params\">(received <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t_, received = chanrecv(c, elem, <span class=\"literal\">true</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">chanrecv</span><span class=\"params\">(c *hchan, ep unsafe.Pointer, block <span class=\"keyword\">bool</span>)</span> <span class=\"params\">(selected, received <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !block &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tgopark(<span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"unreachable\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 在不获取锁的情况下，快速检测失败的非阻塞操作</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !block &amp;&amp; (c.dataqsiz == <span class=\"number\">0</span> &amp;&amp; c.sendq.first == <span class=\"literal\">nil</span> ||</span><br><span class=\"line\">\t\tc.dataqsiz &gt; <span class=\"number\">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class=\"number\">0</span>) &amp;&amp;</span><br><span class=\"line\">\t\tatomic.Load(&amp;c.closed) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t0 <span class=\"keyword\">int64</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> blockprofilerate &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tt0 = cputicks()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlock(&amp;c.lock)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果当前 channel 已被关闭并且缓冲区不存在任何数据，解锁channel，清除 ep 数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.closed != <span class=\"number\">0</span> &amp;&amp; c.qcount == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tunlock(&amp;c.lock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ep != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\ttypedmemclr(c.elemtype, ep)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>, <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>直接接受</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">if</span> sg := c.sendq.dequeue(); sg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// and add sender's value to the tail of the queue (both map to</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// the same buffer slot because the queue is full).</span></span><br><span class=\"line\">\t\trecv(c, sg, ep, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class=\"number\">3</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>, <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recv</span><span class=\"params\">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class=\"keyword\">func</span>()</span>, <span class=\"title\">skip</span> <span class=\"title\">int</span>)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果缓冲区为0，直接调用 recvDirect，将发送方的数据直接拷贝到目标内存地址上</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> c.dataqsiz == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ep != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// copy data from sender</span></span><br><span class=\"line\">\t\t\trecvDirect(c.elemtype, sg, ep)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这种情况下，缓冲区时满的，发送方处于阻塞中</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将缓冲区数据拷贝到目标地址，将发送方数据拷贝到的缓冲区</span></span><br><span class=\"line\">\t\tqp := chanbuf(c, c.recvx)</span><br><span class=\"line\">\t\t<span class=\"comment\">// copy data from queue to receiver</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ep != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\ttypedmemmove(c.elemtype, ep, qp)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// copy data from sender to queue</span></span><br><span class=\"line\">\t\ttypedmemmove(c.elemtype, qp, sg.elem)</span><br><span class=\"line\">\t\tc.recvx++</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class=\"line\">\t\t\tc.recvx = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tc.sendx = c.recvx <span class=\"comment\">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsg.elem = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tgp := sg.g</span><br><span class=\"line\">\tunlockf()</span><br><span class=\"line\">\tgp.param = unsafe.Pointer(sg)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sg.releasetime != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tsg.releasetime = cputicks()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将发送数据的 goroutine 标记成 Grunnable 并把它放到接受方所在的 P 上等待执行</span></span><br><span class=\"line\">\tgoready(gp, skip+<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>缓冲区接受</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缓冲区有数据，拷贝数据值目标内存地址</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> c.qcount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Receive directly from queue</span></span><br><span class=\"line\">\tqp := chanbuf(c, c.recvx)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ep != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\ttypedmemmove(c.elemtype, ep, qp)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttypedmemclr(c.elemtype, qp)</span><br><span class=\"line\">\tc.recvx++</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class=\"line\">\t\tc.recvx = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.qcount--</span><br><span class=\"line\">\tunlock(&amp;c.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>, <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>阻塞接受</strong></p>\n<p>当 channel 的 sends 队列不存在等待的 goroutine，并且缓冲区无数据时，接受操作会变成一个阻塞操作</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非阻塞解锁channel直接返回</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> !block &#123;</span><br><span class=\"line\">\tunlock(&amp;c.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>, <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取当前操作的 goroutine</span></span><br><span class=\"line\">gp := getg()</span><br><span class=\"line\"> <span class=\"comment\">// 获取一个 sudog 结构体，并设置此次阻塞接受的相关信息</span></span><br><span class=\"line\">mysg := acquireSudog()</span><br><span class=\"line\">mysg.releasetime = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> t0 != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\tmysg.releasetime = <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class=\"line\"><span class=\"comment\">// on gp.waiting where copystack can find it.</span></span><br><span class=\"line\">mysg.elem = ep</span><br><span class=\"line\">mysg.waitlink = <span class=\"literal\">nil</span></span><br><span class=\"line\">gp.waiting = mysg</span><br><span class=\"line\">mysg.g = gp</span><br><span class=\"line\">mysg.isSelect = <span class=\"literal\">false</span></span><br><span class=\"line\">mysg.c = c</span><br><span class=\"line\">gp.param = <span class=\"literal\">nil</span></span><br><span class=\"line\"> <span class=\"comment\">// 将 sudog 置于 recvq 等待队列</span></span><br><span class=\"line\">c.recvq.enqueue(mysg)</span><br><span class=\"line\"><span class=\"comment\">// 将当前的 g 置于等待状态并解锁，可以被 goready 再次唤醒</span></span><br><span class=\"line\">goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后面就是唤醒后的收尾工作</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> mysg != gp.waiting &#123;</span><br><span class=\"line\">\tthrow(<span class=\"string\">\"G waiting list is corrupted\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">gp.waiting = <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> mysg.releasetime &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\tblockevent(mysg.releasetime-t0, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">closed := gp.param == <span class=\"literal\">nil</span></span><br><span class=\"line\">gp.param = <span class=\"literal\">nil</span></span><br><span class=\"line\">mysg.c = <span class=\"literal\">nil</span></span><br><span class=\"line\">releaseSudog(mysg)</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">true</span>, !closed</span><br></pre></td></tr></table></figure>\n<h4 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h4><p>close 关键字在编译期间转换成 OCLOSE 节点，最终转换成 closechan 的函数调用</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">closechan</span><span class=\"params\">(c *hchan)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 空指针 或 已经关闭，会出发 panic</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(plainError(<span class=\"string\">\"close of nil channel\"</span>))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlock(&amp;c.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.closed != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tunlock(&amp;c.lock)</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(plainError(<span class=\"string\">\"close of closed channel\"</span>))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 关闭 channel</span></span><br><span class=\"line\">\tc.closed = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> glist gList</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 释放接受队列，清除未被处理的数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tsg := c.recvq.dequeue()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sg == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sg.elem != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\ttypedmemclr(c.elemtype, sg.elem)</span><br><span class=\"line\">\t\t\tsg.elem = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sg.releasetime != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tsg.releasetime = cputicks()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tgp := sg.g</span><br><span class=\"line\">\t\tgp.param = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\tglist.push(gp)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 释放发送队列，将会触发 panic</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tsg := c.sendq.dequeue()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sg == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsg.elem = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sg.releasetime != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tsg.releasetime = cputicks()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tgp := sg.g</span><br><span class=\"line\">\t\tgp.param = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\tglist.push(gp)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tunlock(&amp;c.lock)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 对所有阻塞的 goroutine 进行调度</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> !glist.empty() &#123;</span><br><span class=\"line\">\t\tgp := glist.pop()</span><br><span class=\"line\">\t\tgp.schedlink = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tgoready(gp, <span class=\"number\">3</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - 并发模型","url":"http://localhost:4000/2019/05/10/go-gmp/","content":"<p>Go 语言中的并发模型有三个核心结构 G M P ，下面会简单回顾下基本概念，之后会详细介绍它们的实现原理及运行时的状态切换。</p>\n<ol>\n<li><strong>G</strong> 表示一个 goroutine，它的生命周期受 Go 运行时管理</li>\n<li><strong>M</strong> 等同于系统线程，可以运行 go 代码（即 goroutine 需要一个 P）和原生代码（syscall，不需要 P）</li>\n<li><strong>P</strong>  可以看作是运行在 M 上的一个本地调度器</li>\n</ol>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p><code>runtime2.go</code> 里有详细的定义，这里只列出一些比较重要的字段</p>\n<h4 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> g <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tstack          stack    <span class=\"comment\">// 当前 g 使用的栈空间，有 lo 和 hi 两个成员变量</span></span><br><span class=\"line\">\tstackguard0    <span class=\"keyword\">uintptr</span>  <span class=\"comment\">// 检测 g 的栈是否需要扩张</span></span><br><span class=\"line\">\tstackguard1    <span class=\"keyword\">uintptr</span>  <span class=\"comment\">// 检测 c 的栈是否需要扩张</span></span><br><span class=\"line\">  m              *m       <span class=\"comment\">// 当前 g 对应的 m</span></span><br><span class=\"line\">  sched          gobuf    <span class=\"comment\">// g 的调度数据，当 g 中断时保存当前栈的 pc sp bp 等</span></span><br><span class=\"line\">  atomicstatus   <span class=\"keyword\">uint32</span>   <span class=\"comment\">// 当前 g 的状态 _Gidle/_Grunnable...</span></span><br><span class=\"line\">  schedlink      guintptr <span class=\"comment\">// 当 g 在链表结构中表示下一个 g</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t<span class=\"comment\">// G status</span></span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"comment\">// _Gidle means this goroutine was just allocated and has not</span></span><br><span class=\"line\">\t<span class=\"comment\">// yet been initialized.</span></span><br><span class=\"line\">\t_Gidle = <span class=\"literal\">iota</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// _Grunnable means this goroutine is on a run queue. It is</span></span><br><span class=\"line\">\t<span class=\"comment\">// not currently executing user code. The stack is not owned.</span></span><br><span class=\"line\">\t_Grunnable <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// _Grunning means this goroutine may execute user code. The</span></span><br><span class=\"line\">\t<span class=\"comment\">// stack is owned by this goroutine. It is not on a run queue.</span></span><br><span class=\"line\">\t<span class=\"comment\">// It is assigned an M and a P.</span></span><br><span class=\"line\">\t_Grunning <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// _Gsyscall means this goroutine is executing a system call.</span></span><br><span class=\"line\">\t<span class=\"comment\">// It is not executing user code. The stack is owned by this</span></span><br><span class=\"line\">\t<span class=\"comment\">// goroutine. It is not on a run queue. It is assigned an M.</span></span><br><span class=\"line\">\t_Gsyscall <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// _Gwaiting means this goroutine is blocked in the runtime.</span></span><br><span class=\"line\">\t<span class=\"comment\">// It is not executing user code. It is not on a run queue,</span></span><br><span class=\"line\">\t<span class=\"comment\">// but should be recorded somewhere (e.g., a channel wait</span></span><br><span class=\"line\">\t<span class=\"comment\">// queue) so it can be ready()d when necessary. The stack is</span></span><br><span class=\"line\">\t<span class=\"comment\">// not owned *except* that a channel operation may read or</span></span><br><span class=\"line\">\t<span class=\"comment\">// write parts of the stack under the appropriate channel</span></span><br><span class=\"line\">\t<span class=\"comment\">// lock. Otherwise, it is not safe to access the stack after a</span></span><br><span class=\"line\">\t<span class=\"comment\">// goroutine enters _Gwaiting (e.g., it may get moved).</span></span><br><span class=\"line\">\t_Gwaiting <span class=\"comment\">// 4</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// _Gmoribund_unused is currently unused, but hardcoded in gdb</span></span><br><span class=\"line\">\t<span class=\"comment\">// scripts.</span></span><br><span class=\"line\">\t_Gmoribund_unused <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// _Gdead means this goroutine is currently unused. It may be</span></span><br><span class=\"line\">\t<span class=\"comment\">// just exited, on a free list, or just being initialized. It</span></span><br><span class=\"line\">\t<span class=\"comment\">// is not executing user code. It may or may not have a stack</span></span><br><span class=\"line\">\t<span class=\"comment\">// allocated. The G and its stack (if any) are owned by the M</span></span><br><span class=\"line\">\t<span class=\"comment\">// that is exiting the G or that obtained the G from the free</span></span><br><span class=\"line\">\t<span class=\"comment\">// list.</span></span><br><span class=\"line\">\t_Gdead <span class=\"comment\">// 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// _Genqueue_unused is currently unused.</span></span><br><span class=\"line\">\t_Genqueue_unused <span class=\"comment\">// 7</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// _Gcopystack means this goroutine's stack is being moved. It</span></span><br><span class=\"line\">\t<span class=\"comment\">// is not executing user code and is not on a run queue. The</span></span><br><span class=\"line\">\t<span class=\"comment\">// stack is owned by the goroutine that put it in _Gcopystack.</span></span><br><span class=\"line\">\t_Gcopystack <span class=\"comment\">// 8</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// _Gscan combined with one of the above states other than</span></span><br><span class=\"line\">\t<span class=\"comment\">// _Grunning indicates that GC is scanning the stack. The</span></span><br><span class=\"line\">\t<span class=\"comment\">// goroutine is not executing user code and the stack is owned</span></span><br><span class=\"line\">\t<span class=\"comment\">// by the goroutine that set the _Gscan bit.</span></span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"comment\">// _Gscanrunning is different: it is used to briefly block</span></span><br><span class=\"line\">\t<span class=\"comment\">// state transitions while GC signals the G to scan its own</span></span><br><span class=\"line\">\t<span class=\"comment\">// stack. This is otherwise like _Grunning.</span></span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"comment\">// atomicstatus&amp;~Gscan gives the state the goroutine will</span></span><br><span class=\"line\">\t<span class=\"comment\">// return to when the scan completes.</span></span><br><span class=\"line\">\t_Gscan         = <span class=\"number\">0x1000</span></span><br><span class=\"line\">\t_Gscanrunnable = _Gscan + _Grunnable <span class=\"comment\">// 0x1001</span></span><br><span class=\"line\">\t_Gscanrunning  = _Gscan + _Grunning  <span class=\"comment\">// 0x1002</span></span><br><span class=\"line\">\t_Gscansyscall  = _Gscan + _Gsyscall  <span class=\"comment\">// 0x1003</span></span><br><span class=\"line\">\t_Gscanwaiting  = _Gscan + _Gwaiting  <span class=\"comment\">// 0x1004</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> m <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tg0            *g        <span class=\"comment\">// 调度和执行系统调用时会切换到 g0</span></span><br><span class=\"line\">  tls           [<span class=\"number\">6</span>]<span class=\"keyword\">uintptr</span><span class=\"comment\">// thread-local storage (for x86 extern register)</span></span><br><span class=\"line\">\tcurg          *g        <span class=\"comment\">// 当前运行的 g</span></span><br><span class=\"line\">\tp             puintptr  <span class=\"comment\">// 当前拥有的 P</span></span><br><span class=\"line\">\tnextp         puintptr  <span class=\"comment\">// 唤醒时，会拥有这个 P</span></span><br><span class=\"line\">\toldp          puintptr  <span class=\"comment\">// 系统调用之前拥有的 P</span></span><br><span class=\"line\">\tpark          note      <span class=\"comment\">// M 休眠时的信号量，唤醒时使用</span></span><br><span class=\"line\">\tschedlink     muintptr  <span class=\"comment\">// 在链表结构时，表示下一个 M</span></span><br><span class=\"line\">\tmcache        *mcache   <span class=\"comment\">// 小对象的内存分配器，不需要加锁，因为它属于单独一个 M 或 P</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>M 虽然没有像 G 或 P 的状态值表示，但我们可以认为一个 M 有以下的状态</p>\n<ul>\n<li>自旋中(spinning)：M 正在从运行队列获取 G，此时拥有一个 P</li>\n<li>正在执行 Go 代码：此时也会拥有一个 P</li>\n<li>正在执行原生代码或阻塞的 syscall：此时不拥有 P</li>\n<li>休眠中：M 发现无等待运行的 G 时会进入休眠，此时不拥有 P</li>\n</ul>\n<h4 id=\"P\"><a href=\"#P\" class=\"headerlink\" title=\"P\"></a>P</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> p <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tstatus      <span class=\"keyword\">uint32</span>     <span class=\"comment\">// 当前的状态 pidle/prunning/...</span></span><br><span class=\"line\">\tlink        puintptr   <span class=\"comment\">// 当 p 在链表结构中，表示下一个 p</span></span><br><span class=\"line\">\tm           muintptr   <span class=\"comment\">// 拥有这个 p 的 m</span></span><br><span class=\"line\">  mcache      *mcache    <span class=\"comment\">// 同 M 的 mcache</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  runqhead    <span class=\"keyword\">uint32</span>         <span class=\"comment\">// 本地运行队列头</span></span><br><span class=\"line\">\trunqtail    <span class=\"keyword\">uint32</span>         <span class=\"comment\">// 本地运行队列尾</span></span><br><span class=\"line\">\trunq        [<span class=\"number\">256</span>]guintptr  <span class=\"comment\">// 本地运行队列数组，可以保存 256 个 g</span></span><br><span class=\"line\">  runnext     guintptr       <span class=\"comment\">// 下一个要运行的 g</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Available G's (status == Gdead) 保存着可以复用的 g</span></span><br><span class=\"line\">\tgFree <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tgList</span><br><span class=\"line\">\t\tn <span class=\"keyword\">int32</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t<span class=\"comment\">// P status</span></span><br><span class=\"line\">\t_Pidle    = <span class=\"literal\">iota</span></span><br><span class=\"line\">\t_Prunning <span class=\"comment\">// Only this P is allowed to change from _Prunning.</span></span><br><span class=\"line\">\t_Psyscall</span><br><span class=\"line\">\t_Pgcstop</span><br><span class=\"line\">\t_Pdead</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><h4 id=\"程序初始化\"><a href=\"#程序初始化\" class=\"headerlink\" title=\"程序初始化\"></a>程序初始化</h4><p>Go 程序的入口是在 <code>runtime.rt0_go</code> 汇编语言中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEXT runtime·rt0_go(SB),NOSPLIT,$0</span><br><span class=\"line\">\t// 省略分配栈空间，参数处理等代码</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t// 全局g0实例放入 DI 寄存器中</span><br><span class=\"line\">\tMOVQ\t$runtime·g0(SB), DI    </span><br><span class=\"line\">\tLEAQ\t(-64*1024+104)(SP), BX </span><br><span class=\"line\">\t// 设置 g0 的 stackguard0/stackguard1/stack 三个字段</span><br><span class=\"line\">\tMOVQ\tBX, g_stackguard0(DI)</span><br><span class=\"line\">\tMOVQ\tBX, g_stackguard1(DI)</span><br><span class=\"line\">\tMOVQ\tBX, (g_stack+stack_lo)(DI)</span><br><span class=\"line\">\tMOVQ\tSP, (g_stack+stack_hi)(DI)</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 省略获取当前 CPU 的信息代码</span><br><span class=\"line\">\t...</span><br><span class=\"line\">nocpuinfo:</span><br><span class=\"line\">\t// if there is an _cgo_init, call it.</span><br><span class=\"line\">\tMOVQ\t_cgo_init(SB), AX</span><br><span class=\"line\">\tTESTQ\tAX, AX</span><br><span class=\"line\">\tJZ\tneedtls</span><br><span class=\"line\">\t// g0 already in DI</span><br><span class=\"line\">\tMOVQ\tDI, CX\t// Win64 uses CX for first parameter</span><br><span class=\"line\">\tMOVQ\t$setg_gcc&lt;&gt;(SB), SI</span><br><span class=\"line\">\tCALL\tAX</span><br><span class=\"line\"></span><br><span class=\"line\">\t// update stackguard after _cgo_init</span><br><span class=\"line\">\tMOVQ\t$runtime·g0(SB), CX</span><br><span class=\"line\">\tMOVQ\t(g_stack+stack_lo)(CX), AX</span><br><span class=\"line\">\tADDQ\t$const__StackGuard, AX</span><br><span class=\"line\">\tMOVQ\tAX, g_stackguard0(CX)</span><br><span class=\"line\">\tMOVQ\tAX, g_stackguard1(CX)</span><br><span class=\"line\"></span><br><span class=\"line\">needtls:</span><br><span class=\"line\">\t// 省略预编译的代码</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// 设置 m0 实例的 tls</span><br><span class=\"line\">\tLEAQ\truntime·m0+m_tls(SB), DI</span><br><span class=\"line\">\tCALL\truntime·settls(SB)</span><br><span class=\"line\"></span><br><span class=\"line\">\t// store through it, to make sure it works</span><br><span class=\"line\">\t// 经过上面的settls后，需要验证get_tls和g()作用是否符合预期。失败的话，就引发abort</span><br><span class=\"line\">\tget_tls(BX)</span><br><span class=\"line\">\tMOVQ\t$0x123, g(BX)</span><br><span class=\"line\">\tMOVQ\truntime·m0+m_tls(SB), AX</span><br><span class=\"line\">\tCMPQ\tAX, $0x123</span><br><span class=\"line\">\tJEQ 2(PC)</span><br><span class=\"line\">\tCALL\truntime·abort(SB)</span><br><span class=\"line\">ok:</span><br><span class=\"line\">\t// set the per-goroutine and per-mach &quot;registers&quot;</span><br><span class=\"line\">\t// 验证成功后，把全局g0实例放进tls，并且将g0和m0互相引用</span><br><span class=\"line\">\tget_tls(BX)</span><br><span class=\"line\">\tLEAQ\truntime·g0(SB), CX</span><br><span class=\"line\">\tMOVQ\tCX, g(BX)</span><br><span class=\"line\">\tLEAQ\truntime·m0(SB), AX</span><br><span class=\"line\"></span><br><span class=\"line\">\t// save m-&gt;g0 = g0</span><br><span class=\"line\">\tMOVQ\tCX, m_g0(AX)</span><br><span class=\"line\">\t// save m0 to g0-&gt;m</span><br><span class=\"line\">\tMOVQ\tAX, g_m(CX)</span><br><span class=\"line\"></span><br><span class=\"line\">\tCLD\t\t\t\t// convention is D is always left cleared</span><br><span class=\"line\">\tCALL\truntime·check(SB)</span><br><span class=\"line\"></span><br><span class=\"line\">\tMOVL\t16(SP), AX\t\t// copy argc</span><br><span class=\"line\">\tMOVL\tAX, 0(SP)</span><br><span class=\"line\">\tMOVQ\t24(SP), AX\t\t// copy argv</span><br><span class=\"line\">\tMOVQ\tAX, 8(SP)</span><br><span class=\"line\">\t// 保存传入的argc和argv到全局变量，找到执行文件的绝对路径</span><br><span class=\"line\">\tCALL\truntime·args(SB)</span><br><span class=\"line\">\t// 根据系统执行不同的初始化，cpu个数和内存页大小等</span><br><span class=\"line\">\tCALL\truntime·osinit(SB)</span><br><span class=\"line\">\t// 命令行参数、环境变量、gc、栈空间、内存管理、所有P实例、HASH算法等初始化</span><br><span class=\"line\">\tCALL\truntime·schedinit(SB)</span><br><span class=\"line\"></span><br><span class=\"line\">\t// runtime.main函数地址放进AX</span><br><span class=\"line\">\tMOVQ\t$runtime·mainPC(SB), AX\t\t// entry</span><br><span class=\"line\">\tPUSHQ\tAX</span><br><span class=\"line\">\tPUSHQ\t$0\t\t\t// arg size</span><br><span class=\"line\">\t// 新建一个goroutine，该goroutine绑定runtime.main，放在P的本地队列，等待调度</span><br><span class=\"line\">\tCALL\truntime·newproc(SB)</span><br><span class=\"line\">\tPOPQ\tAX</span><br><span class=\"line\">\tPOPQ\tAX</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 启动M，开始调度goroutine</span><br><span class=\"line\">\tCALL\truntime·mstart(SB)</span><br><span class=\"line\"></span><br><span class=\"line\">\tCALL\truntime·abort(SB)\t// mstart should never return</span><br><span class=\"line\">\tRET</span><br><span class=\"line\"></span><br><span class=\"line\">\t// Prevent dead-code elimination of debugCallV1, which is</span><br><span class=\"line\">\t// intended to be called by debuggers.</span><br><span class=\"line\">\tMOVQ\t$runtime·debugCallV1(SB), AX</span><br><span class=\"line\">\tRET</span><br><span class=\"line\"></span><br><span class=\"line\">DATA\truntime·mainPC+0(SB)/8,$runtime·main(SB)</span><br><span class=\"line\">GLOBL\truntime·mainPC(SB),RODATA,$8</span><br></pre></td></tr></table></figure>\n<p> 来看下<code>runtime.schedinit</code> 函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">schedinit</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 从 tls 中获取当前的 g</span></span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> raceenabled &#123;</span><br><span class=\"line\">\t\t_g_.racectx, raceprocctx0 = raceinit()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置全局线程数上限</span></span><br><span class=\"line\">\tsched.maxmcount = <span class=\"number\">10000</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化一系列函数所在的PC计数器，用于traceback</span></span><br><span class=\"line\">\ttracebackinit()</span><br><span class=\"line\">\tmoduledataverify()</span><br><span class=\"line\">\tstackinit()</span><br><span class=\"line\">  <span class=\"comment\">// 内存分配器初始化</span></span><br><span class=\"line\">\tmallocinit()</span><br><span class=\"line\">\tmcommoninit(_g_.m)</span><br><span class=\"line\">\tcpuinit()       <span class=\"comment\">// must run before alginit</span></span><br><span class=\"line\">\talginit()       <span class=\"comment\">// maps must not be used before this call</span></span><br><span class=\"line\">\tmodulesinit()   <span class=\"comment\">// provides activeModules</span></span><br><span class=\"line\">\ttypelinksinit() <span class=\"comment\">// uses maps, activeModules</span></span><br><span class=\"line\">\titabsinit()     <span class=\"comment\">// uses activeModules</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tmsigsave(_g_.m)</span><br><span class=\"line\">\tinitSigmask = _g_.m.sigmask</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获取命令行参数</span></span><br><span class=\"line\">\tgoargs()</span><br><span class=\"line\">\tgoenvs()</span><br><span class=\"line\">\tparsedebugvars()</span><br><span class=\"line\">  <span class=\"comment\">// gc 初始化</span></span><br><span class=\"line\">\tgcinit()</span><br><span class=\"line\"></span><br><span class=\"line\">\tsched.lastpoll = <span class=\"keyword\">uint64</span>(nanotime())</span><br><span class=\"line\">  <span class=\"comment\">// p 个数检查</span></span><br><span class=\"line\">\tprocs := ncpu</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n, ok := atoi32(gogetenv(<span class=\"string\">\"GOMAXPROCS\"</span>)); ok &amp;&amp; n &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tprocs = n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 所有 p 初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> procresize(procs) != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"unknown runnable goroutine during bootstrap\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看下持有  <code>runtime.main</code>  的 groutine 执行后的流程</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tg := getg()</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"comment\">// 标记主函数已被调用</span></span><br><span class=\"line\">\tmainStarted = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 启动一个新的M执行sysmon函数, 这个函数会监控全局的状态并对运行时间过长的G进行抢占</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> GOARCH != <span class=\"string\">\"wasm\"</span> &#123; <span class=\"comment\">// no threads on wasm yet, so no sysmon</span></span><br><span class=\"line\">\t\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\tnewm(sysmon, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 要求G必须在当前M(系统主线程)上执行</span></span><br><span class=\"line\">\tlockOSThread()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.m != &amp;m0 &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"runtime.main not on m0\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// 调用 main.init ，如果存在</span></span><br><span class=\"line\">\tfn := main_init</span><br><span class=\"line\">\tfn()</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(main_init_done)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 不再要求G必须在当前M上运行</span></span><br><span class=\"line\">\tneedUnlock = <span class=\"literal\">false</span></span><br><span class=\"line\">\tunlockOSThread()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果程序是作为c的类库编译的, 在这里返回</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> isarchive || islibrary &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 调用main.main函数</span></span><br><span class=\"line\">\tfn = main_main</span><br><span class=\"line\">\tfn()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果当前发生了panic, 则等待panic处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;runningPanicDefers) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Running deferred functions should not take long.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> c := <span class=\"number\">0</span>; c &lt; <span class=\"number\">1000</span>; c++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> atomic.Load(&amp;runningPanicDefers) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tGosched()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;panicking) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tgopark(<span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, waitReasonPanicWait, traceEvGoStop, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 退出</span></span><br><span class=\"line\">\texit(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> x *<span class=\"keyword\">int32</span></span><br><span class=\"line\">\t\t*x = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后调用 <code>runtime.mstart</code> 函数，经过初始化和检查最终会调用到 <code>schedule</code> 方法，我们会在下面的调度器实现中详细介绍。</p>\n<p>经过上述一系列步骤，程序进入到 main.main 方法中，了解了程序初始化的流程，下面就开始介绍 goroutine 的创建，调度等操作。</p>\n<h4 id=\"创建-Goroutine\"><a href=\"#创建-Goroutine\" class=\"headerlink\" title=\"创建 Goroutine\"></a>创建 Goroutine</h4><p>在 Go 语言中使用 <code>go</code> 关键字创建一个新的 goroutine，这个关键字在编译期间通过 stmt 和 call 两个方法转换成 <code>newproc</code> 的函数调用</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// siz 是 fn+其他参数的长度，fn 函数指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newproc</span><span class=\"params\">(siz <span class=\"keyword\">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取其他参数地址</span></span><br><span class=\"line\">\targp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class=\"line\">  <span class=\"comment\">// 获取当前的 g</span></span><br><span class=\"line\">\tgp := getg()</span><br><span class=\"line\">  <span class=\"comment\">// 获取调用方的程序计数器（返回地址）</span></span><br><span class=\"line\">\tpc := getcallerpc()</span><br><span class=\"line\">  <span class=\"comment\">// 切换至 g0 堆栈调用 fn 再切回来</span></span><br><span class=\"line\">\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 真正创建 goroutine 的方法</span></span><br><span class=\"line\">\t\tnewproc1(fn, (*<span class=\"keyword\">uint8</span>)(argp), siz, gp, pc)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// argp 参数起始地址，narg 参数长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newproc1</span><span class=\"params\">(fn *funcval, argp *<span class=\"keyword\">uint8</span>, narg <span class=\"keyword\">int32</span>, callergp *g, callerpc <span class=\"keyword\">uintptr</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取当前的g，这里会获取到 g0</span></span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> fn == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t_g_.m.throwing = <span class=\"number\">-1</span> <span class=\"comment\">// do not dump full stacks</span></span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"go of nil func value\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.locks++ <span class=\"comment\">// disable preemption because it can be holding p in a local var</span></span><br><span class=\"line\">\tsiz := narg</span><br><span class=\"line\">\tsiz = (siz + <span class=\"number\">7</span>) &amp;^ <span class=\"number\">7</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// We could allocate a larger initial stack if necessary.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Not worth it: this is almost always an error.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 4*sizeof(uintreg): extra space added below</span></span><br><span class=\"line\">\t<span class=\"comment\">// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> siz &gt;= _StackMin<span class=\"number\">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc: function arguments too large for new goroutine\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获取 m 持有的 p</span></span><br><span class=\"line\">\t_p_ := _g_.m.p.ptr()</span><br><span class=\"line\">  <span class=\"comment\">// 调用 gfget 从 p.gFree 里获取 g，如果之前有g被回收在这里就可以复用（状态为 _Gdead）</span></span><br><span class=\"line\">\tnewg := gfget(_p_)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> newg == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取不到时调用 malg 分配一个 g，初始化栈空间大小为 2k</span></span><br><span class=\"line\">\t\tnewg = malg(_StackMin)</span><br><span class=\"line\">    <span class=\"comment\">// 将状态从 _Gidle 转成 _Gdead</span></span><br><span class=\"line\">\t\tcasgstatus(newg, _Gidle, _Gdead)</span><br><span class=\"line\">\t\tallgadd(newg) <span class=\"comment\">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> newg.stack.hi == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc1: newg missing stack\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"newproc1: new g is not Gdead\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 下面一段是将 fn 的参数拷贝到新 g 的栈上</span></span><br><span class=\"line\">\ttotalSize := <span class=\"number\">4</span>*sys.RegSize + <span class=\"keyword\">uintptr</span>(siz) + sys.MinFrameSize <span class=\"comment\">// extra space in case of reads slightly beyond frame</span></span><br><span class=\"line\">\ttotalSize += -totalSize &amp; (sys.SpAlign - <span class=\"number\">1</span>)                  <span class=\"comment\">// align to spAlign</span></span><br><span class=\"line\">\tsp := newg.stack.hi - totalSize</span><br><span class=\"line\">\tspArg := sp</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> usesLR &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// caller's LR</span></span><br><span class=\"line\">\t\t*(*<span class=\"keyword\">uintptr</span>)(unsafe.Pointer(sp)) = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tprepGoExitFrame(sp)</span><br><span class=\"line\">\t\tspArg += sys.MinFrameSize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> narg &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tmemmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class=\"keyword\">uintptr</span>(narg))</span><br><span class=\"line\">\t\t<span class=\"comment\">// This is a stack-to-stack copy. If write barriers</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// are enabled and the source stack is grey (the</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// destination is always black), then perform a</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// barrier copy. We do this *after* the memmove</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// because the destination stack may have garbage on</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// it.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class=\"line\">\t\t\tf := findfunc(fn.fn)</span><br><span class=\"line\">\t\t\tstkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> stkmap.nbit &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// We're in the prologue, so it's always stack map index 0.</span></span><br><span class=\"line\">\t\t\t\tbv := stackmapdata(stkmap, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tbulkBarrierBitmap(spArg, spArg, <span class=\"keyword\">uintptr</span>(bv.n)*sys.PtrSize, <span class=\"number\">0</span>, bv.bytedata)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置新 g 的栈指针，指令地址等属性</span></span><br><span class=\"line\">\tmemclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class=\"line\">\tnewg.sched.sp = sp</span><br><span class=\"line\">\tnewg.stktopsp = sp</span><br><span class=\"line\">\tnewg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class=\"comment\">// +PCQuantum so that previous instruction is in same function</span></span><br><span class=\"line\">\tnewg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class=\"line\">  <span class=\"comment\">// 将 goexit 函数地址放入 g 的栈底，pc 设置为 g 的地址</span></span><br><span class=\"line\">\tgostartcallfn(&amp;newg.sched, fn)</span><br><span class=\"line\">\tnewg.gopc = callerpc</span><br><span class=\"line\">\tnewg.ancestors = saveAncestors(callergp)</span><br><span class=\"line\">\tnewg.startpc = fn.fn</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.curg != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tnewg.labels = _g_.m.curg.labels</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> isSystemGoroutine(newg, <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">\t\tatomic.Xadd(&amp;sched.ngsys, +<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnewg.gcscanvalid = <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"comment\">// 将新 g 的状态改为 _Grunnable</span></span><br><span class=\"line\">\tcasgstatus(newg, _Gdead, _Grunnable)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Sched.goidgen is the last allocated id,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class=\"line\">\t\t_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class=\"line\">\t\t_p_.goidcache -= _GoidCacheBatch - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnewg.goid = <span class=\"keyword\">int64</span>(_p_.goidcache)</span><br><span class=\"line\">\t_p_.goidcache++</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> raceenabled &#123;</span><br><span class=\"line\">\t\tnewg.racectx = racegostart(callerpc)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\ttraceGoCreate(newg, newg.startpc)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 把 g 放入运行队列</span></span><br><span class=\"line\">  <span class=\"comment\">// 1. 如果新 g 放入 p.runnext ，旧的g代替新g执行下面步骤</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. 将 g 放入 p 的本地可运行队列 runq</span></span><br><span class=\"line\">  <span class=\"comment\">// 3. 如果满了，则调用 runqputslow 把 g 放到全局运行队列，顺便还把本地运行队列的一半放入全局队列中</span></span><br><span class=\"line\">\trunqput(_p_, newg, <span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果有空闲的 P，但无自旋的 M，并且主函数已执行，则唤醒或新建一个 M</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;sched.npidle) != <span class=\"number\">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class=\"number\">0</span> &amp;&amp; mainStarted &#123;</span><br><span class=\"line\">\t\twakep()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.locks--</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.locks == <span class=\"number\">0</span> &amp;&amp; _g_.preempt &#123; <span class=\"comment\">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class=\"line\">\t\t_g_.stackguard0 = stackPreempt</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"调度-Goroutine\"><a href=\"#调度-Goroutine\" class=\"headerlink\" title=\"调度 Goroutine\"></a>调度 Goroutine</h4><p>在程序初始化小节中，最后调用了 <code>mstart</code> 方法，方法中首先给 g0 分配栈空间，然后调用 <code>mstart1</code> ，在 <code>mstart1</code> 中保存一些调度数据，设置信号量后，调用 <code>schedule</code> 方法，进入调度循环。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">schedule</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.locks != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"schedule: holding locks\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.lockedg != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tstoplockedm()</span><br><span class=\"line\">\t\texecute(_g_.m.lockedg.ptr(), <span class=\"literal\">false</span>) <span class=\"comment\">// Never returns.</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class=\"line\">\t<span class=\"comment\">// since the cgo call is using the m's g0 stack.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.incgo &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"schedule: in cgo\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">top:</span><br><span class=\"line\">  <span class=\"comment\">// GC 需要 STW，则休眠当前的 M</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sched.gcwaiting != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tgcstopm()</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> top</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.p.ptr().runSafePointFn != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\trunSafePointFn()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获取等待运行的 goroutine，依次有以下几个步骤</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> gp *g</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> inheritTime <span class=\"keyword\">bool</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 如果有运行时追踪事件触发或 traceReader 尚未处理完成，则获取 trace.reader</span></span><br><span class=\"line\">\t\tgp = traceReader()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> gp != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class=\"line\">\t\t\ttraceGoUnpark(gp, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gp == <span class=\"literal\">nil</span> &amp;&amp; gcBlackenEnabled != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 如果当前 GC 正在标记阶段，则查找等待运行的 GC Worker。</span></span><br><span class=\"line\">\t\tgp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gp == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 3. 公平起见，每61次调度从全局运行队列获取一次 g</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p.ptr().schedtick%<span class=\"number\">61</span> == <span class=\"number\">0</span> &amp;&amp; sched.runqsize &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t\tgp = globrunqget(_g_.m.p.ptr(), <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gp == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 4. 调用 runqget 从本地运行队列获取 g</span></span><br><span class=\"line\">\t\tgp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> gp != <span class=\"literal\">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"schedule: spinning with local work\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gp == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 5. 都失败后，调用 findrunnable 获取待运行的 g，会阻塞到获取成功为止。</span></span><br><span class=\"line\">\t\tgp, inheritTime = findrunnable() <span class=\"comment\">// blocks until work is available</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 此处，成功获取到一个等待运行的 goroutine</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">// 让当前 M 离开自旋状态，同时判断如果无自旋 M，并且有空闲的 P，则唤醒或新建一个 M</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.spinning &#123;</span><br><span class=\"line\">\t\tresetspinning()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当前 g 被禁止调度，放入禁止调度的待运行队列，返回顶部重试</span></span><br><span class=\"line\">\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> schedEnabled(gp) &#123;</span><br><span class=\"line\">\t\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tsched.disable.runnable.pushBack(gp)</span><br><span class=\"line\">\t\t\tsched.disable.n++</span><br><span class=\"line\">\t\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> top</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gp.lockedm != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// g 要求返回到指定的 M，调用 startlockedm 把 g 和 p 交给该 M，自己进入休眠</span></span><br><span class=\"line\">\t\tstartlockedm(gp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> top</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 执行 goroutine</span></span><br><span class=\"line\">\texecute(gp, inheritTime)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来详细看下 <code>findrunnable</code> 函数内部的实现逻辑</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findrunnable</span><span class=\"params\">()</span> <span class=\"params\">(gp *g, inheritTime <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\"></span><br><span class=\"line\">top:</span><br><span class=\"line\">\t_p_ := _g_.m.p.ptr()</span><br><span class=\"line\">  <span class=\"comment\">// GC 需要 STW，休眠当前 M</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sched.gcwaiting != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tgcstopm()</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> top</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _p_.runSafePointFn != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\trunSafePointFn()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> gp := wakefing(); gp != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tready(gp, <span class=\"number\">0</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> *cgo_yield != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tasmcgocall(*cgo_yield, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// local runq</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gp, inheritTime := runqget(_p_); gp != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> gp, inheritTime</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// global runq</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sched.runqsize != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\tgp := globrunqget(_p_, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> gp != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> gp, <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Poll network.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 从 netpoll 获取 g，非阻塞调用</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class=\"number\">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> list := netpoll(<span class=\"literal\">false</span>); !list.empty() &#123; <span class=\"comment\">// non-blocking</span></span><br><span class=\"line\">\t\t\tgp := list.pop()</span><br><span class=\"line\">\t\t\tinjectglist(&amp;list)</span><br><span class=\"line\">\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\t\t\ttraceGoUnpark(gp, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> gp, <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Steal work from other P's.</span></span><br><span class=\"line\">  <span class=\"comment\">// 调用 runqsteal 尝试从其他P的本地运行队列盗取一半的G，如果还是获取不到，就需要休眠 M</span></span><br><span class=\"line\">\tprocs := <span class=\"keyword\">uint32</span>(gomaxprocs)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> atomic.Load(&amp;sched.npidle) == procs<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Either GOMAXPROCS=1 or everybody, except for us, is idle already.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// New work can appear from returning syscall/cgocall, network or timers.</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Neither of that submits to local run queues, so no point in stealing.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> stop</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// If number of spinning M's &gt;= number of busy P's, block.</span></span><br><span class=\"line\">\t<span class=\"comment\">// This is necessary to prevent excessive CPU consumption</span></span><br><span class=\"line\">\t<span class=\"comment\">// when GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !_g_.m.spinning &amp;&amp; <span class=\"number\">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> stop</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !_g_.m.spinning &#123;</span><br><span class=\"line\">\t\t_g_.m.spinning = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\tatomic.Xadd(&amp;sched.nmspinning, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> sched.gcwaiting != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> top</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tstealRunNextG := i &gt; <span class=\"number\">2</span> <span class=\"comment\">// first look for ready queues with more than 1 g</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> gp, <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">stop:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gcBlackenEnabled != <span class=\"number\">0</span> &amp;&amp; _p_.gcBgMarkWorker != <span class=\"number\">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class=\"line\">\t\t_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class=\"line\">\t\tgp := _p_.gcBgMarkWorker.ptr()</span><br><span class=\"line\">\t\tcasgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\t\ttraceGoUnpark(gp, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> gp, <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> beforeIdle() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> top</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tallpSnapshot := allp</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// return P and block</span></span><br><span class=\"line\">\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sched.gcwaiting != <span class=\"number\">0</span> || _p_.runSafePointFn != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> top</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 再次检查全局待运行队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> sched.runqsize != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tgp := globrunqget(_p_, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> gp, <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 释放当前 M 拥有的 P，P状态变为 _Pidle</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> releasep() != _p_ &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"findrunnable: wrong p\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 把 P 加入空闲 P 链表中</span></span><br><span class=\"line\">\tpidleput(_p_)</span><br><span class=\"line\">\tunlock(&amp;sched.lock)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 减少表示当前自旋中 M 数量的全局变量 nmspinning</span></span><br><span class=\"line\">\twasSpinning := _g_.m.spinning</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.spinning &#123;</span><br><span class=\"line\">\t\t_g_.m.spinning = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class=\"number\">-1</span>)) &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"findrunnable: negative nmspinning\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 再次检查所有 P 的本地dai运行队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, _p_ := <span class=\"keyword\">range</span> allpSnapshot &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !runqempty(_p_) &#123;</span><br><span class=\"line\">\t\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t\t_p_ = pidleget()</span><br><span class=\"line\">\t\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> _p_ != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tacquirep(_p_)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> wasSpinning &#123;</span><br><span class=\"line\">\t\t\t\t\t_g_.m.spinning = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t\tatomic.Xadd(&amp;sched.nmspinning, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> top</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 再次检查 GC Worker</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gcBlackenEnabled != <span class=\"number\">0</span> &amp;&amp; gcMarkWorkAvailable(<span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t_p_ = pidleget()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _p_ != <span class=\"literal\">nil</span> &amp;&amp; _p_.gcBgMarkWorker == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tpidleput(_p_)</span><br><span class=\"line\">\t\t\t_p_ = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _p_ != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tacquirep(_p_)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> wasSpinning &#123;</span><br><span class=\"line\">\t\t\t\t_g_.m.spinning = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\tatomic.Xadd(&amp;sched.nmspinning, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Go back to idle GC check.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> stop</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 再次检查 netpoll，此处调用阻塞，直到某个 fd 收到事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class=\"number\">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class=\"number\">0</span>) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.p != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"findrunnable: netpoll with p\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _g_.m.spinning &#123;</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"findrunnable: netpoll with spinning\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlist := netpoll(<span class=\"literal\">true</span>) <span class=\"comment\">// block until new work is available</span></span><br><span class=\"line\">\t\tatomic.Store64(&amp;sched.lastpoll, <span class=\"keyword\">uint64</span>(nanotime()))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !list.empty() &#123;</span><br><span class=\"line\">\t\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t\t_p_ = pidleget()</span><br><span class=\"line\">\t\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> _p_ != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tacquirep(_p_)</span><br><span class=\"line\">\t\t\t\tgp := list.pop()</span><br><span class=\"line\">\t\t\t\tinjectglist(&amp;list)</span><br><span class=\"line\">\t\t\t\tcasgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> trace.enabled &#123;</span><br><span class=\"line\">\t\t\t\t\ttraceGoUnpark(gp, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> gp, <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tinjectglist(&amp;list)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 休眠当前 M，等待被唤醒</span></span><br><span class=\"line\">\tstopm()</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> top</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是 <code>execute</code> 函数内部实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">execute</span><span class=\"params\">(gp *g, inheritTime <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 修改 g 的状态</span></span><br><span class=\"line\">\tcasgstatus(gp, _Grunnable, _Grunning)</span><br><span class=\"line\">\tgp.waitsince = <span class=\"number\">0</span></span><br><span class=\"line\">\tgp.preempt = <span class=\"literal\">false</span></span><br><span class=\"line\">\tgp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !inheritTime &#123;</span><br><span class=\"line\">\t\t_g_.m.p.ptr().schedtick++ <span class=\"comment\">//增加 P 记录的调度次数</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.m.curg = gp</span><br><span class=\"line\">\tgp.m = _g_.m</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Check whether the profiler needs to be turned on or off.</span></span><br><span class=\"line\">\thz := sched.profilehz</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.profilehz != hz &#123;</span><br><span class=\"line\">\t\tsetThreadCPUProfiler(hz)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// gogo 方法在不同的处理器架构实现不同，但也差不太多，下面的汇编是 amd64 上的实现 </span></span><br><span class=\"line\">\tgogo(&amp;gp.sched)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEXT runtime·gogo(SB), NOSPLIT, $16-8</span><br><span class=\"line\">\tMOVQ\tbuf+0(FP), BX\t\t// gobuf</span><br><span class=\"line\">\tMOVQ\tgobuf_g(BX), DX</span><br><span class=\"line\">\tMOVQ\t0(DX), CX\t\t// make sure g != nil</span><br><span class=\"line\">\tget_tls(CX)</span><br><span class=\"line\">\tMOVQ\tDX, g(CX)</span><br><span class=\"line\">\tMOVQ\tgobuf_sp(BX), SP\t// restore SP</span><br><span class=\"line\">\tMOVQ\tgobuf_ret(BX), AX</span><br><span class=\"line\">\tMOVQ\tgobuf_ctxt(BX), DX</span><br><span class=\"line\">\tMOVQ\tgobuf_bp(BX), BP</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_sp(BX)\t// clear to help garbage collector</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_ret(BX)</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_ctxt(BX)</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_bp(BX)</span><br><span class=\"line\">\tMOVQ\tgobuf_pc(BX), BX</span><br><span class=\"line\">\tJMP\tBX</span><br></pre></td></tr></table></figure>\n<p>这个函数会根据 g.sched 中保存的状态恢复各个寄存器的值，跳转至 pc ，也就是 g 的地址开始执行代码。目标函数执行完后会调用 goexit 函数，goexit 会调用 goexit1，goexit1 会通过 mcall 调用 goexit0 函数。</p>\n<p>mcall 会保存当前的运行状态到 g.sched，然后切换到 g0 和 g0 的栈空间，再调用 goexit0。在这里 mcall 的保存状态无意义，因为 g 已经结束了，但是当 g 被抢占或等待资源而进入休眠时，会在休眠前使用 mcall 保存状态，在唤醒后可以继续执行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 g0 当栈空间运行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">goexit0</span><span class=\"params\">(gp *g)</span></span> &#123;</span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 修改状态至 _Gdead</span></span><br><span class=\"line\">\tcasgstatus(gp, _Grunning, _Gdead)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> isSystemGoroutine(gp, <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">\t\tatomic.Xadd(&amp;sched.ngsys, <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清除相关成员数据</span></span><br><span class=\"line\">\tgp.m = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tlocked := gp.lockedm != <span class=\"number\">0</span></span><br><span class=\"line\">\tgp.lockedm = <span class=\"number\">0</span></span><br><span class=\"line\">\t_g_.m.lockedg = <span class=\"number\">0</span></span><br><span class=\"line\">\tgp.paniconfault = <span class=\"literal\">false</span></span><br><span class=\"line\">\tgp._defer = <span class=\"literal\">nil</span> <span class=\"comment\">// should be true already but just in case.</span></span><br><span class=\"line\">\tgp._panic = <span class=\"literal\">nil</span> <span class=\"comment\">// non-nil for Goexit during panic. points at stack-allocated data.</span></span><br><span class=\"line\">\tgp.writebuf = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tgp.waitreason = <span class=\"number\">0</span></span><br><span class=\"line\">\tgp.param = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tgp.labels = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tgp.timer = <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gcBlackenEnabled != <span class=\"number\">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tscanCredit := <span class=\"keyword\">int64</span>(gcController.assistWorkPerByte * <span class=\"keyword\">float64</span>(gp.gcAssistBytes))</span><br><span class=\"line\">\t\tatomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</span><br><span class=\"line\">\t\tgp.gcAssistBytes = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgp.gcscanvalid = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">// 解除 M 和 g 的关联</span></span><br><span class=\"line\">\tdropg()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> GOARCH == <span class=\"string\">\"wasm\"</span> &#123; <span class=\"comment\">// no threads yet on wasm</span></span><br><span class=\"line\">\t\tgfput(_g_.m.p.ptr(), gp)</span><br><span class=\"line\">\t\tschedule() <span class=\"comment\">// never returns</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _g_.m.lockedInt != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">\"invalid m-&gt;lockedInt = \"</span>, _g_.m.lockedInt, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"internal lockOSThread error\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 把 g 放入 P 的 gFree 列表中，下次创建 g 时可以复用</span></span><br><span class=\"line\">\tgfput(_g_.m.p.ptr(), gp)</span><br><span class=\"line\">\t<span class=\"comment\">// 继续调度</span></span><br><span class=\"line\">\tschedule()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个调度流程可以简单总结为：</p>\n<ol>\n<li>schedule 从各个地方获取 goroutine，都没有后进入 findrunnable</li>\n<li>在 findrunnable 中也获取不到后进入休眠，唤醒后返回函数顶部继续</li>\n<li>得到 goroutine 后，调用 execute 执行</li>\n<li>执行完成后调用 goexit ，然后重新执行 schedule</li>\n</ol>\n<p>当然触发重新调度的地方并不止上面的正常流程，在当前 goroutine 被抢占或者等待资源时也会重新进行调度。比如在 channel 里阻塞接受或发送数据时，会调用 goparkunlock -&gt; gopark -&gt; mcall(park_m) 这些函数将 goroutine 状态变为等待，最后调用 schedule 重新调度。</p>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - GC","url":"http://localhost:4000/2019/03/20/go-gc/","content":"<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><p>GC 的初始化在 runtime.schedinit 函数里的，方法为 gcinit，主要是一些参数的设置</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcinit</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// No sweep on the first cycle.</span></span><br><span class=\"line\">\tmheap_.sweepdone = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// GC 触发比率</span></span><br><span class=\"line\">\tmemstats.triggerRatio = <span class=\"number\">7</span> / <span class=\"number\">8.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Fake a heap_marked value so it looks like a trigger at</span></span><br><span class=\"line\">\t<span class=\"comment\">// heapminimum is the appropriate growth from heap_marked.</span></span><br><span class=\"line\">\t<span class=\"comment\">// This will go into computing the initial GC goal.</span></span><br><span class=\"line\">\tmemstats.heap_marked = <span class=\"keyword\">uint64</span>(<span class=\"keyword\">float64</span>(heapminimum) / (<span class=\"number\">1</span> + memstats.triggerRatio))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Set gcpercent from the environment. This will also compute</span></span><br><span class=\"line\">\t<span class=\"comment\">// and set the GC trigger and goal.</span></span><br><span class=\"line\">\t_ = setGCPercent(readgogc())</span><br><span class=\"line\"></span><br><span class=\"line\">\twork.startSema = <span class=\"number\">1</span></span><br><span class=\"line\">\twork.markDoneSema = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在用户代码执行前 GC 还做一些其他的准备工作</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> GOARCH != <span class=\"string\">\"wasm\"</span> &#123; <span class=\"comment\">// no threads on wasm yet, so no sysmon</span></span><br><span class=\"line\">\t\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// sysmon 系统监控，里面 for 循环会检测是否需要触发 GC</span></span><br><span class=\"line\">      <span class=\"comment\">// 满足条件后，将下面的 init 里 goroutine 加入运行队列中</span></span><br><span class=\"line\">\t\t\tnewm(sysmon, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 里面会启动一个 goroutine 进入休眠，等待系统监控触发 GC 后，开始执行 gcStart</span></span><br><span class=\"line\">  runtime_init() <span class=\"comment\">// must be before defer</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 启动后台清扫的 goroutine</span></span><br><span class=\"line\">\tgcenable()</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">//... main.main</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcenable</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> bgsweep(c)</span><br><span class=\"line\">\t&lt;-c</span><br><span class=\"line\">\tmemstats.enablegc = <span class=\"literal\">true</span> <span class=\"comment\">// now that runtime is initialized, GC is okay</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"触发条件\"><a href=\"#触发条件\" class=\"headerlink\" title=\"触发条件\"></a>触发条件</h4><p><code>gcStart</code> 函数是 GC 正式开始的地方，触发条件有以下几种：</p>\n<ul>\n<li>gcTriggerAlways 强制触发，源码里没找到使用地方</li>\n<li>gcTriggerHeap 当前分配内存达到一定值触发，<code>mallocgc</code> 函数里</li>\n<li>gcTriggerTime 当一定时间没有执行 GC 触发，上面的系统监控里</li>\n<li>gcTriggerCycle 手动触发 <code>runtime.GC()</code>，启动新的一轮GC，已启动则跳过</li>\n</ul>\n<p>触发条件判断在 gcTrigger 的 test 函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t gcTrigger)</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !memstats.enablegc || panicking != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t.kind == gcTriggerAlways &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gcphase != _GCoff &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> t.kind &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> gcTriggerHeap:</span><br><span class=\"line\">\t\t<span class=\"comment\">// 上个 GC 结束剩余的加上目前为止分配的内存超过了 gc_trigger</span></span><br><span class=\"line\">    <span class=\"comment\">// gc_trigger 每次 GC 标记终止阶段都会调整</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> gcTriggerTime:</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> gcpercent &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 上次 GC 时间到目前为止超过设定值就会触发GC，默认为2分钟</span></span><br><span class=\"line\">\t\tlastgc := <span class=\"keyword\">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> lastgc != <span class=\"number\">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> gcTriggerCycle:</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断是否是新一轮的GC</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">int32</span>(t.n-work.cycles) &gt; <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><p>Golang 的 GC 主要包含三个阶段，通过两个变量 <code>gcphase</code> 和 <code>writeBarrier</code> 来共同控制</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t_GCoff             = <span class=\"literal\">iota</span> <span class=\"comment\">// GC 没有运行，sweep 在后台运行，写屏障关闭</span></span><br><span class=\"line\">\t_GCmark                   <span class=\"comment\">// GC 标记阶段，扫描根对象和标记队列，写屏障开启</span></span><br><span class=\"line\">\t_GCmarktermination        <span class=\"comment\">// GC 标记完成阶段，会重新扫描部分根对象，写屏障开启</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setGCPhase</span><span class=\"params\">(x <span class=\"keyword\">uint32</span>)</span></span> &#123;</span><br><span class=\"line\">\tatomic.Store(&amp;gcphase, x)</span><br><span class=\"line\">\twriteBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination</span><br><span class=\"line\">\twriteBarrier.enabled = writeBarrier.needed || writeBarrier.cgo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个 GC 过程中，阶段的切换非常明确，其中会经历两次 STW，如果以 STW 为界限，可以将 GC 划分为 4 个阶段</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">阶段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">GCmark</td>\n<td style=\"text-align:left\">标记准备阶段，会计算任务数量，启用辅助GC等</td>\n<td style=\"text-align:center\">STW</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GCmark</td>\n<td style=\"text-align:left\">扫描标记阶段，与 Go 代码并发执行</td>\n<td style=\"text-align:center\">并发</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GCmarktermination</td>\n<td style=\"text-align:left\">标记终止阶段，会重新扫描部分根对象，结束时切换至 GCoff</td>\n<td style=\"text-align:center\">STW</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">GCoff</td>\n<td style=\"text-align:left\">内存清扫阶段，回收未标记的内存</td>\n<td style=\"text-align:center\">并发</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcStart</span><span class=\"params\">(trigger gcTrigger)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//... GC 前置检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 加锁，单个线程执行 STW</span></span><br><span class=\"line\">\tsemacquire(&amp;worldsema)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 进入标记前的准备工作</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 启动 mark workers，进入休眠等待唤醒，为每个 P 启动一个</span></span><br><span class=\"line\">\tgcBgMarkStartWorkers()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 重置标记相关的状态</span></span><br><span class=\"line\">\tgcResetMarkState()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//------------------------- 第一次 STW -------------------------------</span></span><br><span class=\"line\">\tsystemstack(stopTheWorldWithSema)</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">// 清扫上轮 GC 未清扫的 span</span></span><br><span class=\"line\">\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tfinishsweep_m()</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 进入标记阶段，开启写屏障</span></span><br><span class=\"line\">\tsetGCPhase(_GCmark)</span><br><span class=\"line\"></span><br><span class=\"line\">\tgcBgMarkPrepare()   <span class=\"comment\">// 重置标记计数</span></span><br><span class=\"line\">\tgcMarkRootPrepare() <span class=\"comment\">// 算扫描根对象的任务数量</span></span><br><span class=\"line\">\tgcMarkTinyAllocs()  <span class=\"comment\">// 标记所有tiny alloc等待合并的对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 启用辅助 GC</span></span><br><span class=\"line\">\tatomic.Store(&amp;gcBlackenEnabled, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tnow = startTheWorldWithSema(trace.enabled)</span><br><span class=\"line\">\t\twork.pauseNS += now - work.pauseStart</span><br><span class=\"line\">\t\twork.tMark = now</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">  <span class=\"comment\">//------------------------ 结束第一次 STW -------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mode != gcBackgroundMode &#123;</span><br><span class=\"line\">\t\tGosched()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsemrelease(&amp;work.startSema)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在结束第一次 STW 后，程序进入正常的调度流程，其中通过 <code>findRunnableGCWorker</code> 获取上面进入休眠的 mark wokers 后唤醒它继续执行，此时程序进入并发的扫描标记阶段。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过上面的 gcBgMarkStartWorkers 调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcBgMarkWorker</span><span class=\"params\">(_p_ *p)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 陷入休眠，等待唤醒</span></span><br><span class=\"line\">\t\tgopark(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(g *g, parkp unsafe.Pointer)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\t\t&#125;, unsafe.Pointer(park), waitReasonGCWorkerIdle, traceEvGoBlock, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 此处被唤醒继续执行</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">//... 一些检查和参数设置</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 切换至 g0 运行</span></span><br><span class=\"line\">\t\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 设置G的状态为等待中这样它的栈可以被扫描(两个后台标记任务可以互相扫描对方的栈)</span></span><br><span class=\"line\">\t\t\tcasgstatus(gp, _Grunning, _Gwaiting)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">      <span class=\"comment\">// 根据不同的模式执行扫描标记任务，省略了部分代码</span></span><br><span class=\"line\">      gcDrain(&amp;_p_.gcw, mode） </span><br><span class=\"line\">      </span><br><span class=\"line\">\t\t\tcasgstatus(gp, _Gwaiting, _Grunning)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 所有扫描标记任务完成后，准备进入标记完成阶段</span></span><br><span class=\"line\">\t\t\tgcMarkDone()</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在所有的的扫描标记任务结束后，程序准备进入标记终止阶段，此处会进行第二次 STW</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcMarkDone</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 加锁</span></span><br><span class=\"line\">\tsemacquire(&amp;work.markDoneSema)</span><br><span class=\"line\"></span><br><span class=\"line\">top:</span><br><span class=\"line\">\t<span class=\"comment\">//... 重新检查一些节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//------------------------- 第二次 STW -------------------------</span></span><br><span class=\"line\">\tsystemstack(stopTheWorldWithSema)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 禁止后台标记任务和辅助GC运行</span></span><br><span class=\"line\">\tatomic.Store(&amp;gcBlackenEnabled, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tgcWakeAllAssists()</span><br><span class=\"line\">\tsemrelease(&amp;work.markDoneSema)</span><br><span class=\"line\">\tschedEnableUser(<span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 计算下一次触发 GC 的 ratio</span></span><br><span class=\"line\">\tnextTriggerRatio := gcController.endCycle()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 执行终止函数，里面会结束第二次 STW</span></span><br><span class=\"line\">\tgcMarkTermination(nextTriggerRatio)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcMarkTermination</span><span class=\"params\">(nextTriggerRatio <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// World is stopped.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置标记终止阶段</span></span><br><span class=\"line\">\tsetGCPhase(_GCmarktermination)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 再次检查一些节点</span></span><br><span class=\"line\">\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tgcMark(startTime)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//... 再进行一些检查，扫描标记</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t\t<span class=\"comment\">// 设置 GC 阶段至 GCoff，并关闭写屏障</span></span><br><span class=\"line\">\t\tsetGCPhase(_GCoff)</span><br><span class=\"line\">    <span class=\"comment\">// 唤醒后台清扫任务</span></span><br><span class=\"line\">\t\tgcSweep(work.mode)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 更新下一次触发gc需要的 heap 大小(gc_trigger)</span></span><br><span class=\"line\">\tgcSetTriggerRatio(nextTriggerRatio)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//... 更新一些记录</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//------------------ 结束第二次 STW ----------------------- </span></span><br><span class=\"line\">\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; startTheWorldWithSema(<span class=\"literal\">true</span>) &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//... 准备一些清扫阶段的工作</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，本次 GC 所有的扫描标记任务已经完成，之后会唤醒在程序初始化时陷入休眠的清扫 goroutine，正式进入 sweep 阶段，这个阶段会在下面小节详细说明。</p>\n<h4 id=\"根对象\"><a href=\"#根对象\" class=\"headerlink\" title=\"根对象\"></a>根对象</h4><p>在 GC 的标记阶段，首先要标记的就是根对象，从根对象开始可到达的所有对象都会被认为是存活的。</p>\n<ul>\n<li><strong>fixed root</strong> 析构器队列和已经 dead 的 goroutine</li>\n<li><strong>data root</strong> 已经初始化的全局变量</li>\n<li><strong>bss root</strong> 未初始化的全局变量</li>\n<li><strong>span root</strong>  各个 span 中的特殊对象</li>\n<li><strong>stack root</strong>  各个 goroutine 的栈</li>\n<li><strong>flush mcache</strong> 释放 mcache 中的所有的 mspan </li>\n</ul>\n<h4 id=\"扫描\"><a href=\"#扫描\" class=\"headerlink\" title=\"扫描\"></a>扫描</h4><p>正式开始执行扫描任务是通过 <code>gcDrain</code> 函数进行，里面通过 <code>markroot</code> 对根对象进行扫描，根对象扫描标记完成后，对标记队列开始扫描，最后进入扫描标记终止阶段。扫描的方法有下面的几个：</p>\n<ul>\n<li>scanblock  一个通用的扫描函数，扫描全局变量和栈空间会用到</li>\n<li>scang 扫描 goroutine 的栈，依次调用 scanstack，最后调用到 scanblock</li>\n<li>scanobject 扫描从标记队列取出的对象</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcDrain</span><span class=\"params\">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//... 标志位设置，检查等</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 扫描根对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class=\"line\">\t\t\tjob := atomic.Xadd(&amp;work.markrootNext, +<span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmarkroot(gcw, job)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> check != <span class=\"literal\">nil</span> &amp;&amp; check() &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> done</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 消费标记队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> work.full == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tgcw.balance()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tb := gcw.tryGetFast()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tb = gcw.tryGet()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> b == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\twbBufFlush(<span class=\"literal\">nil</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tb = gcw.tryGet()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 扫描标记队列的对象</span></span><br><span class=\"line\">\t\tscanobject(b, gcw)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"三色标记\"><a href=\"#三色标记\" class=\"headerlink\" title=\"三色标记\"></a>三色标记</h4><blockquote>\n<p>白色集合：本次 GC 未被标记，可以回收内存的对象</p>\n<p>灰色集合：已被标记，但包含的子对象未被扫描标记</p>\n<p>黑色集合：已被标记，包含的子对象也被扫描标记过</p>\n</blockquote>\n<p>在 Golang 中，白色对象在它所属 <code>mspan</code> 的 <code>gcmarkBits</code> 对应 bit 为 0，灰色对象为 1 且对象在标记队列中， 黑色对象为 1 且不在标记队列中，GC 完成后， <code>gcmarkBits</code> 复制给 <code>allocBits</code> 然后重置。</p>\n<p><code>gcmarkBits</code> 和 <code>allocBits</code> 在 <code>mspan</code> 初始化时，根据所能存储对象的个数从堆外内存分配，需要 8 字节对齐</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newMarkBits</span><span class=\"params\">(nelems <span class=\"keyword\">uintptr</span>)</span> *<span class=\"title\">gcBits</span></span> &#123;</span><br><span class=\"line\">\tblocksNeeded := <span class=\"keyword\">uintptr</span>((nelems + <span class=\"number\">63</span>) / <span class=\"number\">64</span>)</span><br><span class=\"line\">\tbytesNeeded := blocksNeeded * <span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// gcBitsArena 是堆外内存块</span></span><br><span class=\"line\">\thead := (*gcBitsArena)(atomic.Loadp(unsafe.Pointer(&amp;gcBitsArenas.next)))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p := head.tryAlloc(bytesNeeded); p != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>标记时根据对象在 <code>mspan</code> 的位置索引找到对应的 bit 位进行操作</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *gcBits)</span> <span class=\"title\">bytep</span><span class=\"params\">(n <span class=\"keyword\">uintptr</span>)</span> *<span class=\"title\">uint8</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> addb((*<span class=\"keyword\">uint8</span>)(b), n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查找对象对应的字节，及需要的偏移量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b *gcBits)</span> <span class=\"title\">bitp</span><span class=\"params\">(n <span class=\"keyword\">uintptr</span>)</span> <span class=\"params\">(bytep *<span class=\"keyword\">uint8</span>, mask <span class=\"keyword\">uint8</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b.bytep(n / <span class=\"number\">8</span>), <span class=\"number\">1</span> &lt;&lt; (n % <span class=\"number\">8</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *mspan)</span> <span class=\"title\">markBitsForIndex</span><span class=\"params\">(objIndex <span class=\"keyword\">uintptr</span>)</span> <span class=\"title\">markBits</span></span> &#123;</span><br><span class=\"line\">\tbytep, mask := s.gcmarkBits.bitp(objIndex)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> markBits&#123;bytep, mask, objIndex&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m markBits)</span> <span class=\"title\">setMarked</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 进行标记</span></span><br><span class=\"line\">\tatomic.Or8(m.bytep, m.mask)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面提到的灰色对象都在 <strong>标记队列</strong> 里，队列的实现由两个缓冲区构成，依次使用，都填满后数据放入全局队列里</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> gcWork <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twbuf1, wbuf2 *workbuf</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> workbufhdr <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tnode lfnode <span class=\"comment\">// must be first</span></span><br><span class=\"line\">\tnobj <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//go:notinheap</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> workbuf <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tworkbufhdr</span><br><span class=\"line\">\t<span class=\"comment\">// account for the above fields</span></span><br><span class=\"line\">\tobj [(_WorkbufSize - unsafe.Sizeof(workbufhdr&#123;&#125;)) / sys.PtrSize]<span class=\"keyword\">uintptr</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>标记队列的添加操作通常在扫描过程中将对象变为灰色时执行，还有一些是在启用写屏障后加入标记队列的，这部分会在后面详细说明</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greyobject</span><span class=\"params\">(obj, base, off <span class=\"keyword\">uintptr</span>, span *mspan, gcw *gcWork, objIndex <span class=\"keyword\">uintptr</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// obj should be start of allocation, and so must be at least pointer-aligned.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> obj&amp;(sys.PtrSize<span class=\"number\">-1</span>) != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"greyobject: obj not pointer-aligned\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmbits := span.markBitsForIndex(objIndex)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> useCheckmark &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 已被标记，直接返回</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> mbits.isMarked() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 标记对象，对应的 bit 位置为 1</span></span><br><span class=\"line\">\t\tmbits.setMarked()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Mark span.</span></span><br><span class=\"line\">\t\tarena, pageIdx, pageMask := pageIndexOf(span.base())</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> arena.pageMarks[pageIdx]&amp;pageMask == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tatomic.Or8(&amp;arena.pageMarks[pageIdx], pageMask)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果对象不包含指针，则不需要放入标记队列</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> span.spanclass.noscan() &#123;</span><br><span class=\"line\">\t\t\tgcw.bytesMarked += <span class=\"keyword\">uint64</span>(span.elemsize)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 把对象放入标记队列中</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !gcw.putFast(obj) &#123;</span><br><span class=\"line\">\t\tgcw.put(obj)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对应的消费操作是在扫描根对象完成后进行的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcDrain</span><span class=\"params\">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ... 一些根对象扫描工作</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 非抢占情况下，开始消费标记队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果全局队列为空，平衡下全局标记队列和本地标记队列的数量</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> work.full == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tgcw.balance()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从标记队列获取对象</span></span><br><span class=\"line\">\t\tb := gcw.tryGetFast()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tb = gcw.tryGet()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> b == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\twbBufFlush(<span class=\"literal\">nil</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tb = gcw.tryGet()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 标记队列为空，跳出循环</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> b == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 扫描获取到的对象</span></span><br><span class=\"line\">\t\tscanobject(b, gcw)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等所有的标记队列都为空后，对象被分为白色和黑色集合，然后就会进入清扫阶段。</p>\n<h4 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h4><p>Golang 的 GC 是并发式的 GC，也就是说 GC 的扫描阶段和 Go 的代码可以同时运行，这样带来的问题是 GC 扫描过程中 Go 代码可能会改变了对象的依赖导致某些对象无法被扫描到。</p>\n<p>比如开始扫描时，有根对象 A 和 B，B 拥有 C 的指针，GC 扫描了 A 后，Go 代码把 C 的指针给了 A，GC 再扫描到 B，此时 C 就不会被扫描到，会被当作垃圾清理掉。为了避免这个问题，Golang 在 GC 扫描标记阶段会启用写屏障。</p>\n<p>在启用写屏障后，当 B 把 C 的指针交给 A 时，GC 会将 C 对象标记为灰色，避免 C 被当作垃圾清理掉。但是有个缺点是，由于 Golang 里对栈上指针插入添加屏障的成本非常昂贵，所以只对堆上指针的插入增加了写屏障，这样会出现扫描结束后，栈上仍然存在引用白色对象的情况，此时栈是灰色，需要对栈重新扫描，这个过程得 STW，如果 Goroutine 多的话，重新扫描可能会花费 10 到 100 毫秒的时间。</p>\n<p>为了减少 STW，Go 在 1.8 版本使用了混合写屏障，该技术结合了 Yuasa 样式的删除写屏障和 Dijkstra 样式的插入写屏障，实现如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">writePointer(slot, ptr):</span><br><span class=\"line\">    shade(*slot)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> current stack is grey:</span><br><span class=\"line\">        shade(ptr)</span><br><span class=\"line\">    *slot = ptr</span><br></pre></td></tr></table></figure>\n<p>slot 是原指针，ptr 是新指针</p>\n<ol>\n<li>shade(*slot) 标记原始对象，也就是说在要取消堆上对象的引用时，将堆上对象标记为灰色</li>\n<li>shade(ptr) 标记新对象，就是上面 A B C 的例子</li>\n<li>当 stack 为黑色时，不需要进行第二步，因为要进行 shade(ptr) 需要指针提前在栈上，stack 为黑色表示已经扫描过了</li>\n</ol>\n<p>除了混合写屏障外，在 GC 过程中所有新分配的对象都会立刻标记为黑色</p>\n<h4 id=\"清扫\"><a href=\"#清扫\" class=\"headerlink\" title=\"清扫\"></a>清扫</h4><p>扫描标记完成后，通过 <code>gcSweep</code> 唤醒 GC 初始化时启动的后台清扫 goroutine <code>bgsweep</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bgsweep</span><span class=\"params\">(c <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tsweep.g = getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\tlock(&amp;sweep.lock)</span><br><span class=\"line\">\tsweep.parked = <span class=\"literal\">true</span></span><br><span class=\"line\">\tc &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">\tgoparkunlock(&amp;sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 清扫一个 span，然后进入调度</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> sweepone() != ^<span class=\"keyword\">uintptr</span>(<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tsweep.nbgsweep++</span><br><span class=\"line\">\t\t\tGosched()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 释放一些 workbufs 回到堆中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> freeSomeWbufs(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\t\tGosched()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果清扫未完成则继续循环</span></span><br><span class=\"line\">\t\tlock(&amp;sweep.lock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !isSweepDone() &#123;</span><br><span class=\"line\">\t\t\tunlock(&amp;sweep.lock)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 完成后进入休眠</span></span><br><span class=\"line\">\t\tsweep.parked = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\tgoparkunlock(&amp;sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>Golang 的 GC 从最初的版本到如今在不断的优化，早期只是简单的 标记-清除，整个过程都需要 STW，效果不理想，在 1.5 版本引入三色标记，标记和清扫都可以和用户代码并发执行，但标记前后需要 STW 做些准备工作，尤其后面一次为了解决标记期间对象引用的更改，要重新扫描栈相当耗时。然后在 1.6 版本引入了写屏障，特别是 1.8 实现了混合写屏障，避免了堆栈重新扫描的过程，极大的减少了 STW 的时间。</p>\n","categories":[],"tags":["Golang"]},{"title":"Golang 源码阅读 - 内存管理","url":"http://localhost:4000/2019/03/08/go-memory/","content":"<p>Go 语言的内存分配算法来自 <code>TCMalloc</code> ，核心的思想就是把内存分为多级管理，从而降低锁的粒度和内存碎片的数量。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>Golang 里的堆栈内存和传统意义的堆栈不太相同，传统意义上栈被 Go 的运行时霸占，不对用户代码开放，而传动意义上的堆内存被 Go 分成两个部分，一个是 Go 运行时自身需要的堆内存，称为堆外内存，一个是用于用户代码使用的堆内存，称为 Go 堆。Go 堆负责了用户对象的存放和 goroutine 的执行栈。</p>\n<p>Go 在1.11后修改了内存布局，由一系列 <code>arena</code> 组成，这些 <code>arena</code> 合起来就是我们所说的 Go 堆，Go 程序还在堆外分配一个二维数组，里面存放了每个 <code>arena</code> 的元数据，分别指向了对应的堆地址空间，数组的维度和 <code>arena</code> 的大小与寻址的 bit 位数有关。</p>\n<p>比如在Linux 64位机器上，使用 48 位地址寻址，单个 <code>arena</code> 的大小为 64M，L1的数量通常为1，根据公式可得出 L2 的数量为 2^22</p>\n<blockquote>\n<p>(1 &lt;&lt; addr bits) = arena size <em> L1 entries </em> L2 entries</p>\n</blockquote>\n<p>二维数组的元素表示为 <code>heapArena</code>，里面包含了 <code>bitmap</code> 及 <code>spans</code></p>\n<p><code>bitmap</code> 区域一个 byte 对应 <code>arena</code> 4个指针大小（32 byte），每 4 个 bit 位用来表示对应的 <code>arena</code> 地址对象是否包含指针和有没有被 GC 标记过。</p>\n<p><code>spans</code> 区域存放着 <code>mspan</code> 的指针，每个指针对应一页，Golang 中一页大小为 8K，假如一个 <code>mspan</code> 有三页，那这三页对应的 <code>spans</code> 区域都为同一个 <code>mspan</code> 指针，主要用于回收对象时根据地址反查所属的 <code>mspan</code>。</p>\n<h4 id=\"mspan\"><a href=\"#mspan\" class=\"headerlink\" title=\"mspan\"></a>mspan</h4><p><code>mspan</code> 是 Go 中内存管理的基本单元，由一组连续的页组成，里面包含了页的起始地址，规格和数量等内容。它会根据自身的属性 <code>spanclass</code> 声明自己可以存储多少个对象及每个对象的大小。在 Go 中 <code>mspan</code> 的种类共计 67  种，称为 <code>sizeclass</code> ，<code>spanclass</code> 与之对应关系为 <code>sizeclass = spanclass / 2</code>，是它的两倍表示同一个 <code>sizeclass</code> 会有两个 <code>spanclass</code> ，一个分配含有指针的对象，一个分配不含指针的对象，方便后续 GC 操作。 </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _NumSizeClasses = <span class=\"number\">67</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> class_to_size = [_NumSizeClasses]<span class=\"keyword\">uint16</span>&#123;<span class=\"number\">0</span>, <span class=\"number\">8</span>, <span class=\"number\">16</span>, <span class=\"number\">32</span>, <span class=\"number\">48</span>, <span class=\"number\">64</span>, <span class=\"number\">80</span>, <span class=\"number\">96</span>, <span class=\"number\">112</span>, <span class=\"number\">128</span>, <span class=\"number\">144</span>, <span class=\"number\">160</span>, <span class=\"number\">176</span>, <span class=\"number\">192</span>, <span class=\"number\">208</span>, <span class=\"number\">224</span>, <span class=\"number\">240</span>, <span class=\"number\">256</span>, <span class=\"number\">288</span>, <span class=\"number\">320</span>, <span class=\"number\">352</span>, <span class=\"number\">384</span>, <span class=\"number\">416</span>, <span class=\"number\">448</span>, <span class=\"number\">480</span>, <span class=\"number\">512</span>, <span class=\"number\">576</span>, <span class=\"number\">640</span>, <span class=\"number\">704</span>, <span class=\"number\">768</span>, <span class=\"number\">896</span>, <span class=\"number\">1024</span>, <span class=\"number\">1152</span>, <span class=\"number\">1280</span>, <span class=\"number\">1408</span>, <span class=\"number\">1536</span>, <span class=\"number\">1792</span>, <span class=\"number\">2048</span>, <span class=\"number\">2304</span>, <span class=\"number\">2688</span>, <span class=\"number\">3072</span>, <span class=\"number\">3200</span>, <span class=\"number\">3456</span>, <span class=\"number\">4096</span>, <span class=\"number\">4864</span>, <span class=\"number\">5376</span>, <span class=\"number\">6144</span>, <span class=\"number\">6528</span>, <span class=\"number\">6784</span>, <span class=\"number\">6912</span>, <span class=\"number\">8192</span>, <span class=\"number\">9472</span>, <span class=\"number\">9728</span>, <span class=\"number\">10240</span>, <span class=\"number\">10880</span>, <span class=\"number\">12288</span>, <span class=\"number\">13568</span>, <span class=\"number\">14336</span>, <span class=\"number\">16384</span>, <span class=\"number\">18432</span>, <span class=\"number\">19072</span>, <span class=\"number\">20480</span>, <span class=\"number\">21760</span>, <span class=\"number\">24576</span>, <span class=\"number\">27264</span>, <span class=\"number\">28672</span>, <span class=\"number\">32768</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> class_to_allocnpages = [_NumSizeClasses]<span class=\"keyword\">uint8</span>&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">3</span>, <span class=\"number\">10</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>比如一个 <code>mspan</code> 的 <code>spanclass</code> 为 8，得到它的 <code>sizeclass</code> 为 4，在 <code>class_to_size</code> 中可以看到它存储的对象大小为 48B，在 <code>class_to_allocnpages</code> 得到它的页数为 1 个，那么能存储的对象个数为 8K / 48B = 170 个。</p>\n<p>这里面最大的对象是 32K，超过 32K 的对象称为大对象，对其分配是会进行特殊处理，对应的 <code>spanclass</code> 为 0</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> mspan <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tnext *mspan  </span><br><span class=\"line\">\tprev *mspan     </span><br><span class=\"line\">\tstartAddr <span class=\"keyword\">uintptr</span>      <span class=\"comment\">// 起始地址，指向第一个页</span></span><br><span class=\"line\">\tnpages    <span class=\"keyword\">uintptr</span>      <span class=\"comment\">// 页的数量</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\tfreeindex <span class=\"keyword\">uintptr</span>      <span class=\"comment\">// 标记已经分配到的位置</span></span><br><span class=\"line\">\tnelems <span class=\"keyword\">uintptr</span>         <span class=\"comment\">// 块的个数，表示可分配多少个对象</span></span><br><span class=\"line\">\tallocCache <span class=\"keyword\">uint64</span>      <span class=\"comment\">// allocBits的缓存，从freeindex开始</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tallocBits  *gcBits     <span class=\"comment\">// 标记块是否被分配对象</span></span><br><span class=\"line\">\tgcmarkBits *gcBits     <span class=\"comment\">// 标记对象是否被 GC mark</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tallocCount  <span class=\"keyword\">uint16</span>     <span class=\"comment\">// 已分配的块数</span></span><br><span class=\"line\">\tspanclass   spanClass  <span class=\"comment\">// class id</span></span><br><span class=\"line\">\telemsize    <span class=\"keyword\">uintptr</span>    <span class=\"comment\">// 对象大小，也就是块的大小</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> spanClass <span class=\"keyword\">uint8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据 spanClass 获取 sizeclass</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sc spanClass)</span> <span class=\"title\">sizeclass</span><span class=\"params\">()</span> <span class=\"title\">int8</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int8</span>(sc &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回 spanClass 是否需要扫描，也就是是否分配包含指针的对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sc spanClass)</span> <span class=\"title\">noscan</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sc&amp;<span class=\"number\">1</span> != <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"mcache\"><a href=\"#mcache\" class=\"headerlink\" title=\"mcache\"></a>mcache</h4><p>每个工作线程 M 都会绑定一个 <code>mcache</code> ，里面缓存着可用的 <code>mspan</code> ，这样的好处是在一个线程上没有竞争，可以直接给 goroutine 分配内存而无需加锁。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> mcache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 包含所有种类的 mspan，每个种类分两种，共计 134 个</span></span><br><span class=\"line\">  <span class=\"comment\">// [0_scan,0_noscan,1_scan,1_noscan,....]</span></span><br><span class=\"line\">\talloc [numSpanClasses]*mspan</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mcache</code> 在初始化时是没任何 <code>mspan</code> 的，是在使用过程中动态的从 <code>mcentral</code> 中申请，之后缓存下来。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *mcache)</span> <span class=\"title\">refill</span><span class=\"params\">(spc spanClass)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Return the current cached span to the central lists.</span></span><br><span class=\"line\">\ts := c.alloc[spc]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 确保当前的span所有元素都已分配</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"keyword\">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"refill of span with free space remaining\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s != &amp;emptymspan &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Mark this span as no longer cached.</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.sweepgen != mheap_.sweepgen+<span class=\"number\">3</span> &#123;</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"bad sweepgen in refill\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tatomic.Store(&amp;s.sweepgen, mheap_.sweepgen)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 向 mcentral 申请一个新的span</span></span><br><span class=\"line\">\ts = mheap_.central[spc].mcentral.cacheSpan()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"out of memory\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"keyword\">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"span has no free space\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ts.sweepgen = mheap_.sweepgen + <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tc.alloc[spc] = s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"mcentral\"><a href=\"#mcentral\" class=\"headerlink\" title=\"mcentral\"></a>mcentral</h4><p>为所有的 <code>mcache</code> 提供切分好的 <code>mspan</code> ，每个 <code>mcentral</code> 都保存着两个特定类型的全局 <code>mspan</code> 链表。总共有 134 个 <code>mcentral</code> 。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> mcentral <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tlock      mutex      <span class=\"comment\">// 全局对象，互斥锁</span></span><br><span class=\"line\">\tspanclass spanClass </span><br><span class=\"line\">\tnonempty  mSpanList  <span class=\"comment\">// 可用的 mspan 链表</span></span><br><span class=\"line\">\tempty     mSpanList  <span class=\"comment\">// 没有空闲对象或已被 mcache 缓存的 mspan 链表</span></span><br><span class=\"line\">\tnmalloc <span class=\"keyword\">uint64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假如需要分配内存时，<code>mcentral</code> 没有可用的 <code>mspan</code> ，此时需要向 <code>mheap</code> 去申请，具体分配逻辑如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *mcentral)</span> <span class=\"title\">cacheSpan</span><span class=\"params\">()</span> *<span class=\"title\">mspan</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 分配时，会让当前的 goroutine 协助一部分 sweep 工作</span></span><br><span class=\"line\">\tspanBytes := <span class=\"keyword\">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize</span><br><span class=\"line\">\tdeductSweepCredit(spanBytes, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlock(&amp;c.lock)</span><br><span class=\"line\">\tsg := mheap_.sweepgen</span><br><span class=\"line\">  <span class=\"comment\">// sweepgen每次GC都会增加2</span></span><br><span class=\"line\">  <span class=\"comment\">// - sweepgen == 全局sweepgen, 表示span已经sweep过</span></span><br><span class=\"line\">  <span class=\"comment\">// - sweepgen == 全局sweepgen-1, 表示span正在sweep</span></span><br><span class=\"line\">  <span class=\"comment\">// - sweepgen == 全局sweepgen-2, 表示span等待sweep</span></span><br><span class=\"line\">  </span><br><span class=\"line\">retry:</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> s *mspan</span><br><span class=\"line\">  <span class=\"comment\">// 优先查找 nonempty 链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> s = c.nonempty.first; s != <span class=\"literal\">nil</span>; s = s.next &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 span 等待 sweep，尝试修改状态为 sg-1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.sweepgen == sg<span class=\"number\">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class=\"number\">-2</span>, sg<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 成功后把它添加到 empty 链表尾部，跳转至 havespan</span></span><br><span class=\"line\">\t\t\tc.nonempty.remove(s)</span><br><span class=\"line\">\t\t\tc.empty.insertBack(s)</span><br><span class=\"line\">\t\t\tunlock(&amp;c.lock)</span><br><span class=\"line\">\t\t\ts.sweep(<span class=\"literal\">true</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> havespan</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.sweepgen == sg<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 正在被其他线程 sweep，跳过</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 可以直接使用</span></span><br><span class=\"line\">\t\tc.nonempty.remove(s)</span><br><span class=\"line\">\t\tc.empty.insertBack(s)</span><br><span class=\"line\">\t\tunlock(&amp;c.lock)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> havespan</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 查找 empty 链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> s = c.empty.first; s != <span class=\"literal\">nil</span>; s = s.next &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 span 等待 sweep，尝试修改状态为 sg-1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.sweepgen == sg<span class=\"number\">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class=\"number\">-2</span>, sg<span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 修改成功，移动至链表尾部</span></span><br><span class=\"line\">\t\t\tc.empty.remove(s)</span><br><span class=\"line\">\t\t\tc.empty.insertBack(s)</span><br><span class=\"line\">\t\t\tunlock(&amp;c.lock)</span><br><span class=\"line\">\t\t\ts.sweep(<span class=\"literal\">true</span>)</span><br><span class=\"line\">      <span class=\"comment\">// 检查是否有空闲位置</span></span><br><span class=\"line\">\t\t\tfreeIndex := s.nextFreeIndex()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> freeIndex != s.nelems &#123;</span><br><span class=\"line\">\t\t\t\ts.freeindex = freeIndex</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> havespan</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tlock(&amp;c.lock)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> retry</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.sweepgen == sg<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tunlock(&amp;c.lock)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 未找到 span，向 mheap 申请</span></span><br><span class=\"line\">\ts = c.grow()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlock(&amp;c.lock)</span><br><span class=\"line\">\tc.empty.insertBack(s)</span><br><span class=\"line\">\tunlock(&amp;c.lock)</span><br><span class=\"line\"></span><br><span class=\"line\">havespan:</span><br><span class=\"line\"></span><br><span class=\"line\">\tn := <span class=\"keyword\">int</span>(s.nelems) - <span class=\"keyword\">int</span>(s.allocCount)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> || s.freeindex == s.nelems || <span class=\"keyword\">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"span has no free objects\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tatomic.Xadd64(&amp;c.nmalloc, <span class=\"keyword\">int64</span>(n))</span><br><span class=\"line\">\tusedBytes := <span class=\"keyword\">uintptr</span>(s.allocCount) * s.elemsize</span><br><span class=\"line\">\tatomic.Xadd64(&amp;memstats.heap_live, <span class=\"keyword\">int64</span>(spanBytes)-<span class=\"keyword\">int64</span>(usedBytes))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> gcBlackenEnabled != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// heap_live changed.</span></span><br><span class=\"line\">\t\tgcController.revise()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfreeByteBase := s.freeindex &amp;^ (<span class=\"number\">64</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">\twhichByte := freeByteBase / <span class=\"number\">8</span></span><br><span class=\"line\">\t<span class=\"comment\">// Init alloc bits cache.</span></span><br><span class=\"line\">\ts.refillAllocCache(whichByte)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Adjust the allocCache so that s.freeindex corresponds to the low bit in</span></span><br><span class=\"line\">\t<span class=\"comment\">// s.allocCache.</span></span><br><span class=\"line\">\ts.allocCache &gt;&gt;= s.freeindex % <span class=\"number\">64</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"mheap\"><a href=\"#mheap\" class=\"headerlink\" title=\"mheap\"></a>mheap</h4><p><code>mheap</code> 可以认为是 Go 程序持有的整个堆空间，<code>mheap_</code> 为唯一全局对象用来管理堆内存，里面的数据会在程序启动时初始化完成。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mheap_ mheap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> mheap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tlock      mutex</span><br><span class=\"line\">  </span><br><span class=\"line\">  free      mTreap <span class=\"comment\">// free and non-scavenged spans</span></span><br><span class=\"line\">\tscav      mTreap <span class=\"comment\">// free and scavenged spans</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 存放所有产生的 mspan</span></span><br><span class=\"line\">\tallspans []*mspan </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// arenas 是个二维数组，元素为 heapArena，里面存放着 arena 的 metadata</span></span><br><span class=\"line\">  <span class=\"comment\">// 每个 arena 都有一个对应的 heapArena</span></span><br><span class=\"line\">\tarenas [<span class=\"number\">1</span> &lt;&lt; arenaL1Bits]*[<span class=\"number\">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// arena 链表，保存了起始地址、是否为最后一个 arena</span></span><br><span class=\"line\">  arenaHints *arenaHint</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 全部的 mcentral，共计134个</span></span><br><span class=\"line\">\tcentral [numSpanClasses]<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tmcentral mcentral</span><br><span class=\"line\">\t\tpad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class=\"keyword\">byte</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> heapArena <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 每 2 个 bit 对应 arena 里一个指针大小的数据</span></span><br><span class=\"line\">\tbitmap [heapArenaBitmapBytes]<span class=\"keyword\">byte</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// spans 将 page 对应到 mspan</span></span><br><span class=\"line\">\tspans [pagesPerArena]*mspan</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mheap</code> 分配 <code>mspan</code> 的函数是 alloc，这个函数会在 g0 栈空间中调用 alloc_m 函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *mheap)</span> <span class=\"title\">alloc</span><span class=\"params\">(npage <span class=\"keyword\">uintptr</span>, spanclass spanClass, large <span class=\"keyword\">bool</span>, needzero <span class=\"keyword\">bool</span>)</span> *<span class=\"title\">mspan</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> s *mspan</span><br><span class=\"line\">\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\ts = h.alloc_m(npage, spanclass, large)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> needzero &amp;&amp; s.needzero != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tmemclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ts.needzero = <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *mheap)</span> <span class=\"title\">alloc_m</span><span class=\"params\">(npage <span class=\"keyword\">uintptr</span>, spanclass spanClass, large <span class=\"keyword\">bool</span>)</span> *<span class=\"title\">mspan</span></span> &#123;</span><br><span class=\"line\">\t_g_ := getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 防止 heap 增长过快，分配前清扫回收等量的 page</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> h.sweepdone == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\th.reclaim(npage)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlock(&amp;h.lock)</span><br><span class=\"line\">\t<span class=\"comment\">// transfer stats from cache to global</span></span><br><span class=\"line\">\tmemstats.heap_scan += <span class=\"keyword\">uint64</span>(_g_.m.mcache.local_scan)</span><br><span class=\"line\">\t_g_.m.mcache.local_scan = <span class=\"number\">0</span></span><br><span class=\"line\">\tmemstats.tinyallocs += <span class=\"keyword\">uint64</span>(_g_.m.mcache.local_tinyallocs)</span><br><span class=\"line\">\t_g_.m.mcache.local_tinyallocs = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 分配 span </span></span><br><span class=\"line\">\ts := h.allocSpanLocked(npage, &amp;memstats.heap_inuse)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">  \t... <span class=\"comment\">// 记录 span 的信息</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\tunlock(&amp;h.lock)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *mheap)</span> <span class=\"title\">allocSpanLocked</span><span class=\"params\">(npage <span class=\"keyword\">uintptr</span>, stat *<span class=\"keyword\">uint64</span>)</span> *<span class=\"title\">mspan</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> s *mspan</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 从 free 链表分配</span></span><br><span class=\"line\">\ts = h.pickFreeSpan(npage)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> HaveSpan</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 失败的话，向系统申请内存</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !h.grow(npage) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 再试一次</span></span><br><span class=\"line\">\ts = h.pickFreeSpan(npage)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> HaveSpan</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthrow(<span class=\"string\">\"grew heap, but no adequate free span found\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">HaveSpan:</span><br><span class=\"line\">\t<span class=\"comment\">// Mark span in use.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.state != mSpanFree &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"candidate mspan for allocation is not free\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.npages &lt; npage &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"candidate mspan for allocation is too small\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmemstats.heap_released -= <span class=\"keyword\">uint64</span>(s.released())</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 拿到的页数多于申请的，分割剩余的页数到另一个 span 并放入 free 链表</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.npages &gt; npage &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Trim extra and put it back in the heap.</span></span><br><span class=\"line\">\t\tt := (*mspan)(h.spanalloc.alloc())</span><br><span class=\"line\">\t\tt.init(s.base()+npage&lt;&lt;_PageShift, s.npages-npage)</span><br><span class=\"line\">\t\ts.npages = npage</span><br><span class=\"line\">\t\th.setSpan(t.base()<span class=\"number\">-1</span>, s)</span><br><span class=\"line\">\t\th.setSpan(t.base(), t)</span><br><span class=\"line\">\t\th.setSpan(t.base()+t.npages*pageSize<span class=\"number\">-1</span>, t)</span><br><span class=\"line\">\t\tt.needzero = s.needzero</span><br><span class=\"line\">\t\t<span class=\"comment\">// If s was scavenged, then t may be scavenged.</span></span><br><span class=\"line\">\t\tstart, end := t.physPageBounds()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.scavenged &amp;&amp; start &lt; end &#123;</span><br><span class=\"line\">\t\t\tmemstats.heap_released += <span class=\"keyword\">uint64</span>(end - start)</span><br><span class=\"line\">\t\t\tt.scavenged = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ts.state = mSpanManual <span class=\"comment\">// prevent coalescing with s</span></span><br><span class=\"line\">\t\tt.state = mSpanManual</span><br><span class=\"line\">\t\th.freeSpanLocked(t, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, s.unusedsince)</span><br><span class=\"line\">\t\ts.state = mSpanFree</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.scavenged &#123;</span><br><span class=\"line\">\t\tsysUsed(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)</span><br><span class=\"line\">\t\ts.scavenged = <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts.unusedsince = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置 span 位置</span></span><br><span class=\"line\">\th.setSpans(s.base(), npage, s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t*stat += <span class=\"keyword\">uint64</span>(npage &lt;&lt; _PageShift)</span><br><span class=\"line\">\tmemstats.heap_idle -= <span class=\"keyword\">uint64</span>(npage &lt;&lt; _PageShift)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s.inList() &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"still in list\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><p>堆上的内存分配调用了 runtime 包里的 newobject 函数，此函数调用了 mallocgc 函数，Go 语言在分配内存时，会根据对象的大小将对象分成三类：</p>\n<ul>\n<li>大对象，大于 32K，在 mheap 上分配</li>\n<li>微对象，小于 16B 且不是指针，使用 mcache 的 tiny 分配</li>\n<li>小对象，使用 mcache 对应的规格大小的 mspan 分配</li>\n</ul>\n<h4 id=\"小对象\"><a href=\"#小对象\" class=\"headerlink\" title=\"小对象\"></a>小对象</h4><p>小对象的分配流程大致如下：</p>\n<ol>\n<li>根据对象大小确定 size class 和 span class</li>\n<li>尝试从 mcache 找到可用空间，有的话直接分配</li>\n<li>若没有向 mcentral 申请一个 mspan</li>\n<li>若 mcentral 也没有，向 mheap 申请</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mallocgc</span><span class=\"params\">(size <span class=\"keyword\">uintptr</span>, typ *_type, needzero <span class=\"keyword\">bool</span>)</span> <span class=\"title\">unsafe</span>.<span class=\"title\">Pointer</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 省略部分代码 </span></span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt;= maxSmallSize &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 微对象分配</span></span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> sizeclass <span class=\"keyword\">uint8</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 根据对象的大小找到合适的 sizeClass</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> size &lt;= smallSizeMax<span class=\"number\">-8</span> &#123;</span><br><span class=\"line\">\t\t\t\tsizeclass = size_to_class8[(size+smallSizeDiv<span class=\"number\">-1</span>)/smallSizeDiv]</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tsizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class=\"number\">-1</span>)/largeSizeDiv]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 根据 sizeClass 找到 spanClass</span></span><br><span class=\"line\">\t\t\tsize = <span class=\"keyword\">uintptr</span>(class_to_size[sizeclass])</span><br><span class=\"line\">\t\t\tspc := makeSpanClass(sizeclass, noscan)</span><br><span class=\"line\">      <span class=\"comment\">// 从 mcache 拿到 mspan</span></span><br><span class=\"line\">\t\t\tspan := c.alloc[spc]</span><br><span class=\"line\">      <span class=\"comment\">// 利用 mspan.allocCache 尝试快速找到可用空间</span></span><br><span class=\"line\">\t\t\tv := nextFreeFast(span)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> v == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从整个 mspan 中查找可用空间，如果没有，向 mcentral 要一个新的 mspan</span></span><br><span class=\"line\">\t\t\t\tv, span, shouldhelpgc = c.nextFree(spc)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tx = unsafe.Pointer(v)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> needzero &amp;&amp; span.needzero != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tmemclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 大对象分配</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//... 后续处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">nextFreeFast</span><span class=\"params\">(s *mspan)</span> <span class=\"title\">gclinkptr</span></span> &#123;</span><br><span class=\"line\">\ttheBit := sys.Ctz64(s.allocCache) <span class=\"comment\">// Is there a free object in the allocCache?</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> theBit &lt; <span class=\"number\">64</span> &#123;</span><br><span class=\"line\">\t\tresult := s.freeindex + <span class=\"keyword\">uintptr</span>(theBit)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> result &lt; s.nelems &#123;</span><br><span class=\"line\">\t\t\tfreeidx := result + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> freeidx%<span class=\"number\">64</span> == <span class=\"number\">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ts.allocCache &gt;&gt;= <span class=\"keyword\">uint</span>(theBit + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ts.freeindex = freeidx</span><br><span class=\"line\">\t\t\ts.allocCount++</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> gclinkptr(result*s.elemsize + s.base())</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *mcache)</span> <span class=\"title\">nextFree</span><span class=\"params\">(spc spanClass)</span> <span class=\"params\">(v gclinkptr, s *mspan, shouldhelpgc <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\ts = c.alloc[spc]</span><br><span class=\"line\">\tshouldhelpgc = <span class=\"literal\">false</span></span><br><span class=\"line\">\tfreeIndex := s.nextFreeIndex()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> freeIndex == s.nelems &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// mspan 已满</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">println</span>(<span class=\"string\">\"runtime: s.allocCount=\"</span>, s.allocCount, <span class=\"string\">\"s.nelems=\"</span>, s.nelems)</span><br><span class=\"line\">\t\t\tthrow(<span class=\"string\">\"s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems\"</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tc.refill(spc) <span class=\"comment\">// 向 mcentral 申请一个新的替换旧的</span></span><br><span class=\"line\">\t\tshouldhelpgc = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\ts = c.alloc[spc]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfreeIndex = s.nextFreeIndex()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> freeIndex &gt;= s.nelems &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"freeIndex is not valid\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tv = gclinkptr(freeIndex*s.elemsize + s.base())</span><br><span class=\"line\">\ts.allocCount++</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"keyword\">uintptr</span>(s.allocCount) &gt; s.nelems &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">println</span>(<span class=\"string\">\"s.allocCount=\"</span>, s.allocCount, <span class=\"string\">\"s.nelems=\"</span>, s.nelems)</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"s.allocCount &gt; s.nelems\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"微对象\"><a href=\"#微对象\" class=\"headerlink\" title=\"微对象\"></a>微对象</h4><p>微对象的分配流程大致如下：</p>\n<ol>\n<li>将对象的大小对齐在 2、4、8 字节上</li>\n<li>如果 mcache 有 tiny block 并且有合适的空间，直接分配</li>\n<li>如果没有，在 mcache 里寻找其他 mspan</li>\n<li>若没有，向 mcentral 申请</li>\n<li>也没有，向 mheap 申请</li>\n<li>调整 mcache 的 tiny block 和 tinyoffset</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mallocgc</span><span class=\"params\">(size <span class=\"keyword\">uintptr</span>, typ *_type, needzero <span class=\"keyword\">bool</span>)</span> <span class=\"title\">unsafe</span>.<span class=\"title\">Pointer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt;= maxSmallSize &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t\toff := c.tinyoffset</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 根据要分配的对象对齐字节</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> size&amp;<span class=\"number\">7</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\toff = round(off, <span class=\"number\">8</span>)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> size&amp;<span class=\"number\">3</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\toff = round(off, <span class=\"number\">4</span>)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> size&amp;<span class=\"number\">1</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\toff = round(off, <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">      <span class=\"comment\">// 检查 mcache 有没有 tiny block</span></span><br><span class=\"line\">      <span class=\"comment\">// 有且有空间，直接分配，调整 tinyoffset</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tx = unsafe.Pointer(c.tiny + off)</span><br><span class=\"line\">\t\t\t\tc.tinyoffset = off + size</span><br><span class=\"line\">\t\t\t\tc.local_tinyallocs++</span><br><span class=\"line\">\t\t\t\tmp.mallocing = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\treleasem(mp)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 下面一段和普通对象分配流程一样</span></span><br><span class=\"line\">\t\t\tspan := c.alloc[tinySpanClass]</span><br><span class=\"line\">\t\t\tv := nextFreeFast(span)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> v == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tv, _, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tx = unsafe.Pointer(v)</span><br><span class=\"line\">\t\t\t(*[<span class=\"number\">2</span>]<span class=\"keyword\">uint64</span>)(x)[<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t(*[<span class=\"number\">2</span>]<span class=\"keyword\">uint64</span>)(x)[<span class=\"number\">1</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 更新 mcache 的 tiny 和 tinyoffset 字段</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> size &lt; c.tinyoffset || c.tiny == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tc.tiny = <span class=\"keyword\">uintptr</span>(x)</span><br><span class=\"line\">\t\t\t\tc.tinyoffset = size</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tsize = maxTinySize</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 小对象分配</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 大对象分配</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 后续处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"大对象\"><a href=\"#大对象\" class=\"headerlink\" title=\"大对象\"></a>大对象</h4><p>大对象分配流程相对简单，跳过了 mcache 和 mcentral 阶段直接通过 mheap 分配</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mallocgc</span><span class=\"params\">(size <span class=\"keyword\">uintptr</span>, typ *_type, needzero <span class=\"keyword\">bool</span>)</span> <span class=\"title\">unsafe</span>.<span class=\"title\">Pointer</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt;= maxSmallSize &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 微对象分配</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 小对象分配</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 大对象分配</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> s *mspan</span><br><span class=\"line\">\t\tshouldhelpgc = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\tsystemstack(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\ts = largeAlloc(size, needzero, noscan)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\ts.freeindex = <span class=\"number\">1</span></span><br><span class=\"line\">\t\ts.allocCount = <span class=\"number\">1</span></span><br><span class=\"line\">\t\tx = unsafe.Pointer(s.base())</span><br><span class=\"line\">\t\tsize = s.elemsize</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 后续处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">largeAlloc</span><span class=\"params\">(size <span class=\"keyword\">uintptr</span>, needzero <span class=\"keyword\">bool</span>, noscan <span class=\"keyword\">bool</span>)</span> *<span class=\"title\">mspan</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size+_PageSize &lt; size &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"out of memory\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnpages := size &gt;&gt; _PageShift</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size&amp;_PageMask != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tnpages++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdeductSweepCredit(npages*_PageSize, npages)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 通过 mheap 进行分配</span></span><br><span class=\"line\">\ts := mheap_.alloc(npages, makeSpanClass(<span class=\"number\">0</span>, noscan), <span class=\"literal\">true</span>, needzero)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tthrow(<span class=\"string\">\"out of memory\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts.limit = s.base() + size</span><br><span class=\"line\">\theapBitsForAddr(s.base()).initSpan(s)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Golang 的内存分配是个相当复杂的过程，并且里面还掺杂了 GC 的处理，这里仅对一些关键性的数据结构及流程进行了梳理说明，这在整个 Golang 内存分配策略的多样性里只是冰山一角。</p>\n<ul>\n<li>程序在启动时申请了一块内存，之后自行管理</li>\n<li>mspan 是内存分配的基本单元，由若干个页组成，每个 mspan 分配特定大小的对象</li>\n<li>mcache、mcentral、mheap 内存管理三大组件，层层递进</li>\n<li>分配对象时根据大小分为三类，使用对应的分配器分配内存，节省资源</li>\n</ul>\n","categories":[],"tags":["Golang"]},{"title":"当我们使用 Helm 时，可能需要考虑一些安全问题","url":"http://localhost:4000/2018/12/19/helm-security/","content":"<p>使用默认的安装命令 helm init 可以快速安装 Tiller，但是默认的安装方式没有任何安全性的配置。</p>\n<p>默认的安装方式将 Tiller 安装在 kube-system 下，并赋予它 cluster-admin 的权限，可以操作集群中任意资源。</p>\n<h2 id=\"RBAC\"><a href=\"#RBAC\" class=\"headerlink\" title=\"RBAC\"></a>RBAC</h2><p>在安装 Tiller 时，可以指定其使用的 ServiceAccount 进行 RBAC 授权。</p>\n<p>但是有个问题是，Tiller 操作集群资源都是使用其自身凭证和权限执行，并不考虑 Helm 客户端的权限。</p>\n<p>也就说 kubectl 只要能连接集群并且只需要有 pods 和 portforward 权限，那么 Helm 就可以通过 kubectl 连接到 Tiller，进而使用 Tiller 的权限操作集群资源。</p>\n<p>如果我们需要用户可以使用 Helm，但是仍要限制对集群的操作，该怎么做？目前的方法对不同的用户群组创建的不同的 ServiceAccount，使用不同的 RBAC 策略，绑定到对应的 TIller 实例上，通过控制用户访问哪个 Tiller 来确保操作。这样带来的问题也很明显，集群里有多个 Tiller 实例难以管理。</p>\n<p>社区也在考虑将 RBAC 权限控制从 Tiller 服务端移到 Helm 客户端，每个操作都是由用户请求的，而不是 TIller。</p>\n<h2 id=\"GRPC-Endpoint\"><a href=\"#GRPC-Endpoint\" class=\"headerlink\" title=\"GRPC Endpoint\"></a>GRPC Endpoint</h2><p>helm 客户端通过 GRPC 和 Tiller 通信，Tiller 提供的 GRPC 端口在集群内部无需通过身份验证即可访问，这意味着集群内的任意 Pod 都可以使用此端口连接 Tiller 进而操作集群资源，创建 ClusterRole 授予任意 Pod 升级权限等等，GMAE OVER 😭。</p>\n<p>在集群外访问时 Helm 需要通过 API Server 进行身份验证，才可以访问 Tiller。</p>\n<p>有两种方式保护 Tiller 端口</p>\n<ul>\n<li>开启 TLS</li>\n<li>本地运行 Tiller，Helm 客户端通过 port forward 连接不受影响</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://docs.helm.sh/using_helm/#securing-your-helm-installation\" target=\"_blank\" rel=\"noopener\">Helm Docs</a></li>\n<li><a href=\"https://engineering.bitnami.com/articles/helm-security.html\" target=\"_blank\" rel=\"noopener\">Bitnami Engineering Portal: Exploring the Security of Helm</a></li>\n</ul>\n","categories":[],"tags":["Kubernetes","Helm"]},{"title":"访问 Kubernetes API - Admission Control（三）","url":"http://localhost:4000/2018/12/18/k8s-admission/","content":"<p>准入控制器是运行在 Authention 和 Authoriztion 之后，对象持久化之前，拦截 API Server 的请求对请求资源进行修改或者验证的一组插件列表，必须在 API Server 启动时配置。</p>\n<p>在 1.10+ 版本，修改资源的控制器优先执行，然后执行验证控制器。任意控制器拒绝请求，则立即拒绝整个请求，并向用户返回错误。</p>\n<h2 id=\"控制器列表\"><a href=\"#控制器列表\" class=\"headerlink\" title=\"控制器列表\"></a>控制器列表</h2><h3 id=\"AlwaysPullImages\"><a href=\"#AlwaysPullImages\" class=\"headerlink\" title=\"AlwaysPullImages\"></a>AlwaysPullImages</h3><p>强制修改每个 Pod 拉取镜像的策略为 Always，主要用于多用户集群中，他们的私有镜像只能被拥有凭证的人使用。没有这个控制器，一旦镜像被拉去到节点上，任何 Pod 都可以通过镜像名称（同一个节点）来使用它，而不需要对镜像进行授权检查。</p>\n<h3 id=\"DefaultStorageClass\"><a href=\"#DefaultStorageClass\" class=\"headerlink\" title=\"DefaultStorageClass\"></a>DefaultStorageClass</h3><p>控制器监视 PersistentVolumeClaim 的创建，如果没有指定 storage class，就会向他们添加默认的 storage class。当没有配置默认的 storage class，控制器不会执行任何操作，当有一个以上的 storage class 别标记为默认时，控制器会拒绝请求，返回一个错误。</p>\n<h3 id=\"DefaultTolerationSeconds\"><a href=\"#DefaultTolerationSeconds\" class=\"headerlink\" title=\"DefaultTolerationSeconds\"></a>DefaultTolerationSeconds</h3><p>设置 Pod 默认的容忍时间为5分钟，<code>notready:NoExecute</code>  和 <code>unreachable:NoExecute</code></p>\n<h3 id=\"DenyEscalatingExec\"><a href=\"#DenyEscalatingExec\" class=\"headerlink\" title=\"DenyEscalatingExec\"></a>DenyEscalatingExec</h3><h3 id=\"EventRateLimit-alpha\"><a href=\"#EventRateLimit-alpha\" class=\"headerlink\" title=\"EventRateLimit (alpha)\"></a>EventRateLimit (alpha)</h3><p>限制 API Server 在设定时间片接受 event 请求的数量。因为集群中可能会有始终处于某种错误状态的 Pod，kubelet 或者 controllers 会重复不断的发出 event 请求，可能会影响到整个集群。</p>\n<h3 id=\"ExtendedResourceToleration\"><a href=\"#ExtendedResourceToleration\" class=\"headerlink\" title=\"ExtendedResourceToleration\"></a>ExtendedResourceToleration</h3><h3 id=\"ImagePolicyWebhook\"><a href=\"#ImagePolicyWebhook\" class=\"headerlink\" title=\"ImagePolicyWebhook\"></a>ImagePolicyWebhook</h3><p>控制器允许使用 webhook 来判断镜像拉取策略</p>\n<h3 id=\"LimitPodHardAntiAffinityTopology\"><a href=\"#LimitPodHardAntiAffinityTopology\" class=\"headerlink\" title=\"LimitPodHardAntiAffinityTopology\"></a>LimitPodHardAntiAffinityTopology</h3><p>Pod Affinity 相关</p>\n<h3 id=\"LimitRanger\"><a href=\"#LimitRanger\" class=\"headerlink\" title=\"LimitRanger\"></a>LimitRanger</h3><p>控制器确保请求的资源不会违反 Namespace 中 LimitRange 的约束。还可以将默认的资源请求和限制设置到未指定的 Pod 上。</p>\n<h3 id=\"NamespaceAutoProvision\"><a href=\"#NamespaceAutoProvision\" class=\"headerlink\" title=\"NamespaceAutoProvision\"></a>NamespaceAutoProvision</h3><p>检查请求资源所属 Namespace 是否存在，如果不存在则创建一个。</p>\n<h3 id=\"NamespaceExists\"><a href=\"#NamespaceExists\" class=\"headerlink\" title=\"NamespaceExists\"></a>NamespaceExists</h3><p>检查除 Namespace 自身外资源请求的命名空间，如果不存在，拒绝请求。</p>\n<h3 id=\"NamespaceLifecycle\"><a href=\"#NamespaceLifecycle\" class=\"headerlink\" title=\"NamespaceLifecycle\"></a>NamespaceLifecycle</h3><p>这个插件强制不能在一个正在被终止的 Namespace 中创建新对象，和确保使用不存在 Namespace 的请求被拒绝。删除 Namespace 触发了在该命名空间中删除所有对象（ pod 、 services 等）的一系列操作。</p>\n<h3 id=\"NodeRestriction\"><a href=\"#NodeRestriction\" class=\"headerlink\" title=\"NodeRestriction\"></a>NodeRestriction</h3><p>控制器限制了 kubelet 可以修改的 Node 和 Pod 对象，只允许修改自己的 Node 资源及绑定到节点本身的 Pod 资源。</p>\n<h3 id=\"OwnerReferencesPermissionEnforcement\"><a href=\"#OwnerReferencesPermissionEnforcement\" class=\"headerlink\" title=\"OwnerReferencesPermissionEnforcement\"></a>OwnerReferencesPermissionEnforcement</h3><p>控制器保护对 metadata.ownerReferences 对象的访问，只有具有删除权限的用户才能对其更改。</p>\n<h3 id=\"PodNodeSelector\"><a href=\"#PodNodeSelector\" class=\"headerlink\" title=\"PodNodeSelector\"></a>PodNodeSelector</h3><p>使用 Namespace 的一个注解 <code>scheduler.alpha.kubernetes.io/node-selector</code>  ，在其中查找标签选择器将其添加至 Pod 中，这功能限制了某个 Namespace 的 Pod，只能运行在指定的节点上。</p>\n<h3 id=\"PodPreset\"><a href=\"#PodPreset\" class=\"headerlink\" title=\"PodPreset\"></a>PodPreset</h3><p>允许控制器向一个 Pod 注入匹配的 PodPreset 中指定的字段。</p>\n<h3 id=\"PodSecurityPolicy\"><a href=\"#PodSecurityPolicy\" class=\"headerlink\" title=\"PodSecurityPolicy\"></a>PodSecurityPolicy</h3><p>控制器在创建和修改 Pod 时，根据请求的安全上下文和可用的 Pod 安全策略来确定是否应该通过请求。</p>\n<h3 id=\"PodTolerationRestriction\"><a href=\"#PodTolerationRestriction\" class=\"headerlink\" title=\"PodTolerationRestriction\"></a>PodTolerationRestriction</h3><p>控制器首先验证 Pod 的容忍和 Namespace 的容忍是否冲突，如果冲突拒绝请求，然后合并容忍度，在根据 Namespace 容忍白名单验证，成功通过请求，失败拒绝请求。</p>\n<h3 id=\"Priority\"><a href=\"#Priority\" class=\"headerlink\" title=\"Priority\"></a>Priority</h3><p>控制器使用 priorityClassName 字段查找 priority class 设置 Pod 优先级，如果 priority class 不存在，拒绝请求。</p>\n<h3 id=\"ResourceQuota\"><a href=\"#ResourceQuota\" class=\"headerlink\" title=\"ResourceQuota\"></a>ResourceQuota</h3><p>控制器观察进入请求，确保它不违反任何一个 Namespace 中的 ResourceQuota 对象约束。</p>\n<h3 id=\"SecurityContextDeny\"><a href=\"#SecurityContextDeny\" class=\"headerlink\" title=\"SecurityContextDeny\"></a>SecurityContextDeny</h3><p>控制器拒绝任何试图设置某些升级的 SecurityContext 字段的 Pod。</p>\n<h3 id=\"ServiceAccount\"><a href=\"#ServiceAccount\" class=\"headerlink\" title=\"ServiceAccount\"></a>ServiceAccount</h3><p>控制器实现了 ServiceAccount 的自动化。</p>\n<ol>\n<li>如果 Pod 未设置 ServiceAccount，则会将其设置为 default。</li>\n<li>确保 Pod 引用的 ServiceAccount 存在，否则拒绝请求。</li>\n<li>如果 Pod 不包含 ImagePullSecrets，那么 ServiceAccount 的 ImagePullSecrets 将被设置到 Pod 上。</li>\n<li>向 Pod 添加一个 volume，包含用于访问 API 的 token。</li>\n<li>将 volumeSource 挂载到每个容器的 /var/run/secrets/kubernetes.io/serviceaccount 下 </li>\n</ol>\n<h3 id=\"StorageObjectInUseProtection\"><a href=\"#StorageObjectInUseProtection\" class=\"headerlink\" title=\"StorageObjectInUseProtection\"></a>StorageObjectInUseProtection</h3><p>控制器将 kubernetes.io/pvc-protection 或 kubernetes.io/pv-protection 终结器添加到新创建的持久卷声明（PVC）或持久卷（PV）。在用户删除PVC或PV的情况下，PVC或PV不会被移除，直到PVC或PV保护控制器从PVC或PV中移除终结器。</p>\n<h3 id=\"PersistentVolumeClaimResize\"><a href=\"#PersistentVolumeClaimResize\" class=\"headerlink\" title=\"PersistentVolumeClaimResize\"></a>PersistentVolumeClaimResize</h3><p>当调整 PersistentVolumeClaim 大小时，控制器将进行额外的验证。</p>\n<h2 id=\"动态准入控制\"><a href=\"#动态准入控制\" class=\"headerlink\" title=\"动态准入控制\"></a>动态准入控制</h2><p>上面的控制器都需要编译到 API Server 中才可以使用，而且只能在启动时配置。Webhooks 和 Initializers 允许用户动态设置准入控制器。</p>\n<h3 id=\"Admission-Webhooks-beta-in-1-9\"><a href=\"#Admission-Webhooks-beta-in-1-9\" class=\"headerlink\" title=\"Admission Webhooks (beta in 1.9)\"></a>Admission Webhooks (beta in 1.9)</h3><p>一个 HTTP 的回调，接受准入请求并处理验证数据，有两种类型</p>\n<ul>\n<li>MutatingAdmissionWebhook </li>\n<li>ValidatingAdmissionWebhook</li>\n</ul>\n<p>istio 就是使用 ValidatingAdmissionWebhook 机制来验证授权用户，使用 MutatingAdmissionWebhook 注入 sidecar</p>\n<h3 id=\"Initializers\"><a href=\"#Initializers\" class=\"headerlink\" title=\"Initializers\"></a>Initializers</h3><p>也是一种动态准入控制，未深入研究</p>\n","categories":[],"tags":["Kubernetes"]},{"title":"Golang 源码阅读 - 函数调用","url":"http://localhost:4000/2018/12/10/go-func/","content":"<p>函数调用是大多数编程语言中的最重要的部分，理解和掌握函数的整个调用过程是深入学习一门语言必不可少的步骤。</p>\n<p>开始前，先介绍几个概念</p>\n<ol>\n<li>每个进程有一个栈（stack），在这个进程中每个函数被调用时分别从这个栈占用一段区域，称为帧（frame）。</li>\n<li>大多数架构中，stack 向着低地址内存增长，即栈顶对应低地址，栈底对应高地址。</li>\n<li>sp 寄存器存储的地址始终指向栈顶，许多CPU指令会自动更新 sp 的数据。</li>\n<li>bp 寄存器存储地址指向正在执行函数栈帧的栈底位置，为访问局部变量和参数提供稳定的参考点。bp 仅在函数调用的开始和结束时更改，因此我们可以轻松通过函数内部数据与距 bp 的偏移量进行寻址。和 sp 不同，bp主要由程序代码维护。</li>\n<li>习惯使用 ax 寄存器将函数返回值传送给调用方。</li>\n</ol>\n<p>让我来来看个简单的 C 程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result = a + b;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> answer;</span><br><span class=\"line\">  answer = add(<span class=\"number\">40</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>gcc -S main.c</code> 将当前文件编译成汇编语言</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.section\t__TEXT,__text,regular,pure_instructions</span><br><span class=\"line\">\t.build_version macos, 10, 14</span><br><span class=\"line\">\t.globl\t_add                    ## -- Begin function add</span><br><span class=\"line\">\t.p2align\t4, 0x90</span><br><span class=\"line\">_add:                                   ## @add</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">## %bb.0:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset %rbp, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register %rbp</span><br><span class=\"line\">\tmovl\t%edi, -4(%rbp)             # 7.从 di 获取第一个参数</span><br><span class=\"line\">\tmovl\t%esi, -8(%rbp)             # 8.从 si 获取第二个参数</span><br><span class=\"line\">\tmovl\t-4(%rbp), %esi</span><br><span class=\"line\">\taddl\t-8(%rbp), %esi             # 9.相加</span><br><span class=\"line\">\tmovl\t%esi, -12(%rbp)</span><br><span class=\"line\">\tmovl\t-12(%rbp), %eax            # 10.将结果存放在 ax 寄存器</span><br><span class=\"line\">\tpopq\t%rbp                       # 11.从栈中恢复之前保存的 bp 值</span><br><span class=\"line\">\tretq                             # 12.从栈取得返回地址，并跳转到该位置</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">                                        ## -- End function</span><br><span class=\"line\">\t.globl\t_main                   ## -- Begin function main</span><br><span class=\"line\">\t.p2align\t4, 0x90</span><br><span class=\"line\">_main:                                  ## @main</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">## %bb.0:</span><br><span class=\"line\">\tpushq\t%rbp                       # 1.将当前 bp 寄存器的值压入栈中</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset %rbp, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp                 # 2.将 sp 值复制给 bp</span><br><span class=\"line\">\t.cfi_def_cfa_register %rbp</span><br><span class=\"line\">\tsubq\t$16, %rsp                  # 3.在栈上分配16字节空间</span><br><span class=\"line\">\tmovl\t$40, %edi                  # 4.将第一个参数存到 di 寄存器</span><br><span class=\"line\">\tmovl\t$2, %esi                   # 5.将第二个参数存到 si 寄存器</span><br><span class=\"line\">\tcallq\t_add                       # 6.返回地址压入栈中，跳转至 add 并开始执行</span><br><span class=\"line\">\txorl\t%esi, %esi                 # 13.清零 si 寄存器</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)             # 14.将 ax 寄存器值（返回值）传送到栈上</span><br><span class=\"line\">\tmovl\t%esi, %eax                 # 15.清零 ax 寄存器</span><br><span class=\"line\">\taddq\t$16, %rsp</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tretq</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">                                        ## -- End function</span><br><span class=\"line\"></span><br><span class=\"line\">.subsections_via_symbols</span><br></pre></td></tr></table></figure>\n<p>步骤1，2，3 基本上所有函数都是这样开始，bp 的当前值保存到栈的顶部，然后 sp 值复制给 bp 建立新的栈帧。在上面的注释中可以看到， C 语言中参数的传递通过寄存器 di，si 传递，返回值通过 ax 寄存器传递。</p>\n<p>如果我们将参数增加的 6 个以上，生成的汇编会出现一些变化，主要在参数传递方面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_main:                                  ## @main</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">## %bb.0:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset 16</span><br><span class=\"line\">\t.cfi_offset %rbp, -16</span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register %rbp</span><br><span class=\"line\">\tsubq\t$16, %rsp</span><br><span class=\"line\">\tmovl\t$1, %edi</span><br><span class=\"line\">\tmovl\t$2, %esi</span><br><span class=\"line\">\tmovl\t$3, %edx</span><br><span class=\"line\">\tmovl\t$4, %ecx</span><br><span class=\"line\">\tmovl\t$5, %r8d</span><br><span class=\"line\">\tmovl\t$6, %r9d</span><br><span class=\"line\">\tmovl\t$7, %eax                </span><br><span class=\"line\">\tmovl\t$7, (%rsp)</span><br><span class=\"line\">\tmovl\t%eax, -8(%rbp)          ## 4-byte Spill</span><br><span class=\"line\">\tcallq\t_add</span><br><span class=\"line\">\txorl\t%ecx, %ecx</span><br><span class=\"line\">\tmovl\t%eax, -4(%rbp)</span><br><span class=\"line\">\tmovl\t%ecx, %eax</span><br><span class=\"line\">\taddq\t$16, %rsp</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tretq</span><br></pre></td></tr></table></figure>\n<p>从上我们可以看到前6个参数还是通过寄存器传递，第7个参数开始通过栈进行传递。总结一下就是，在 x86_64 的机器上使用 C 语言调用函数，参数是通过寄存器和栈进行传递（6个以下通过寄存器，之上通过栈），返回值通过 ax 寄存器传递，这也就是为什么 C 语言只支持一个返回值。</p>\n<p>看完 C 语言的函数调用，我们来看看 Golang 的做法有何不同</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(a, b <span class=\"keyword\">int</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a + b, a - b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tadd(<span class=\"number\">40</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>GOOS=linux GOARCH=amd64 go tool compile -S -N -l main.go</code> 得到 Plan9 汇编代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;&quot;.add STEXT nosplit size=49 args=0x20 locals=0x0</span><br><span class=\"line\">        0x0000 00000 (main.go:3)        TEXT    &quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-32</span><br><span class=\"line\">        0x0000 00000 (main.go:3)        FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class=\"line\">        0x0000 00000 (main.go:3)        FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class=\"line\">        0x0000 00000 (main.go:3)        FUNCDATA        $3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class=\"line\">        0x0000 00000 (main.go:3)        PCDATA  $2, $0</span><br><span class=\"line\">        0x0000 00000 (main.go:3)        PCDATA  $0, $0</span><br><span class=\"line\">        0x0000 00000 (main.go:3)        MOVQ    $0, &quot;&quot;.~r2+24(SP)  # 4.初始化第一个返回值</span><br><span class=\"line\">        0x0009 00009 (main.go:3)        MOVQ    $0, &quot;&quot;.~r3+32(SP)  # 5.初始化第二个返回值</span><br><span class=\"line\">        0x0012 00018 (main.go:4)        MOVQ    &quot;&quot;.a+8(SP), AX     # 6.第一个参数至 AX</span><br><span class=\"line\">        0x0017 00023 (main.go:4)        ADDQ    &quot;&quot;.b+16(SP), AX    # 7.和第二个参数相加</span><br><span class=\"line\">        0x001c 00028 (main.go:4)        MOVQ    AX, &quot;&quot;.~r2+24(SP)  # 8.将 AX 值放入第一个返回值</span><br><span class=\"line\">        0x0021 00033 (main.go:4)        MOVQ    &quot;&quot;.a+8(SP), AX     </span><br><span class=\"line\">        0x0026 00038 (main.go:4)        SUBQ    &quot;&quot;.b+16(SP), AX    # 9.相减</span><br><span class=\"line\">        0x002b 00043 (main.go:4)        MOVQ    AX, &quot;&quot;.~r3+32(SP)  # 10.放入第二个返回值</span><br><span class=\"line\">        0x0030 00048 (main.go:4)        RET</span><br><span class=\"line\">        0x0000 48 c7 44 24 18 00 00 00 00 48 c7 44 24 20 00 00  H.D$.....H.D$ ..</span><br><span class=\"line\">        0x0010 00 00 48 8b 44 24 08 48 03 44 24 10 48 89 44 24  ..H.D$.H.D$.H.D$</span><br><span class=\"line\">        0x0020 18 48 8b 44 24 08 48 2b 44 24 10 48 89 44 24 20  .H.D$.H+D$.H.D$ </span><br><span class=\"line\">        0x0030 c3                                               .</span><br><span class=\"line\">&quot;&quot;.main STEXT size=68 args=0x0 locals=0x28</span><br><span class=\"line\">        0x0000 00000 (main.go:7)        TEXT    &quot;&quot;.main(SB), ABIInternal, $40-0</span><br><span class=\"line\">        0x0000 00000 (main.go:7)        MOVQ    (TLS), CX</span><br><span class=\"line\">        0x0009 00009 (main.go:7)        CMPQ    SP, 16(CX)</span><br><span class=\"line\">        0x000d 00013 (main.go:7)        JLS     61</span><br><span class=\"line\">        0x000f 00015 (main.go:7)        SUBQ    $40, SP            # 1.对 SP 做减法，为函数分配栈帧</span><br><span class=\"line\">        0x0013 00019 (main.go:7)        MOVQ    BP, 32(SP)         # 2.将当前 BP 值压入栈中</span><br><span class=\"line\">        0x0018 00024 (main.go:7)        LEAQ    32(SP), BP         # 3.设置新的 BP 值</span><br><span class=\"line\">        0x001d 00029 (main.go:7)        FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class=\"line\">        0x001d 00029 (main.go:7)        FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class=\"line\">        0x001d 00029 (main.go:7)        FUNCDATA        $3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class=\"line\">        0x001d 00029 (main.go:8)        PCDATA  $2, $0</span><br><span class=\"line\">        0x001d 00029 (main.go:8)        PCDATA  $0, $0</span><br><span class=\"line\">        0x001d 00029 (main.go:8)        MOVQ    $40, (SP)          # 4.设置第一个参数</span><br><span class=\"line\">        0x0025 00037 (main.go:8)        MOVQ    $30, 8(SP)         # 5.设置第二个参数</span><br><span class=\"line\">        0x002e 00046 (main.go:8)        CALL    &quot;&quot;.add(SB)         # 6.压入返回地址，并调用 add 函数</span><br><span class=\"line\">        0x0033 00051 (main.go:9)        MOVQ    32(SP), BP         # 11.恢复之前保存的 bp 值</span><br><span class=\"line\">        0x0038 00056 (main.go:9)        ADDQ    $40, SP            # 12.释放空间</span><br><span class=\"line\">        0x003c 00060 (main.go:9)        RET</span><br><span class=\"line\">        0x003d 00061 (main.go:9)        NOP</span><br><span class=\"line\">        0x003d 00061 (main.go:7)        PCDATA  $0, $-1</span><br><span class=\"line\">        0x003d 00061 (main.go:7)        PCDATA  $2, $-1</span><br><span class=\"line\">        0x003d 00061 (main.go:7)        CALL    runtime.morestack_noctxt(SB)</span><br><span class=\"line\">        0x0042 00066 (main.go:7)        JMP     0</span><br><span class=\"line\">        0x0000 64 48 8b 0c 25 00 00 00 00 48 3b 61 10 76 2e 48  dH..%....H;a.v.H</span><br><span class=\"line\">        0x0010 83 ec 28 48 89 6c 24 20 48 8d 6c 24 20 48 c7 04  ..(H.l$ H.l$ H..</span><br><span class=\"line\">        0x0020 24 28 00 00 00 48 c7 44 24 08 1e 00 00 00 e8 00  $(...H.D$.......</span><br><span class=\"line\">        0x0030 00 00 00 48 8b 6c 24 20 48 83 c4 28 c3 e8 00 00  ...H.l$ H..(....</span><br><span class=\"line\">        0x0040 00 00 eb bc                                      ....</span><br><span class=\"line\">        rel 5+4 t=16 TLS+0</span><br><span class=\"line\">        rel 47+4 t=8 &quot;&quot;.add+0</span><br><span class=\"line\">        rel 62+4 t=8 runtime.morestack_noctxt+0</span><br></pre></td></tr></table></figure>\n<p>通过对 Golang 的汇编语言分析，发现 Golang 传递和接受参数使用的都是栈，并没有像 C 语言一样使用寄存器，同时返回值也通过栈传递并由调用者预先分配内存空间，这也就是为什么 Golang 能支持多返回值的原因。但是需要注意的是，函数的入参和出参需要的内存空间都得在栈上进行分配，对比寄存器会有一定的性能损耗，但是也带来了一些好处：</p>\n<ul>\n<li>降低了实现的复杂多，寄存器数量有限，不用考虑多参数的情况</li>\n<li>兼容性好，不同的 CPU 寄存器差别比较大</li>\n<li>支持多返回值，栈上的地址相比寄存器是无限的，如果使用寄存器，也得考虑数量的问题</li>\n</ul>\n","categories":[],"tags":["Golang"]},{"title":"访问 Kubernetes API - Authorization（二）","url":"http://localhost:4000/2018/11/02/k8s-authorization/","content":"<p>经过第一步的身份认证后，请求带着认证后的用户信息来到授权模块</p>\n<h2 id=\"请求属性\"><a href=\"#请求属性\" class=\"headerlink\" title=\"请求属性\"></a>请求属性</h2><ul>\n<li>user - 认证阶段将提供的用户名</li>\n<li>group - 用户所属 group 列表</li>\n<li>extra - 扩展数据</li>\n<li>API -  是否请求 API resource，/api, /healthz 等这些属于 non-resource</li>\n<li>Request Path - 请求路径</li>\n<li>HTTP request verb - 资源请求返回 kube verb (get, list, watch 等)</li>\n<li>Resource - 资源名称，请求的 REST 对象</li>\n<li>Subresource - 子资源</li>\n<li>Namespace - 资源对象所属 namespace</li>\n<li>API group -  正在访问的 API 资源组</li>\n</ul>\n<h2 id=\"授权模块\"><a href=\"#授权模块\" class=\"headerlink\" title=\"授权模块\"></a>授权模块</h2><h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><p>特殊模块，专门用来授权由 kubelet 发出来的 API 请求，kubelet 设置请求属性，用户组为 <code>system:nodes</code> ，用户名为 <code>system:node:&lt;nodeName&gt;</code>，让 Node 授权模块识别自己的请求。</p>\n<ul>\n<li>Read - services, nodes, endpoints, pods 等</li>\n<li>Wirte - nodes,node status,pod,pod status,events</li>\n<li>Auth-related -  引导 TLS 的certificationsigningrequests 和委托认证授权 tokenreviews subjectaccessreviews 权限</li>\n</ul>\n<h3 id=\"ABAC\"><a href=\"#ABAC\" class=\"headerlink\" title=\"ABAC\"></a>ABAC</h3><p>基于属性的访问控制定义了一系列策略（用户，资源，对象等），通过组合属性向用户授权访问权限。</p>\n<p>开起 ABAC 模块，需要启动时指定两个参数 <code>--authorization-policy-file=SOME_FILENAME</code>  和 <code>--authorization-mode=ABAC</code> ，策略文件为 JSON 格式。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"apiVersion\"</span>: <span class=\"string\">\"abac.authorization.kubernetes.io/v1beta1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"kind\"</span>: <span class=\"string\">\"Policy\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"spec\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"user\"</span>: <span class=\"string\">\"alice\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"namespace\"</span>: <span class=\"string\">\"*\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"resource\"</span>: <span class=\"string\">\"*\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"apiGroup\"</span>: <span class=\"string\">\"*\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RBAC\"><a href=\"#RBAC\" class=\"headerlink\" title=\"RBAC\"></a>RBAC</h3><p>基于角色的访问控制，允许管理员动态配置权限策略。</p>\n<p>RBAC API 定义了四种顶级资源对象，Role , ClusterRole , RoleBinding , ClusterRoleBinding ，其中：</p>\n<blockquote>\n<p>Role 定义权限集合，必须在 Namespace 下，ClusterRole 类似，区别是整个集群范围内使用，没有 Namespace 的约束。<br>RoleBinding 把 Role 绑定到 Subject ,让 Subject 可以拥有 Role 定义的权限，ClusterRoleBinding 类似，只不过作用于 ClusterRole。RoleBinding 也可以绑定 ClusterRole，拥有的权限只有自己所在 Namespace 下。  </p>\n</blockquote>\n<p>Subject 可以理解为用户，分为 User Group ServiceAccount 几类。</p>\n<h4 id=\"Rules\"><a href=\"#Rules\" class=\"headerlink\" title=\"Rules\"></a>Rules</h4><ul>\n<li>apiGroups</li>\n<li>resources</li>\n<li>resourceNames </li>\n<li>verbs</li>\n</ul>\n<h4 id=\"Aggregated-ClusterRoles\"><a href=\"#Aggregated-ClusterRoles\" class=\"headerlink\" title=\"Aggregated ClusterRoles\"></a>Aggregated ClusterRoles</h4><p>ClusterRole 可以通过标签选择聚合其他 ClusterRole</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ClusterRole</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">rbac.authorization.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">monitoring</span></span><br><span class=\"line\"><span class=\"attr\">aggregationRule:</span></span><br><span class=\"line\"><span class=\"attr\">  clusterRoleSelectors:</span></span><br><span class=\"line\"><span class=\"attr\">  - matchLabels:</span></span><br><span class=\"line\">      <span class=\"string\">rbac.example.com/aggregate-to-monitoring:</span> <span class=\"string\">\"true\"</span></span><br><span class=\"line\"><span class=\"attr\">rules:</span> <span class=\"string\">[]</span> <span class=\"comment\"># Rules are automatically filled in by the controller manager.</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"WebHook\"><a href=\"#WebHook\" class=\"headerlink\" title=\"WebHook\"></a>WebHook</h3><p>通过配置文件定义外部服务器和需要此方式授权的用户，和 kubeconfig 格式相同。当授权开始后，API Server 向外部服务器 POST 一个 JSON 序列化的 SubjectAccessReview 对象，包含发出请求用户信息及正在请求的资源。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"apiVersion\"</span>: <span class=\"string\">\"authorization.k8s.io/v1beta1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"kind\"</span>: <span class=\"string\">\"SubjectAccessReview\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"spec\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"resourceAttributes\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"namespace\"</span>: <span class=\"string\">\"kittensandponies\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"verb\"</span>: <span class=\"string\">\"get\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"group\"</span>: <span class=\"string\">\"unicorn.example.org\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"resource\"</span>: <span class=\"string\">\"pods\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"user\"</span>: <span class=\"string\">\"jane\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"group\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"group1\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"group2\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>远程服务器确认授权后，填充 status 字段</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"apiVersion\"</span>: <span class=\"string\">\"authorization.k8s.io/v1beta1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"kind\"</span>: <span class=\"string\">\"SubjectAccessReview\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"status\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"allowed\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"校验授权\"><a href=\"#校验授权\" class=\"headerlink\" title=\"校验授权\"></a>校验授权</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> kubectl auth can-i create deployments --namespace dev</span><br><span class=\"line\">yes</span><br><span class=\"line\"><span class=\"meta\">$</span> kubectl auth can-i create deployments --namespace prod</span><br><span class=\"line\">no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 管理员可以模拟用户验证权限</span><br><span class=\"line\"><span class=\"meta\">$</span> kubectl auth can-i list secrets --namespace dev --as dave</span><br><span class=\"line\">no</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过-Pod-创建升级权限\"><a href=\"#通过-Pod-创建升级权限\" class=\"headerlink\" title=\"通过 Pod 创建升级权限\"></a>通过 Pod 创建升级权限</h2><p>有创建 Pod 权限的用户可以通过 volume 读取 namespace 下所有的 secret，configmap，并模拟 servcieAccount 执行任何操作，所以管理员在授予 Pod 创建权限时需要小心。</p>\n","categories":[],"tags":["Kubernetes"]},{"title":"访问 Kubernetes API - Authentication（一）","url":"http://localhost:4000/2018/10/15/k8s-authentication/","content":"<p>以下两种用户类型都可以合法访问 API </p>\n<ul>\n<li>Normal User</li>\n<li>ServiceAccount managed by kubernetes</li>\n</ul>\n<p>普通用户由外部服务管理，集群管理员给他们分发 private keys，用户名密码等，kubernetes 不管理普通用户。</p>\n<p>相反，service account 被集群管理，绑定在指定的 namespace 下，与一个存储证书的 secret 关联，secret 可用于 pod 直接访问 API 。</p>\n<p>当请求到达 API 后，会经历三个阶段：</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/673dbafd771491a080c02c6de3fdd41b09623c90/50100/images/docs/admin/access-control-overview.svg\" alt=\"img\"></p>\n<p>身份验证通常会检查 HTTP 请求的 headers 或者客户端证书，这个阶段可以指定多个认证模块，任意模块认证成功，请求会带着认证后的 username (User or ServiceAccount) 进入下一个阶段。</p>\n<h2 id=\"认证策略\"><a href=\"#认证策略\" class=\"headerlink\" title=\"认证策略\"></a>认证策略</h2><h3 id=\"X509-Client-Certs\"><a href=\"#X509-Client-Certs\" class=\"headerlink\" title=\"X509 Client Certs\"></a>X509 Client Certs</h3><p>如果客户端提供了证书，并通过了验证，请求将会使用证书 subject 的 common name 作为用户名，kubernetes1.4 之后，客户端证书可以指定用户组，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj \"/CN=jbeda/O=app1/O=app2\"</span><br></pre></td></tr></table></figure>\n<p>认证成功后，此次请求 username 为 jbeda，groups 为 app1,app2</p>\n<h3 id=\"Static-Token-File\"><a href=\"#Static-Token-File\" class=\"headerlink\" title=\"Static Token File\"></a>Static Token File</h3><p>API Server 读取 bearer tokens 从启动参数 <code>--token-auth-file=SOMEFILE</code>  指定 csv 文件中，文件至少包含3列数据，token，用户名，用户ID，group可选。除非重启 API Server，否则 token 列表无法更改。</p>\n<p>客户端请求时，将 token 设置在请求头中<br><code>Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269</code></p>\n<h3 id=\"Bootstrap-Tokens-alpha\"><a href=\"#Bootstrap-Tokens-alpha\" class=\"headerlink\" title=\"Bootstrap Tokens  (alpha)\"></a>Bootstrap Tokens  (alpha)</h3><p>集群可以动态管理 bearer token，主要用于将节点加入现有集群，为支持 kubeadm 构建的。</p>\n<h3 id=\"Static-Password-File\"><a href=\"#Static-Password-File\" class=\"headerlink\" title=\"Static Password File\"></a>Static Password File</h3><p>和 static token file 类似，API Server 读取 <code>--basic-auth-file=SOMEFILE</code><br>csv 文件，文件至少包含3列数据，password，user，uid，gruop。除非重启 API Server，否则配置无法更改。</p>\n<p>客户端请求时，将用户名密码设置在请求头中<br><code>Authorzation: Basic base64encoded(user:password)</code></p>\n<h3 id=\"Service-Account-Tokens\"><a href=\"#Service-Account-Tokens\" class=\"headerlink\" title=\"Service Account Tokens\"></a>Service Account Tokens</h3><p>默认启用的身份验证，用 JWT 签名的 token 来验证请求，<code>--service-account-key-file</code>  可指定用于签名的 PEM key，未指定，签名将用 API Server 的 TLS private key。</p>\n<p>创建一个 Service Account，会生成一个与之关联的 Secret，Secret 里包含集群的 ca.crt ，namespace 和签名后的 token。</p>\n<p>请求时 token 设置与 bearer token 一致，放入 Authorzation 请求头中。</p>\n<p>认证后用户名为： <code>system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)</code></p>\n<h3 id=\"OpenID-Connect-Tokens\"><a href=\"#OpenID-Connect-Tokens\" class=\"headerlink\" title=\"OpenID Connect Tokens\"></a>OpenID Connect Tokens</h3><p>OAuth2 风格的认证方式，身份提供商下发 token，要启用此功能，需要配置相关参数 <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/authentication/#configuring-the-api-server\" target=\"_blank\" rel=\"noopener\">Configuring the API Server</a></p>\n<h3 id=\"Webhook-Token-Authentication\"><a href=\"#Webhook-Token-Authentication\" class=\"headerlink\" title=\"Webhook Token Authentication\"></a>Webhook Token Authentication</h3><p>当客户端请求时，webhook token authentication 将包含 token 的 JSON 序列化的对象 TokenReview POST 到远程服务</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"apiVersion\"</span>: <span class=\"string\">\"authentication.k8s.io/v1beta1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"kind\"</span>: <span class=\"string\">\"TokenReview\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"spec\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"token\"</span>: <span class=\"string\">\"(BEARERTOKEN)\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>认证成功后返回相关数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"apiVersion\"</span>: <span class=\"string\">\"authentication.k8s.io/v1beta1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"kind\"</span>: <span class=\"string\">\"TokenReview\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"status\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"authenticated\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"user\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"username\"</span>: <span class=\"string\">\"janedoe@example.com\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"uid\"</span>: <span class=\"string\">\"42\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"groups\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"developers\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"qa\"</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"attr\">\"extra\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"extrafield1\"</span>: [</span><br><span class=\"line\">          <span class=\"string\">\"extravalue1\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"extravalue2\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Authenticating-Proxy\"><a href=\"#Authenticating-Proxy\" class=\"headerlink\" title=\"Authenticating Proxy\"></a>Authenticating Proxy</h3><p>API Server 可以设置从请求头识别用户信息，和代理认证服务组合使用</p>\n<h2 id=\"匿名请求\"><a href=\"#匿名请求\" class=\"headerlink\" title=\"匿名请求\"></a>匿名请求</h2><p>集群默认开启匿名请求，如果用户请求没有任何方式的身份认证，将被视为匿名请求，用户名 <code>system:anonymous</code> ，用户组 <code>system:unauthenticated</code>可以设置相关权限，方便用户访问。</p>\n<h2 id=\"用户模拟\"><a href=\"#用户模拟\" class=\"headerlink\" title=\"用户模拟\"></a>用户模拟</h2><p>用户可以通过模拟 headers 模拟另一个用户，模拟请求时，首先验证请求用户信息，是否有模拟权限，通过后再切换至模拟用户，例如，管理员可以用这种方式模拟用户调试权限授权。</p>\n<p>相关 headers </p>\n<ul>\n<li>Impersonate-User</li>\n<li>Impersonate-Group</li>\n<li>Impersonate-Extra-( extra name ) </li>\n</ul>\n<p>kubectl 可以使用 <code>--as=xxx --as-group=xxx</code>  模拟用户。</p>\n<p>要模拟用户必须要有模拟权限 <code>impersonate</code>。</p>\n","categories":[],"tags":["Kubernetes"]},{"title":"Google v8 源码编译","url":"http://localhost:4000/2018/09/04/v8-build/","content":"<p>想深入学习 Node.js 绕不开 v8，要学习 v8 那只能从编译它开始了。我是在 mac 环境下编译的，以下大部分命令都需要在翻墙状态下完成😣。</p>\n<ol>\n<li><p>下载工具 depot_tools</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=`pwd`/depot_tools:\"$PATH\"</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>检查并更新工具</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gclient</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找一个你要下载 v8 源码的目录进去后执行下面操作，时间会有点长</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch v8</span><br><span class=\"line\">cd v8</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确认你在 v8 源码目录中，通过下面命令下载所有构建依赖项</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gclient sync</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>仅在 Linux 环境下</strong>需要此操作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./build/install-build-deps.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成构建文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tools/dev/v8gen.py x64.release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置编译参数，我们需要嵌入 v8 ，需要生成静态库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gn args out.gn/x64.release</span><br><span class=\"line\"></span><br><span class=\"line\">将下面设置加入配置中</span><br><span class=\"line\">is_component_build = false</span><br><span class=\"line\">v8_static_library = true</span><br><span class=\"line\">use_custom_libcxx = false</span><br><span class=\"line\">use_custom_libcxx_for_host = false</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译源码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ninja -C out.gn/x64.release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译完成后，在 out.gn/x64.release 目录下查看编译产生的二进制文件及静态库</p>\n<p>我们需要下面一些文件来进行嵌入开发</p>\n<ul>\n<li><p>快照文件，用于加快创建 Javascript 引擎</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">natives_blob.bin</span><br><span class=\"line\">snapshot_blob.bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>静态库，位于 out.gn/x64.release/obj 目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libv8_base.a</span><br><span class=\"line\">libv8_external_snapshot.a</span><br><span class=\"line\">libv8_init.a</span><br><span class=\"line\">libv8_initializers.a</span><br><span class=\"line\">libv8_libbase.a</span><br><span class=\"line\">libv8_libplatform.a</span><br><span class=\"line\">libv8_libsampler.a</span><br><span class=\"line\">libv8_nosnapshot.a</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>icu 静态库，out.gn/x64.release/obj/third_party/icu 目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libicui18n.a</span><br><span class=\"line\">libicuuc.a</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调试库，out.gn/x64.release/obj/src/inspector 目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libinspector.a</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p>上面的流程中，任意一条命令执行有误，都有可能会导致最终编译失败，我们要注意每一条命令的输出信息。</p>\n<p>我在第七步  <code>tools/dev/v8gen.py x64.release</code> 时发生过错误，使用 <code>-vv</code>  查看具体错误信息，发现是系统没有安装  pkg-config 导致的，<code>brew install pkg-config</code> 后解决问题。</p>\n","categories":[],"tags":["v8"]},{"title":"基于 Prometheus 的监控实践","url":"http://localhost:4000/2018/06/14/prometheus/","content":"<h3 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h3><p>之前团队一直使用 APM (newrelic、tingyun等) 去监控应用的状态，分析性能，这些工具不侵入业务，不用埋点，接入简单，是非常好的系统监控解决方案。但是，有些需求是 APM 无法满足的，比如，我们需要监控各个渠道或各平台充值速率，各渠道新用户的增长等等。这种细粒度的监控能帮助我们及时发现以及定位问题，这些指标一般也统称为<strong>应用业务指标</strong>。</p>\n<p>指标采集目前比较常见的方式就是写日志，将日志通过 TCP、UDP 等方式推送到远端（ES、InfluxDB等）进行分析和绘图，虽然可以满足我们的需求，但在指标采集的粒度和维度以及查询上都不太灵活。</p>\n<p>最终我们选择使用 Prometheus ，主要是通过 pull 的方式来采集指标。</p>\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p>下图说明了 Prometheus 及其生态系统组件的一些架构，来自<a href=\"https://prometheus.io/docs/introduction/overview/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p><img src=\"https://prometheus.io/assets/architecture.svg\" alt=\"\"></p>\n<p>Prometheus 可以从配置或用服务发现获取监控目标，然后去调用目标的 /metrics 接口采集数据，将数据存储到硬盘中，采集到的数据最终有两个去向，一个是报警，一个就是可视化。</p>\n<h3 id=\"prometheus-特点\"><a href=\"#prometheus-特点\" class=\"headerlink\" title=\"prometheus 特点\"></a>prometheus 特点</h3><ul>\n<li>多维度的数据模型</li>\n<li>灵活强大的查询语句（PromQL）</li>\n<li>采用 HTTP 协议，主要使用 Pull 方式采集指标</li>\n<li>监控目标，可以采用静态配置和服务发现的方式</li>\n</ul>\n<h3 id=\"数据模型和类型\"><a href=\"#数据模型和类型\" class=\"headerlink\" title=\"数据模型和类型\"></a>数据模型和类型</h3><p>每条指标数据由 metric (指标名称)，一个或一组 label ，以及 float64 的值和毫秒级的时间戳组成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">例子：</span><br><span class=\"line\">api_http_requests_total&#123;method=&quot;POST&quot;, handler=&quot;/messages&quot;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>metric name 需要满足正则 <code>[a-zA-Z_:][a-zA-Z0-9_:]*</code> </li>\n<li>label name 需要满足正则 <code>[a-zA-Z_][a-zA-Z0-9_]*</code></li>\n</ul>\n<p>Prometheus 客户端库目前提供了四种核心度量类型。</p>\n<h4 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h4><p>简单的计数器，不断的增加。比如监控新用户的变化，可以使用 Counter</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_user_count&#123;platform=&quot;Weixin&quot;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Gauge\"><a href=\"#Gauge\" class=\"headerlink\" title=\"Gauge\"></a>Gauge</h4><p>监控的数据是瞬时的，可以任意变高变低。比如监控 Node.js 内存使用情况</p>\n<h4 id=\"Histogram\"><a href=\"#Histogram\" class=\"headerlink\" title=\"Histogram\"></a>Histogram</h4><p>直方图对观察结果进行采样（通常是请求持续时间或响应大小等），并将其计入可配置桶中，还提供了所有观测值的总和。</p>\n<h4 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h4><p>和 Histogram 十分相似，也是对观察结果进行采样，区别是它按百分比去统计数据。比如统计 API 接口响应时间，可以使用 Summary 或者 Histogram。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_request_duration_seconds&#123;quantile=&quot;0.05&quot;,method=&quot;GET&quot;&#125; 21</span><br><span class=\"line\">http_request_duration_seconds&#123;quantile=&quot;0.5&quot;,method=&quot;GET&quot;&#125; 60</span><br><span class=\"line\">http_request_duration_seconds&#123;quantile=&quot;0.99&quot;,method=&quot;GET&quot;&#125; 80</span><br><span class=\"line\">http_request_duration_seconds_sum&#123;method=&quot;GET&quot;&#125; 600</span><br><span class=\"line\">http_request_duration_seconds_count&#123;method=&quot;GET&quot;&#125; 112</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><p>Prometheus 提供了一个实用性的查询语言 PromQL，可以让我们实时的选择和汇总时间序列数据，它的语言表现力非常丰富，内置多种函数，满足各个维度的复杂查询。</p>\n<p>在这里简单举个例子，详细的使用参考<a href=\"https://prometheus.io/docs/prometheus/latest/querying/basics/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比如有以下一组序列数据，每条数据包含三个 label ，渠道、平台及充值类型，值为当时充值总量</span><br><span class=\"line\"></span><br><span class=\"line\">charge_order_price_count&#123;channel=&quot;ANDROID&quot;,platform=&quot;ALI&quot;,type=&quot;CHARGE&quot;&#125;\t5000</span><br><span class=\"line\">charge_order_price_count&#123;channel=&quot;ANDROID&quot;,platform=&quot;ALI&quot;,type=&quot;MONTHLY&quot;&#125;\t4000</span><br><span class=\"line\">charge_order_price_count&#123;channel=&quot;ANDROID&quot;,platform=&quot;WEIXIN&quot;,type=&quot;CHARGE&quot;&#125; 6000</span><br><span class=\"line\">charge_order_price_count&#123;channel=&quot;iOS&quot;,platform=&quot;ALI&quot;,type=&quot;CHARGE&quot;&#125; 6000</span><br><span class=\"line\">charge_order_price_count&#123;channel=&quot;iOS&quot;,platform=&quot;WEIXIN&quot;,type=&quot;MONTHLY&quot;&#125; 6000</span><br><span class=\"line\"></span><br><span class=\"line\">我们想分别统计各个渠道充值速率，可以用如下 query 语句</span><br><span class=\"line\">sum(rate(charge_order_price_count[5m])) by (channel) </span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">&#123;channel=&quot;iOS&quot;&#125;\t 12</span><br><span class=\"line\">&#123;channel=&quot;ANDROID&quot;&#125;\t25</span><br><span class=\"line\"></span><br><span class=\"line\">想统计各个平台或充值类型，使用同样语句只需要改变 by 的值就可以办到</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务发现和数据采集\"><a href=\"#服务发现和数据采集\" class=\"headerlink\" title=\"服务发现和数据采集\"></a>服务发现和数据采集</h3><p>对 API 进行监控，如果使用 Prometheus 的静态配置，当新增或下线一个实例时，由于配置列表过长，修改起来非常痛苦，极其容易导致误操作，所以从一开始我们就决定了使用 Prometheus 的服务发现。从官方文档可以发现它支持多种多样的服务发现，consul、file、dns等等，最终我们选择了使用 consul。</p>\n<p>在 API 项目暴露出 /metrics 指标采集接口，并将地址注册到 consul，在 Prometheus 里配置 consul_sd_configs 发现服务，开始采集数据，整个流程都如架构图一样的完美。</p>\n<p>然而，在采集一段时间后，发现监控数据与实际数值差异巨大，比如监控的接口 QPS 是实际的 1/16，仔细回顾了整个过程，发现遗漏一个非常重要的事情，我们 API 使用 pm2 集群模式在单个机器上部署了16个进程，共享同一个端口，Prometheus 每次扒取的数据仅仅是16个进程中的其中一个！</p>\n<p>事情变得没有刚开始想象的那么简单，解决方案想来想去貌似只有两个，一是每个进程都去聚合16个进程的指标数据，Prometheus 不管去哪个进程抓数据，拿到的都是同样的聚合后的数据。二是将每个进程都注册到 consul，Prometheus 分别去抓每个进程的数据。</p>\n<p>刚开始采用方案一，就碰到个棘手的问题，由于使用 pm2 的集群模式，导致 node 进程无法获取集群中 master 信息，进而无法进行进程间通信。幸运的是，pm2 自身提供了与子进程通信的接口，然后调整了方案一，决定编写个 pm2 的模块(<a href=\"https://github.com/redar9/pm2-cluster-prometheus\" target=\"_blank\" rel=\"noopener\">pm2-cluster-prometheus</a>)，通过模块去聚合各个进程的指标数据，并提供 /metrics 接口给 Prometheus，思路理清后发现使用 pm2 模块聚合指标比最初的方案要好很多。</p>\n<p>模块编写完成后，开始上线测试，一切也都很顺利，所有的数据都被采集到 Prometheus，结果又碰到个问题😣，根据指标使用下面查询语句计算的 API 平均延迟高于实际的，非常不准确，而且波动很大</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])</span><br></pre></td></tr></table></figure>\n<p>将近找了一天原因，发现问题出现在指标的聚合运算上，两个进程中名称同样的 Counter 类型指标，聚合时只是将值相加，由于采集值是浮点数，js 进行聚合时因为精度问题，聚合后的结果忽大忽小，最终导致计算的曲线与实际的不否。后面将采集的值调整为整数，解决数据波动问题。</p>\n<p>问题还在继续发生，上线后，随着业务的增上，需要监控的指标越来越多，pm2 模块在聚合指标时计算量越来越大，需要的内存也越来越多，为了减轻模块的压力结合领导的建议，开始考虑当初方案二的可行度，有了pm2 模块的基础，实施也就变得简单点了，pm2 模块将所有进程都注册到 cosnul 并打上 pmId 的 tag，Prometheus 通过 relabel_configs 将 pmId 增加到抓取接口请求参数中，请求到 pm2 模块的链接变为 /metrics?pm_id=1，模块根据 pm_id 到相应的进程拿到指标数据再返回。至此问题总算告一段落，后续碰到再分享给大家。</p>\n<h3 id=\"报警和可视化\"><a href=\"#报警和可视化\" class=\"headerlink\" title=\"报警和可视化\"></a>报警和可视化</h3><p>Prometheus 的报警功能主要是利用 Alertmanager 这个组件，这个组件实现了几个高级的功能，报警分组、报警抑制、报警静默，让我们可以忽视重复的、没用的、级别不高的报警，筛选出真正有用的信息。报警通知的方式也有很多中，emali、微信、slack、webhook等，目前我们使用 webhook 将报警内容发送到一个中间程序中自定义内容格式后再发送到钉钉群。</p>\n<p>可视化，基本使用的都是 Grafana，配置简单，可以做非常多定制化图表。</p>\n","categories":[],"tags":["Prometheus"]},{"title":"Golang 的 for-range 循环中指针和值的区别","url":"http://localhost:4000/2018/04/18/golang-forRang/","content":"<p>我们先看下面的一段代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> field <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *field)</span> <span class=\"title\">print</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(p.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"use values:\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tvalues := []field&#123;&#123;<span class=\"string\">\"one\"</span>&#125;, &#123;<span class=\"string\">\"two\"</span>&#125;, &#123;<span class=\"string\">\"three\"</span>&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> v.<span class=\"built_in\">print</span>()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println()</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"use pointers:\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tponiters := []*field&#123;&#123;<span class=\"string\">\"one\"</span>&#125;, &#123;<span class=\"string\">\"two\"</span>&#125;, &#123;<span class=\"string\">\"three\"</span>&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> poniters &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> v.<span class=\"built_in\">print</span>()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最近在面试过程中，经常会问面试者这道题打印的结果是什么，很多人回答出了正确的答案，但不能清晰的说明为什么会这样。在开始之前，我们可以自己先思考下上述问题的答案，然后在深入分析下具体原因。</p>\n<p>OK！我们现在知道了答案，第一个循环，控制台会打印出 three three three，因为在 goroutines 执行前，for 循环已经执行结束，变量 v 值为切片里的最后一位元素。但是第二个循环呢，如果你尝试将代码运行后，会看到打印的永远是 one two three，可能顺序不一致，但结果是这三个，为什么？</p>\n<p>在上面这两种情况下，每一次的迭代都使用了相同的变量 v ，只是每次的值不相同。在第一个循环中，v 的类型是 field ，go 声明会评估函数的参数和返回值，方法的调用可以看作方法调用者作为一个隐藏参数的函数调用，所以此时，参数被评估为 &amp;v，v.print() 其实就是 (&amp;v).print() 的简写，go 声明创建了 goroutine 将 v 的地址作为第一个参数传入函数等待调用。</p>\n<p>接着，循环将下一个元素赋值给变量 v，这里出现了 data race，goroutine 并不能保证肯定在 for 循环之后执行（第一种结果也有可能出现 two three three），虽然绝大数情况是这样，在循环中给变量 v 赋值和在 goroutine 中引用 v.name 不是同步的操作，所以产生了 data race。</p>\n<p>如果循环结束后，goroutines 才开始执行，变量 v 被赋值为数组最后一个元素，三个 goroutine 里的 &amp;v 指向同一个地址，结果为最开始所描述的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *field)</span> <span class=\"title\">print</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%p \\n\"</span>, p)  <span class=\"comment\">//将 p 的地址打印出来</span></span><br><span class=\"line\">\tfmt.Println(p.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果三次指针指向的地址相同</span></span><br><span class=\"line\">use values:</span><br><span class=\"line\"><span class=\"number\">0xc42000e1d</span>0</span><br><span class=\"line\">three</span><br><span class=\"line\"><span class=\"number\">0xc42000e1d</span>0</span><br><span class=\"line\">three</span><br><span class=\"line\"><span class=\"number\">0xc42000e1d</span>0</span><br><span class=\"line\">three</span><br></pre></td></tr></table></figure>\n<p>在第二种情况中，v 的类型是 *filed，go 声明评估参数为当前 v 的值，也就是 slice 中第一个指针，go 声明创建了 goroutine 将 v 作为第一个参数传入函数等待调用。</p>\n<p>当循环继续给变量 v 重新赋值时，没有改变任何 goroutine 中的参数引用，所以没有产生 data race，goroutines 执行后打印出 slice 中每个元素的 name。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三次指针指向不同的地址</span></span><br><span class=\"line\">use pointers:</span><br><span class=\"line\"><span class=\"number\">0xc4200ae010</span></span><br><span class=\"line\">one</span><br><span class=\"line\"><span class=\"number\">0xc4200ae020</span></span><br><span class=\"line\">two</span><br><span class=\"line\"><span class=\"number\">0xc4200ae030</span></span><br><span class=\"line\">three</span><br></pre></td></tr></table></figure>\n<p>如果第一种情况，我们确实需要将指针传入 goroutine 中，如何保证输出的结果正确呢？有两个解决的办法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, _ := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> values[i].<span class=\"built_in\">print</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时，表达式 values[i].print() 评估传入的第一个隐藏参数为 &amp;values[i]，它是一个指向 slice 底层数组元素的指针，所以每次循环指向了不同元素。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> values &#123; </span><br><span class=\"line\">    w := v </span><br><span class=\"line\">    <span class=\"keyword\">go</span> w.<span class=\"built_in\">print</span>() </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，虽然每次迭代还是重复使用了变量 v ，但是每次会创建一个新的变量 w，循环给 v 赋值，然后复制给 w，现在 go 中函数调用参数被评估为 &amp;w，因为每次迭代会创建新的 w，所以每个 goroutine 创建时复制了不同的 slice 元素作为参数进行函数调用。</p>\n","categories":[],"tags":["Golang"]},{"title":"Kubernetes 架构浅析","url":"http://localhost:4000/2018/03/23/Kubernetes-architecture/","content":"<p>最近研究了一段时间的 Kubernetes，在我们的测试环境上也搭建了一个简单的集群来学习相关的知识。月初的时候在团队做了一次 Kubernetes 架构分享，此次整理成文章记录下。</p>\n<h3 id=\"为什么要用-Kubernetes\"><a href=\"#为什么要用-Kubernetes\" class=\"headerlink\" title=\"为什么要用 Kubernetes ?\"></a>为什么要用 Kubernetes ?</h3><p>Kubernetes 作为一个容器管理平台，优点足够足够的多，在任意的相关文章中都可以看到，比如，自动化容器的部署和复制、服务发现、负载均衡、滚动更新、自动缩放等等… ，但在我看来最根本的一个理由是，IT 从来都是一个由新技术驱动的行业，况且这还是 Google 十几年以来大规模应用容器技术的经验积累和升华的一个重要成果。</p>\n<h3 id=\"Kubernetes-组件\"><a href=\"#Kubernetes-组件\" class=\"headerlink\" title=\"Kubernetes 组件\"></a>Kubernetes 组件</h3><p>为了理解 Kubernetes 的核心原理，我们先大致看下它的整体架构图，主要分为了两个大块，主节点和工作节点，每个大块又运行着不同的组件，下面我们会具体说说每个组件各自的职责。</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178480852096\" alt=\"\"></p>\n<h3 id=\"Mater-Node\"><a href=\"#Mater-Node\" class=\"headerlink\" title=\"Mater Node\"></a>Mater Node</h3><p>主节点负责管理整个 k8s 集群，是所有管理任务的入口，检测并且响应集群事件。</p>\n<h4 id=\"API-Server\"><a href=\"#API-Server\" class=\"headerlink\" title=\"API Server\"></a>API Server</h4><p>顾名思义，提供增删改查及 watch 的 API 接口，服务对象是 Kubernetes 中各类资源，如 Pod、Service 等，在图中可以看到 API Server 是整个集群内部各个功能模块之间数据交互和通信的中心枢纽，是整个系统的数据总线和数据中心。</p>\n<p>​API Server 通过一个名为 kube-apiserver 的进程提供服务，运行在 Master 节点上，默认情况下，是在本机的 8080 端口提供服务，我们也可以同时开启 HTTPS 安全端口加强接口访问的安全性。</p>\n<p>​我们通常情况下使用 kubectl ，或使用 REST 接口访问 API ，当请求到达时，会经历几个阶段，如下图中所示：</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178489225754\" alt=\"\"></p>\n<ul>\n<li><p>Authentication（身份认证）</p>\n<blockquote>\n<p>方式有很多中，可以同时指定多个模块，每个认证模块都会按顺序进行，直到其中一个成功，就会进入下一步。图中我们可以看出，k8s 的客户端有两类，一种是普通用户，一种是集群内的 Pod，虽然这种两种客户端认证机制略有不同，但无论哪一种都需要依次经历三个步骤。</p>\n</blockquote>\n<ul>\n<li><p>证书认证</p>\n</li>\n<li><p>Token 认证</p>\n</li>\n<li><p>用户名密码</p>\n</li>\n<li><p>JWT Token （用于 Service Account ）</p>\n</li>\n</ul>\n</li>\n<li><p>Authorization（授权）</p>\n<blockquote>\n<p>授权策略也支持开启多个授权插件，只要一个验证通过即可。</p>\n</blockquote>\n<ul>\n<li><p>Node  配合 NodeRestriction 准入控制限制 kubelet 访问相关资源</p>\n</li>\n<li><p>ABAC  基于属性的授权策略</p>\n</li>\n<li><p>RBAC  基于角色的授权策略</p>\n</li>\n<li><p>Webhook  通过外部提供的 HTTPS 服务进行授权</p>\n</li>\n</ul>\n</li>\n<li><p>AdmissionControl（准入控制）</p>\n<blockquote>\n<p>准入控制用来对请求做进一步的验证或添加默认参数，是一组插件列表，请求时，每个准入插件按照一定顺序执行，如果有一个拒绝了此次请求，那么请求会立即失败。</p>\n</blockquote>\n<ul>\n<li><p>ServiceAccount  为 Pod 添加相应的认证信息</p>\n</li>\n<li><p>ResourceQuota  Namespace 上的配额管理</p>\n</li>\n<li><p>LimitRanger  Pod和容器的配额管理</p>\n</li>\n<li><p>NamespaceLifecycle</p>\n</li>\n<li><p>… 其他的就不一一列举了</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>上面只是简单介绍了下 API 访问控制涉及到的一些功能模块，具体到每个里面其实还是很深的细节值得挖掘，有机会的话会单独整理一篇文章详细介绍这里的内容。</p>\n<h4 id=\"Controller-Manager\"><a href=\"#Controller-Manager\" class=\"headerlink\" title=\"Controller Manager\"></a>Controller Manager</h4><p>集群内部的管理控制中心，一系列控制器的集合，主要工作是通过 API Server 监控整个集群的状态，并确保集群处于预期的工作状态。</p>\n<p>一个典型的控制器例子就是副本控制器（Replication Controller），它主要负责控制集群中 Pod 的数量（数量由用户配置），如果发现数量超过预设值，则会销毁一些 Pod，反之，创建新的 Pod 副本。</p>\n<p>​还有个例子 Endpoint Controller，在这之前我们先看下 Service、Endpoints 与 Pod 的关系</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178495275310\" alt=\"\"></p>\n<p>如图中所示，Endpoints 表示了一个 Service 对应的所有 Pod 副本的访问地址，而 Endpoints Controller 就是负责监听 Service 和所对应 Pod 副本的变化，进而生成和维护所有 Endpoints 对象的控制器。</p>\n<p>​还有其他的控制器，比如节点控制器、命名空间控制器、配额控制器、令牌控制器等，在这里就不深入说明了。</p>\n<h4 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h4><p>Kubernetes 的调度器，核心功能是监听 API Server 来获取未绑定节点的 Pod，把它绑定到合适的节点上，然后通过 API Server 将绑定信息写入 etcd。调度原理说起来很简单，但是要编写一个优秀的调度器却不容易，有很多问题需要考虑，如何保证每个节点都能分配到资源？如何高效利用集群资源等。</p>\n<p>​Kubernetes Scheduler 当前提供的默认调度流程分为以下两步：</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178500602936\" alt=\"\"></p>\n<ol>\n<li><p>预选调度过程，即遍历所有的目标Node，筛选出符合条件的候选节点。Kubernetes 里内置了多种预选策略供用户选择。</p>\n<ul>\n<li><p>NoDiskConflict   判断 Pod 指定的 Volume 和节点上已经挂载的 Volume 是否冲突</p>\n</li>\n<li><p>PodFitsResource    判断节点的资源是否满足 Pod 的需求（内存和 CPU ）</p>\n</li>\n<li><p>PodSelectorMatches   判断节点是否包含 Pod 的标签选择器指定的标签</p>\n</li>\n<li><p>PodFitsHost   判断 Pod 指定的节点名称与备选节点名称是否一致</p>\n</li>\n<li><p>CheckNodeLabelPresence   （需要用户配置）如果节点存在此策略列出的标签时，根据配置是否选择该节点</p>\n</li>\n<li><p>CheckServiceAffinity    （需要用户配置）判断节点是否包含策略指定的标签，或包含和 Pod 同 Service 和 Namespace 下其他 Pod 所在节点的标签列表</p>\n</li>\n<li><p>PodFitsPorts    判断 Pod 所用端口是否在节点上已被占用</p>\n</li>\n</ul>\n</li>\n<li><p>确定最优节点，在第一步的基础上，采用优选策略计算出每个候选节点的积分，积分最高者胜出。</p>\n<ul>\n<li><p>LeastRequestedPriority   从备选节点列表中选出资源消耗最小的节点（内存和 CPU ）</p>\n</li>\n<li><p>BalancedResourceAllocation   从备选节点列表中选出各项资源使用率最均衡的节点</p>\n</li>\n<li><p>ImageLocalityPriority   倾向于已经有 Pod 要使用镜像的节点，镜像越大，分数越高</p>\n</li>\n<li><p>CalculateNodeLabelPriority   （需要用户配置）如果节点包含策略指定标签时，根据配置是否选择该节点</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Woker-Node\"><a href=\"#Woker-Node\" class=\"headerlink\" title=\"Woker Node\"></a>Woker Node</h3><p>Node 节点是 Kubernetes 集群中的工作负载节点，Pod 就运行在 Node 节点上。</p>\n<h4 id=\"Kubelet\"><a href=\"#Kubelet\" class=\"headerlink\" title=\"Kubelet\"></a>Kubelet</h4><p>每个节点上都会启动一个 Kubelet 服务进程，主要来处理 Master 节点下发到本节点的任务，管理 Pod 及 Pod 中的容器。还会在 API Server 上注册节点自身信息，定期像 Master 汇报节点资源使用情况。</p>\n<ul>\n<li><p>节点管理</p>\n</li>\n<li><p>Pod 管理</p>\n<p>Kubelet 通过三种方式获取自身 Node 上所要运行的 Pod 清单。</p>\n<ol>\n<li><p>文件目录，默认目录是 /etc/kubernetes/manifests/</p>\n</li>\n<li><p>HTTP接口，通过 –manifest-url 参数设置</p>\n</li>\n<li><p>API Server，监听接口，同步自身节点 Pod 目录</p>\n</li>\n</ol>\n<p>前两种情况创建的 Pod 叫做 Static Pod，不受集群管理，但是 Kubelet会将 Static Pod 状态汇报到 API Server，然后 API Server 会创建一个镜像 Pod 与之匹配，可以检测到状态变化，但并不能通过接口去修改操作它。</p>\n</li>\n<li><p>容器健康检查</p>\n<p>通过两类探针来检查容器的健康状态，一个是 LivenessProbe 探针，用于判断容器是否健康，一个是 ReadinessProbe 探针，用于判断容器是否启动完成，并准备接受请求。</p>\n</li>\n</ul>\n<h4 id=\"Kube-Proxy\"><a href=\"#Kube-Proxy\" class=\"headerlink\" title=\"Kube Proxy\"></a>Kube Proxy</h4><p>当我们在集群中创建了 Pod 后，可以获得这个 Pod ip 地址，然后在集群内部可以通过 PodIP:Port 来获取对应的服务，但是 Pod 是经常变化的，每次更新 ip 地址可能发生变化，而且水平扩展后，会有新的 Pod 被创建出来，出现新的 ip 地址，所以为了解决这个问题，Kubernetes 抽象出了 Service 的概念。</p>\n<p>​每个 Service 都有一个固定的虚拟 ip，客户端通过访问这个 ip 来访问服务，Service 则负责将请求转发到后端的 Pod 上，并且能起到负载均衡的作用。</p>\n<p>​实现 Service 这个功能的关键就是 kube-proxy，kube-proxy 通过查询和监听 API Server 中 Service 和 Endpoints 的变化，通过管理 Iptables 来实现网络的转发，所以，由于 kube-proxy 的作用，客户端无需关心后端有几个 Pod，整个通信的过程，负载均衡，水平扩展都是透明的。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>此次从整体的角度介绍了 Kubernetes 中各个组件的作用，一些深入的细节部分有机会在整理出来分享给大家。Kubernetes 各个组件没有复杂的交互，每个模块只做好自己事情，看似简单的设计却支撑着强大分布式系统有序而又稳定的工作，这种设计思想十分值得我们学习。</p>\n","categories":[],"tags":["Kubernetes"]},{"title":"关于","url":"http://localhost:4000/about/index.html","content":"<p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:&#x72;&#x75;&#x69;&#121;&#x75;&#x61;&#x6e;&#x2e;&#119;&#97;&#110;&#103;&#64;&#x6f;&#117;&#x74;&#108;&#111;&#111;&#107;&#x2e;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x72;&#x75;&#x69;&#121;&#x75;&#x61;&#x6e;&#x2e;&#119;&#97;&#110;&#103;&#64;&#x6f;&#117;&#x74;&#108;&#111;&#111;&#107;&#x2e;&#99;&#x6f;&#x6d;</a></p>\n<p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/ryanwry\" target=\"_blank\" rel=\"noopener\">ryanwry</a></p>\n","categories":[],"tags":[]},{"title":"category","url":"http://localhost:4000/category/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://localhost:4000/css/personal-style.css","content":"html.page-home{\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-image: url('/images/bg.jpg');\n  background-color: transparent;\n  background-size: cover;\n  background-position: center center;\n  background-repeat: no-repeat;\n  /*background: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);*/\n  /*background-blend-mode: screen;*/\n  /*background: linear-gradient(to left, #5f2c82, #49a09d);*/\n}","categories":[],"tags":[]},{"title":"link","url":"http://localhost:4000/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://localhost:4000/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://localhost:4000/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://localhost:4000/tag/index.html","content":"","categories":[],"tags":[]}]