[{"title":"当我们使用 Helm 时，可能需要考虑一些安全问题","url":"http://localhost:4000/2018/12/19/helm-security/","content":"<p>使用默认的安装命令 helm init 可以快速安装 Tiller，但是默认的安装方式没有任何安全性的配置。</p>\n<p>默认的安装方式将 Tiller 安装在 kube-system 下，并赋予它 cluster-admin 的权限，可以操作集群中任意资源。</p>\n<h2 id=\"RBAC\"><a href=\"#RBAC\" class=\"headerlink\" title=\"RBAC\"></a>RBAC</h2><p>在安装 Tiller 时，可以指定其使用的 ServiceAccount 进行 RBAC 授权。</p>\n<p>但是有个问题是，Tiller 操作集群资源都是使用其自身凭证和权限执行，并不考虑 Helm 客户端的权限。</p>\n<p>也就说 kubectl 只要能连接集群并且只需要有 pods 和 portforward 权限，那么 Helm 就可以通过 kubectl 连接到 Tiller，进而使用 Tiller 的权限操作集群资源。</p>\n<p>如果我们需要用户可以使用 Helm，但是仍要限制对集群的操作，该怎么做？目前的方法对不同的用户群组创建的不同的 ServiceAccount，使用不同的 RBAC 策略，绑定到对应的 TIller 实例上，通过控制用户访问哪个 Tiller 来确保操作。这样带来的问题也很明显，集群里有多个 Tiller 实例难以管理。</p>\n<p>社区也在考虑将 RBAC 权限控制从 Tiller 服务端移到 Helm 客户端，每个操作都是由用户请求的，而不是 TIller。</p>\n<h2 id=\"GRPC-Endpoint\"><a href=\"#GRPC-Endpoint\" class=\"headerlink\" title=\"GRPC Endpoint\"></a>GRPC Endpoint</h2><p>helm 客户端通过 GRPC 和 Tiller 通信，Tiller 提供的 GRPC 端口在集群内部无需通过身份验证即可访问，这意味着集群内的任意 Pod 都可以使用此端口连接 Tiller 进而操作集群资源，创建 ClusterRole 授予任意 Pod 升级权限等等，GMAE OVER 😭。</p>\n<p>在集群外访问时 Helm 需要通过 API Server 进行身份验证，才可以访问 Tiller。</p>\n<p>有两种方式保护 Tiller 端口</p>\n<ul>\n<li>开启 TLS</li>\n<li>本地运行 Tiller，Helm 客户端通过 port forward 连接不受影响</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ul>\n<li><a href=\"https://docs.helm.sh/using_helm/#securing-your-helm-installation\" target=\"_blank\" rel=\"noopener\">Helm Docs</a></li>\n<li><a href=\"https://engineering.bitnami.com/articles/helm-security.html\" target=\"_blank\" rel=\"noopener\">Bitnami Engineering Portal: Exploring the Security of Helm</a></li>\n</ul>\n","categories":[],"tags":["Kubernetes","Helm"]},{"title":"访问 Kubernetes API - Admission Control（三）","url":"http://localhost:4000/2018/12/18/k8s-admission/","content":"<p>准入控制器是运行在 Authention 和 Authoriztion 之后，对象持久化之前，拦截 API Server 的请求对请求资源进行修改或者验证的一组插件列表，必须在 API Server 启动时配置。</p>\n<p>在 1.10+ 版本，修改资源的控制器优先执行，然后执行验证控制器。任意控制器拒绝请求，则立即拒绝整个请求，并向用户返回错误。</p>\n<h2 id=\"控制器列表\"><a href=\"#控制器列表\" class=\"headerlink\" title=\"控制器列表\"></a>控制器列表</h2><h3 id=\"AlwaysPullImages\"><a href=\"#AlwaysPullImages\" class=\"headerlink\" title=\"AlwaysPullImages\"></a>AlwaysPullImages</h3><p>强制修改每个 Pod 拉取镜像的策略为 Always，主要用于多用户集群中，他们的私有镜像只能被拥有凭证的人使用。没有这个控制器，一旦镜像被拉去到节点上，任何 Pod 都可以通过镜像名称（同一个节点）来使用它，而不需要对镜像进行授权检查。</p>\n<h3 id=\"DefaultStorageClass\"><a href=\"#DefaultStorageClass\" class=\"headerlink\" title=\"DefaultStorageClass\"></a>DefaultStorageClass</h3><p>控制器监视 PersistentVolumeClaim 的创建，如果没有指定 storage class，就会向他们添加默认的 storage class。当没有配置默认的 storage class，控制器不会执行任何操作，当有一个以上的 storage class 别标记为默认时，控制器会拒绝请求，返回一个错误。</p>\n<h3 id=\"DefaultTolerationSeconds\"><a href=\"#DefaultTolerationSeconds\" class=\"headerlink\" title=\"DefaultTolerationSeconds\"></a>DefaultTolerationSeconds</h3><p>设置 Pod 默认的容忍时间为5分钟，<code>notready:NoExecute</code>  和 <code>unreachable:NoExecute</code></p>\n<h3 id=\"DenyEscalatingExec\"><a href=\"#DenyEscalatingExec\" class=\"headerlink\" title=\"DenyEscalatingExec\"></a>DenyEscalatingExec</h3><h3 id=\"EventRateLimit-alpha\"><a href=\"#EventRateLimit-alpha\" class=\"headerlink\" title=\"EventRateLimit (alpha)\"></a>EventRateLimit (alpha)</h3><p>限制 API Server 在设定时间片接受 event 请求的数量。因为集群中可能会有始终处于某种错误状态的 Pod，kubelet 或者 controllers 会重复不断的发出 event 请求，可能会影响到整个集群。</p>\n<h3 id=\"ExtendedResourceToleration\"><a href=\"#ExtendedResourceToleration\" class=\"headerlink\" title=\"ExtendedResourceToleration\"></a>ExtendedResourceToleration</h3><h3 id=\"ImagePolicyWebhook\"><a href=\"#ImagePolicyWebhook\" class=\"headerlink\" title=\"ImagePolicyWebhook\"></a>ImagePolicyWebhook</h3><p>控制器允许使用 webhook 来判断镜像拉取策略</p>\n<h3 id=\"LimitPodHardAntiAffinityTopology\"><a href=\"#LimitPodHardAntiAffinityTopology\" class=\"headerlink\" title=\"LimitPodHardAntiAffinityTopology\"></a>LimitPodHardAntiAffinityTopology</h3><p>Pod Affinity 相关</p>\n<h3 id=\"LimitRanger\"><a href=\"#LimitRanger\" class=\"headerlink\" title=\"LimitRanger\"></a>LimitRanger</h3><p>控制器确保请求的资源不会违反 Namespace 中 LimitRange 的约束。还可以将默认的资源请求和限制设置到未指定的 Pod 上。</p>\n<h3 id=\"NamespaceAutoProvision\"><a href=\"#NamespaceAutoProvision\" class=\"headerlink\" title=\"NamespaceAutoProvision\"></a>NamespaceAutoProvision</h3><p>检查请求资源所属 Namespace 是否存在，如果不存在则创建一个。</p>\n<h3 id=\"NamespaceExists\"><a href=\"#NamespaceExists\" class=\"headerlink\" title=\"NamespaceExists\"></a>NamespaceExists</h3><p>检查除 Namespace 自身外资源请求的命名空间，如果不存在，拒绝请求。</p>\n<h3 id=\"NamespaceLifecycle\"><a href=\"#NamespaceLifecycle\" class=\"headerlink\" title=\"NamespaceLifecycle\"></a>NamespaceLifecycle</h3><p>这个插件强制不能在一个正在被终止的 Namespace 中创建新对象，和确保使用不存在 Namespace 的请求被拒绝。删除 Namespace 触发了在该命名空间中删除所有对象（ pod 、 services 等）的一系列操作。</p>\n<h3 id=\"NodeRestriction\"><a href=\"#NodeRestriction\" class=\"headerlink\" title=\"NodeRestriction\"></a>NodeRestriction</h3><p>控制器限制了 kubelet 可以修改的 Node 和 Pod 对象，只允许修改自己的 Node 资源及绑定到节点本身的 Pod 资源。</p>\n<h3 id=\"OwnerReferencesPermissionEnforcement\"><a href=\"#OwnerReferencesPermissionEnforcement\" class=\"headerlink\" title=\"OwnerReferencesPermissionEnforcement\"></a>OwnerReferencesPermissionEnforcement</h3><p>控制器保护对 metadata.ownerReferences 对象的访问，只有具有删除权限的用户才能对其更改。</p>\n<h3 id=\"PodNodeSelector\"><a href=\"#PodNodeSelector\" class=\"headerlink\" title=\"PodNodeSelector\"></a>PodNodeSelector</h3><p>使用 Namespace 的一个注解 <code>scheduler.alpha.kubernetes.io/node-selector</code>  ，在其中查找标签选择器将其添加至 Pod 中，这功能限制了某个 Namespace 的 Pod，只能运行在指定的节点上。</p>\n<h3 id=\"PodPreset\"><a href=\"#PodPreset\" class=\"headerlink\" title=\"PodPreset\"></a>PodPreset</h3><p>允许控制器向一个 Pod 注入匹配的 PodPreset 中指定的字段。</p>\n<h3 id=\"PodSecurityPolicy\"><a href=\"#PodSecurityPolicy\" class=\"headerlink\" title=\"PodSecurityPolicy\"></a>PodSecurityPolicy</h3><p>控制器在创建和修改 Pod 时，根据请求的安全上下文和可用的 Pod 安全策略来确定是否应该通过请求。</p>\n<h3 id=\"PodTolerationRestriction\"><a href=\"#PodTolerationRestriction\" class=\"headerlink\" title=\"PodTolerationRestriction\"></a>PodTolerationRestriction</h3><p>控制器首先验证 Pod 的容忍和 Namespace 的容忍是否冲突，如果冲突拒绝请求，然后合并容忍度，在根据 Namespace 容忍白名单验证，成功通过请求，失败拒绝请求。</p>\n<h3 id=\"Priority\"><a href=\"#Priority\" class=\"headerlink\" title=\"Priority\"></a>Priority</h3><p>控制器使用 priorityClassName 字段查找 priority class 设置 Pod 优先级，如果 priority class 不存在，拒绝请求。</p>\n<h3 id=\"ResourceQuota\"><a href=\"#ResourceQuota\" class=\"headerlink\" title=\"ResourceQuota\"></a>ResourceQuota</h3><p>控制器观察进入请求，确保它不违反任何一个 Namespace 中的 ResourceQuota 对象约束。</p>\n<h3 id=\"SecurityContextDeny\"><a href=\"#SecurityContextDeny\" class=\"headerlink\" title=\"SecurityContextDeny\"></a>SecurityContextDeny</h3><p>控制器拒绝任何试图设置某些升级的 SecurityContext 字段的 Pod。</p>\n<h3 id=\"ServiceAccount\"><a href=\"#ServiceAccount\" class=\"headerlink\" title=\"ServiceAccount\"></a>ServiceAccount</h3><p>控制器实现了 ServiceAccount 的自动化。</p>\n<ol>\n<li>如果 Pod 未设置 ServiceAccount，则会将其设置为 default。</li>\n<li>确保 Pod 引用的 ServiceAccount 存在，否则拒绝请求。</li>\n<li>如果 Pod 不包含 ImagePullSecrets，那么 ServiceAccount 的 ImagePullSecrets 将被设置到 Pod 上。</li>\n<li>向 Pod 添加一个 volume，包含用于访问 API 的 token。</li>\n<li>将 volumeSource 挂载到每个容器的 /var/run/secrets/kubernetes.io/serviceaccount 下 </li>\n</ol>\n<h3 id=\"StorageObjectInUseProtection\"><a href=\"#StorageObjectInUseProtection\" class=\"headerlink\" title=\"StorageObjectInUseProtection\"></a>StorageObjectInUseProtection</h3><p>控制器将 kubernetes.io/pvc-protection 或 kubernetes.io/pv-protection 终结器添加到新创建的持久卷声明（PVC）或持久卷（PV）。在用户删除PVC或PV的情况下，PVC或PV不会被移除，直到PVC或PV保护控制器从PVC或PV中移除终结器。</p>\n<h3 id=\"PersistentVolumeClaimResize\"><a href=\"#PersistentVolumeClaimResize\" class=\"headerlink\" title=\"PersistentVolumeClaimResize\"></a>PersistentVolumeClaimResize</h3><p>当调整 PersistentVolumeClaim 大小时，控制器将进行额外的验证。</p>\n<h2 id=\"动态准入控制\"><a href=\"#动态准入控制\" class=\"headerlink\" title=\"动态准入控制\"></a>动态准入控制</h2><p>上面的控制器都需要编译到 API Server 中才可以使用，而且只能在启动时配置。Webhooks 和 Initializers 允许用户动态设置准入控制器。</p>\n<h3 id=\"Admission-Webhooks-beta-in-1-9\"><a href=\"#Admission-Webhooks-beta-in-1-9\" class=\"headerlink\" title=\"Admission Webhooks (beta in 1.9)\"></a>Admission Webhooks (beta in 1.9)</h3><p>一个 HTTP 的回调，接受准入请求并处理验证数据，有两种类型</p>\n<ul>\n<li>MutatingAdmissionWebhook </li>\n<li>ValidatingAdmissionWebhook</li>\n</ul>\n<p>istio 就是使用 ValidatingAdmissionWebhook 机制来验证授权用户，使用 MutatingAdmissionWebhook 注入 sidecar</p>\n<h3 id=\"Initializers\"><a href=\"#Initializers\" class=\"headerlink\" title=\"Initializers\"></a>Initializers</h3><p>也是一种动态准入控制，未深入研究</p>\n","categories":[],"tags":["Kubernetes"]},{"title":"访问 Kubernetes API - Authorization（二）","url":"http://localhost:4000/2018/11/02/k8s-authorization/","content":"<p>经过第一步的身份认证后，请求带着认证后的用户信息来到授权模块</p>\n<h2 id=\"请求属性\"><a href=\"#请求属性\" class=\"headerlink\" title=\"请求属性\"></a>请求属性</h2><ul>\n<li>user - 认证阶段将提供的用户名</li>\n<li>group - 用户所属 group 列表</li>\n<li>extra - 扩展数据</li>\n<li>API -  是否请求 API resource，/api, /healthz 等这些属于 non-resource</li>\n<li>Request Path - 请求路径</li>\n<li>HTTP request verb - 资源请求返回 kube verb (get, list, watch 等)</li>\n<li>Resource - 资源名称，请求的 REST 对象</li>\n<li>Subresource - 子资源</li>\n<li>Namespace - 资源对象所属 namespace</li>\n<li>API group -  正在访问的 API 资源组</li>\n</ul>\n<h2 id=\"授权模块\"><a href=\"#授权模块\" class=\"headerlink\" title=\"授权模块\"></a>授权模块</h2><h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><p>特殊模块，专门用来授权由 kubelet 发出来的 API 请求，kubelet 设置请求属性，用户组为 <code>system:nodes</code> ，用户名为 <code>system:node:&lt;nodeName&gt;</code>，让 Node 授权模块识别自己的请求。</p>\n<ul>\n<li>Read - services, nodes, endpoints, pods 等</li>\n<li>Wirte - nodes,node status,pod,pod status,events</li>\n<li>Auth-related -  引导 TLS 的certificationsigningrequests 和委托认证授权 tokenreviews subjectaccessreviews 权限</li>\n</ul>\n<h3 id=\"ABAC\"><a href=\"#ABAC\" class=\"headerlink\" title=\"ABAC\"></a>ABAC</h3><p>基于属性的访问控制定义了一系列策略（用户，资源，对象等），通过组合属性向用户授权访问权限。</p>\n<p>开起 ABAC 模块，需要启动时指定两个参数 <code>--authorization-policy-file=SOME_FILENAME</code>  和 <code>--authorization-mode=ABAC</code> ，策略文件为 JSON 格式。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"apiVersion\"</span>: <span class=\"string\">\"abac.authorization.kubernetes.io/v1beta1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"kind\"</span>: <span class=\"string\">\"Policy\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"spec\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"user\"</span>: <span class=\"string\">\"alice\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"namespace\"</span>: <span class=\"string\">\"*\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"resource\"</span>: <span class=\"string\">\"*\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"apiGroup\"</span>: <span class=\"string\">\"*\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RBAC\"><a href=\"#RBAC\" class=\"headerlink\" title=\"RBAC\"></a>RBAC</h3><p>基于角色的访问控制，允许管理员动态配置权限策略。</p>\n<p>RBAC API 定义了四种顶级资源对象，Role , ClusterRole , RoleBinding , ClusterRoleBinding ，其中：</p>\n<blockquote>\n<p>Role 定义权限集合，必须在 Namespace 下，ClusterRole 类似，区别是整个集群范围内使用，没有 Namespace 的约束。<br>RoleBinding 把 Role 绑定到 Subject ,让 Subject 可以拥有 Role 定义的权限，ClusterRoleBinding 类似，只不过作用于 ClusterRole。RoleBinding 也可以绑定 ClusterRole，拥有的权限只有自己所在 Namespace 下。  </p>\n</blockquote>\n<p>Subject 可以理解为用户，分为 User Group ServiceAccount 几类。</p>\n<h4 id=\"Rules\"><a href=\"#Rules\" class=\"headerlink\" title=\"Rules\"></a>Rules</h4><ul>\n<li>apiGroups</li>\n<li>resources</li>\n<li>resourceNames </li>\n<li>verbs</li>\n</ul>\n<h4 id=\"Aggregated-ClusterRoles\"><a href=\"#Aggregated-ClusterRoles\" class=\"headerlink\" title=\"Aggregated ClusterRoles\"></a>Aggregated ClusterRoles</h4><p>ClusterRole 可以通过标签选择聚合其他 ClusterRole</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ClusterRole</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">rbac.authorization.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">monitoring</span></span><br><span class=\"line\"><span class=\"attr\">aggregationRule:</span></span><br><span class=\"line\"><span class=\"attr\">  clusterRoleSelectors:</span></span><br><span class=\"line\"><span class=\"attr\">  - matchLabels:</span></span><br><span class=\"line\">      <span class=\"string\">rbac.example.com/aggregate-to-monitoring:</span> <span class=\"string\">\"true\"</span></span><br><span class=\"line\"><span class=\"attr\">rules:</span> <span class=\"string\">[]</span> <span class=\"comment\"># Rules are automatically filled in by the controller manager.</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"WebHook\"><a href=\"#WebHook\" class=\"headerlink\" title=\"WebHook\"></a>WebHook</h3><p>通过配置文件定义外部服务器和需要此方式授权的用户，和 kubeconfig 格式相同。当授权开始后，API Server 向外部服务器 POST 一个 JSON 序列化的 SubjectAccessReview 对象，包含发出请求用户信息及正在请求的资源。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"apiVersion\"</span>: <span class=\"string\">\"authorization.k8s.io/v1beta1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"kind\"</span>: <span class=\"string\">\"SubjectAccessReview\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"spec\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"resourceAttributes\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"namespace\"</span>: <span class=\"string\">\"kittensandponies\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"verb\"</span>: <span class=\"string\">\"get\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"group\"</span>: <span class=\"string\">\"unicorn.example.org\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"resource\"</span>: <span class=\"string\">\"pods\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"user\"</span>: <span class=\"string\">\"jane\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"group\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"group1\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"group2\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>远程服务器确认授权后，填充 status 字段</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"apiVersion\"</span>: <span class=\"string\">\"authorization.k8s.io/v1beta1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"kind\"</span>: <span class=\"string\">\"SubjectAccessReview\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"status\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"allowed\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"校验授权\"><a href=\"#校验授权\" class=\"headerlink\" title=\"校验授权\"></a>校验授权</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> kubectl auth can-i create deployments --namespace dev</span><br><span class=\"line\">yes</span><br><span class=\"line\"><span class=\"meta\">$</span> kubectl auth can-i create deployments --namespace prod</span><br><span class=\"line\">no</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 管理员可以模拟用户验证权限</span><br><span class=\"line\"><span class=\"meta\">$</span> kubectl auth can-i list secrets --namespace dev --as dave</span><br><span class=\"line\">no</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过-Pod-创建升级权限\"><a href=\"#通过-Pod-创建升级权限\" class=\"headerlink\" title=\"通过 Pod 创建升级权限\"></a>通过 Pod 创建升级权限</h2><p>有创建 Pod 权限的用户可以通过 volume 读取 namespace 下所有的 secret，configmap，并模拟 servcieAccount 执行任何操作，所以管理员在授予 Pod 创建权限时需要小心。</p>\n","categories":[],"tags":["Kubernetes"]},{"title":"访问 Kubernetes API - Authentication（一）","url":"http://localhost:4000/2018/10/15/k8s-authentication/","content":"<p>以下两种用户类型都可以合法访问 API </p>\n<ul>\n<li>Normal User</li>\n<li>ServiceAccount managed by kubernetes</li>\n</ul>\n<p>普通用户由外部服务管理，集群管理员给他们分发 private keys，用户名密码等，kubernetes 不管理普通用户。</p>\n<p>相反，service account 被集群管理，绑定在指定的 namespace 下，与一个存储证书的 secret 关联，secret 可用于 pod 直接访问 API 。</p>\n<p>当请求到达 API 后，会经历三个阶段：</p>\n<p><img src=\"https://d33wubrfki0l68.cloudfront.net/673dbafd771491a080c02c6de3fdd41b09623c90/50100/images/docs/admin/access-control-overview.svg\" alt=\"img\"></p>\n<p>身份验证通常会检查 HTTP 请求的 headers 或者客户端证书，这个阶段可以指定多个认证模块，任意模块认证成功，请求会带着认证后的 username (User or ServiceAccount) 进入下一个阶段。</p>\n<h2 id=\"认证策略\"><a href=\"#认证策略\" class=\"headerlink\" title=\"认证策略\"></a>认证策略</h2><h3 id=\"X509-Client-Certs\"><a href=\"#X509-Client-Certs\" class=\"headerlink\" title=\"X509 Client Certs\"></a>X509 Client Certs</h3><p>如果客户端提供了证书，并通过了验证，请求将会使用证书 subject 的 common name 作为用户名，kubernetes1.4 之后，客户端证书可以指定用户组，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj \"/CN=jbeda/O=app1/O=app2\"</span><br></pre></td></tr></table></figure>\n<p>认证成功后，此次请求 username 为 jbeda，groups 为 app1,app2</p>\n<h3 id=\"Static-Token-File\"><a href=\"#Static-Token-File\" class=\"headerlink\" title=\"Static Token File\"></a>Static Token File</h3><p>API Server 读取 bearer tokens 从启动参数 <code>--token-auth-file=SOMEFILE</code>  指定 csv 文件中，文件至少包含3列数据，token，用户名，用户ID，group可选。除非重启 API Server，否则 token 列表无法更改。</p>\n<p>客户端请求时，将 token 设置在请求头中<br><code>Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269</code></p>\n<h3 id=\"Bootstrap-Tokens-alpha\"><a href=\"#Bootstrap-Tokens-alpha\" class=\"headerlink\" title=\"Bootstrap Tokens  (alpha)\"></a>Bootstrap Tokens  (alpha)</h3><p>集群可以动态管理 bearer token，主要用于将节点加入现有集群，为支持 kubeadm 构建的。</p>\n<h3 id=\"Static-Password-File\"><a href=\"#Static-Password-File\" class=\"headerlink\" title=\"Static Password File\"></a>Static Password File</h3><p>和 static token file 类似，API Server 读取 <code>--basic-auth-file=SOMEFILE</code><br>csv 文件，文件至少包含3列数据，password，user，uid，gruop。除非重启 API Server，否则配置无法更改。</p>\n<p>客户端请求时，将用户名密码设置在请求头中<br><code>Authorzation: Basic base64encoded(user:password)</code></p>\n<h3 id=\"Service-Account-Tokens\"><a href=\"#Service-Account-Tokens\" class=\"headerlink\" title=\"Service Account Tokens\"></a>Service Account Tokens</h3><p>默认启用的身份验证，用 JWT 签名的 token 来验证请求，<code>--service-account-key-file</code>  可指定用于签名的 PEM key，未指定，签名将用 API Server 的 TLS private key。</p>\n<p>创建一个 Service Account，会生成一个与之关联的 Secret，Secret 里包含集群的 ca.crt ，namespace 和签名后的 token。</p>\n<p>请求时 token 设置与 bearer token 一致，放入 Authorzation 请求头中。</p>\n<p>认证后用户名为： <code>system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)</code></p>\n<h3 id=\"OpenID-Connect-Tokens\"><a href=\"#OpenID-Connect-Tokens\" class=\"headerlink\" title=\"OpenID Connect Tokens\"></a>OpenID Connect Tokens</h3><p>OAuth2 风格的认证方式，身份提供商下发 token，要启用此功能，需要配置相关参数 <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/authentication/#configuring-the-api-server\" target=\"_blank\" rel=\"noopener\">Configuring the API Server</a></p>\n<h3 id=\"Webhook-Token-Authentication\"><a href=\"#Webhook-Token-Authentication\" class=\"headerlink\" title=\"Webhook Token Authentication\"></a>Webhook Token Authentication</h3><p>当客户端请求时，webhook token authentication 将包含 token 的 JSON 序列化的对象 TokenReview POST 到远程服务</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"apiVersion\"</span>: <span class=\"string\">\"authentication.k8s.io/v1beta1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"kind\"</span>: <span class=\"string\">\"TokenReview\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"spec\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"token\"</span>: <span class=\"string\">\"(BEARERTOKEN)\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>认证成功后返回相关数据</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"apiVersion\"</span>: <span class=\"string\">\"authentication.k8s.io/v1beta1\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"kind\"</span>: <span class=\"string\">\"TokenReview\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"status\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"authenticated\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"user\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"username\"</span>: <span class=\"string\">\"janedoe@example.com\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"uid\"</span>: <span class=\"string\">\"42\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"groups\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"developers\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"qa\"</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"attr\">\"extra\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"extrafield1\"</span>: [</span><br><span class=\"line\">          <span class=\"string\">\"extravalue1\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"extravalue2\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Authenticating-Proxy\"><a href=\"#Authenticating-Proxy\" class=\"headerlink\" title=\"Authenticating Proxy\"></a>Authenticating Proxy</h3><p>API Server 可以设置从请求头识别用户信息，和代理认证服务组合使用</p>\n<h2 id=\"匿名请求\"><a href=\"#匿名请求\" class=\"headerlink\" title=\"匿名请求\"></a>匿名请求</h2><p>集群默认开启匿名请求，如果用户请求没有任何方式的身份认证，将被视为匿名请求，用户名 <code>system:anonymous</code> ，用户组 <code>system:unauthenticated</code>可以设置相关权限，方便用户访问。</p>\n<h2 id=\"用户模拟\"><a href=\"#用户模拟\" class=\"headerlink\" title=\"用户模拟\"></a>用户模拟</h2><p>用户可以通过模拟 headers 模拟另一个用户，模拟请求时，首先验证请求用户信息，是否有模拟权限，通过后再切换至模拟用户，例如，管理员可以用这种方式模拟用户调试权限授权。</p>\n<p>相关 headers </p>\n<ul>\n<li>Impersonate-User</li>\n<li>Impersonate-Group</li>\n<li>Impersonate-Extra-( extra name ) </li>\n</ul>\n<p>kubectl 可以使用 <code>--as=xxx --as-group=xxx</code>  模拟用户。</p>\n<p>要模拟用户必须要有模拟权限 <code>impersonate</code>。</p>\n","categories":[],"tags":["Kubernetes"]},{"title":"Google v8 源码编译","url":"http://localhost:4000/2018/09/04/v8-build/","content":"<p>想深入学习 Node.js 绕不开 v8，要学习 v8 那只能从编译它开始了。我是在 mac 环境下编译的，以下大部分命令都需要在翻墙状态下完成😣。</p>\n<ol>\n<li><p>下载工具 depot_tools</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=`pwd`/depot_tools:\"$PATH\"</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>检查并更新工具</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gclient</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找一个你要下载 v8 源码的目录进去后执行下面操作，时间会有点长</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch v8</span><br><span class=\"line\">cd v8</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确认你在 v8 源码目录中，通过下面命令下载所有构建依赖项</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gclient sync</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>仅在 Linux 环境下</strong>需要此操作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./build/install-build-deps.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成构建文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tools/dev/v8gen.py x64.release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置编译参数，我们需要嵌入 v8 ，需要生成静态库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gn args out.gn/x64.release</span><br><span class=\"line\"></span><br><span class=\"line\">将下面设置加入配置中</span><br><span class=\"line\">is_component_build = false</span><br><span class=\"line\">v8_static_library = true</span><br><span class=\"line\">use_custom_libcxx = false</span><br><span class=\"line\">use_custom_libcxx_for_host = false</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译源码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ninja -C out.gn/x64.release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译完成后，在 out.gn/x64.release 目录下查看编译产生的二进制文件及静态库</p>\n<p>我们需要下面一些文件来进行嵌入开发</p>\n<ul>\n<li><p>快照文件，用于加快创建 Javascript 引擎</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">natives_blob.bin</span><br><span class=\"line\">snapshot_blob.bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>静态库，位于 out.gn/x64.release/obj 目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libv8_base.a</span><br><span class=\"line\">libv8_external_snapshot.a</span><br><span class=\"line\">libv8_init.a</span><br><span class=\"line\">libv8_initializers.a</span><br><span class=\"line\">libv8_libbase.a</span><br><span class=\"line\">libv8_libplatform.a</span><br><span class=\"line\">libv8_libsampler.a</span><br><span class=\"line\">libv8_nosnapshot.a</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>icu 静态库，out.gn/x64.release/obj/third_party/icu 目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libicui18n.a</span><br><span class=\"line\">libicuuc.a</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调试库，out.gn/x64.release/obj/src/inspector 目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libinspector.a</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p>上面的流程中，任意一条命令执行有误，都有可能会导致最终编译失败，我们要注意每一条命令的输出信息。</p>\n<p>我在第七步  <code>tools/dev/v8gen.py x64.release</code> 时发生过错误，使用 <code>-vv</code>  查看具体错误信息，发现是系统没有安装  pkg-config 导致的，<code>brew install pkg-config</code> 后解决问题。</p>\n","categories":[],"tags":["v8"]},{"title":"基于 Prometheus 的监控实践","url":"http://localhost:4000/2018/06/14/prometheus/","content":"<h3 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h3><p>之前团队一直使用 APM (newrelic、tingyun等) 去监控应用的状态，分析性能，这些工具不侵入业务，不用埋点，接入简单，是非常好的系统监控解决方案。但是，有些需求是 APM 无法满足的，比如，我们需要监控各个渠道或各平台充值速率，各渠道新用户的增长等等。这种细粒度的监控能帮助我们及时发现以及定位问题，这些指标一般也统称为<strong>应用业务指标</strong>。</p>\n<p>指标采集目前比较常见的方式就是写日志，将日志通过 TCP、UDP 等方式推送到远端（ES、InfluxDB等）进行分析和绘图，虽然可以满足我们的需求，但在指标采集的粒度和维度以及查询上都不太灵活。</p>\n<p>最终我们选择使用 Prometheus ，主要是通过 pull 的方式来采集指标。</p>\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p>下图说明了 Prometheus 及其生态系统组件的一些架构，来自<a href=\"https://prometheus.io/docs/introduction/overview/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p><img src=\"https://prometheus.io/assets/architecture.svg\" alt=\"\"></p>\n<p>Prometheus 可以从配置或用服务发现获取监控目标，然后去调用目标的 /metrics 接口采集数据，将数据存储到硬盘中，采集到的数据最终有两个去向，一个是报警，一个就是可视化。</p>\n<h3 id=\"prometheus-特点\"><a href=\"#prometheus-特点\" class=\"headerlink\" title=\"prometheus 特点\"></a>prometheus 特点</h3><ul>\n<li>多维度的数据模型</li>\n<li>灵活强大的查询语句（PromQL）</li>\n<li>采用 HTTP 协议，主要使用 Pull 方式采集指标</li>\n<li>监控目标，可以采用静态配置和服务发现的方式</li>\n</ul>\n<h3 id=\"数据模型和类型\"><a href=\"#数据模型和类型\" class=\"headerlink\" title=\"数据模型和类型\"></a>数据模型和类型</h3><p>每条指标数据由 metric (指标名称)，一个或一组 label ，以及 float64 的值和毫秒级的时间戳组成。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">例子：</span><br><span class=\"line\">api_http_requests_total&#123;method=&quot;POST&quot;, handler=&quot;/messages&quot;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>metric name 需要满足正则 <code>[a-zA-Z_:][a-zA-Z0-9_:]*</code> </li>\n<li>label name 需要满足正则 <code>[a-zA-Z_][a-zA-Z0-9_]*</code></li>\n</ul>\n<p>Prometheus 客户端库目前提供了四种核心度量类型。</p>\n<h4 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h4><p>简单的计数器，不断的增加。比如监控新用户的变化，可以使用 Counter</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_user_count&#123;platform=&quot;Weixin&quot;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Gauge\"><a href=\"#Gauge\" class=\"headerlink\" title=\"Gauge\"></a>Gauge</h4><p>监控的数据是瞬时的，可以任意变高变低。比如监控 Node.js 内存使用情况</p>\n<h4 id=\"Histogram\"><a href=\"#Histogram\" class=\"headerlink\" title=\"Histogram\"></a>Histogram</h4><p>直方图对观察结果进行采样（通常是请求持续时间或响应大小等），并将其计入可配置桶中，还提供了所有观测值的总和。</p>\n<h4 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h4><p>和 Histogram 十分相似，也是对观察结果进行采样，区别是它按百分比去统计数据。比如统计 API 接口响应时间，可以使用 Summary 或者 Histogram。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_request_duration_seconds&#123;quantile=&quot;0.05&quot;,method=&quot;GET&quot;&#125; 21</span><br><span class=\"line\">http_request_duration_seconds&#123;quantile=&quot;0.5&quot;,method=&quot;GET&quot;&#125; 60</span><br><span class=\"line\">http_request_duration_seconds&#123;quantile=&quot;0.99&quot;,method=&quot;GET&quot;&#125; 80</span><br><span class=\"line\">http_request_duration_seconds_sum&#123;method=&quot;GET&quot;&#125; 600</span><br><span class=\"line\">http_request_duration_seconds_count&#123;method=&quot;GET&quot;&#125; 112</span><br></pre></td></tr></table></figure>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><p>Prometheus 提供了一个实用性的查询语言 PromQL，可以让我们实时的选择和汇总时间序列数据，它的语言表现力非常丰富，内置多种函数，满足各个维度的复杂查询。</p>\n<p>在这里简单举个例子，详细的使用参考<a href=\"https://prometheus.io/docs/prometheus/latest/querying/basics/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比如有以下一组序列数据，每条数据包含三个 label ，渠道、平台及充值类型，值为当时充值总量</span><br><span class=\"line\"></span><br><span class=\"line\">charge_order_price_count&#123;channel=&quot;ANDROID&quot;,platform=&quot;ALI&quot;,type=&quot;CHARGE&quot;&#125;\t5000</span><br><span class=\"line\">charge_order_price_count&#123;channel=&quot;ANDROID&quot;,platform=&quot;ALI&quot;,type=&quot;MONTHLY&quot;&#125;\t4000</span><br><span class=\"line\">charge_order_price_count&#123;channel=&quot;ANDROID&quot;,platform=&quot;WEIXIN&quot;,type=&quot;CHARGE&quot;&#125; 6000</span><br><span class=\"line\">charge_order_price_count&#123;channel=&quot;iOS&quot;,platform=&quot;ALI&quot;,type=&quot;CHARGE&quot;&#125; 6000</span><br><span class=\"line\">charge_order_price_count&#123;channel=&quot;iOS&quot;,platform=&quot;WEIXIN&quot;,type=&quot;MONTHLY&quot;&#125; 6000</span><br><span class=\"line\"></span><br><span class=\"line\">我们想分别统计各个渠道充值速率，可以用如下 query 语句</span><br><span class=\"line\">sum(rate(charge_order_price_count[5m])) by (channel) </span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">&#123;channel=&quot;iOS&quot;&#125;\t 12</span><br><span class=\"line\">&#123;channel=&quot;ANDROID&quot;&#125;\t25</span><br><span class=\"line\"></span><br><span class=\"line\">想统计各个平台或充值类型，使用同样语句只需要改变 by 的值就可以办到</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务发现和数据采集\"><a href=\"#服务发现和数据采集\" class=\"headerlink\" title=\"服务发现和数据采集\"></a>服务发现和数据采集</h3><p>对 API 进行监控，如果使用 Prometheus 的静态配置，当新增或下线一个实例时，由于配置列表过长，修改起来非常痛苦，极其容易导致误操作，所以从一开始我们就决定了使用 Prometheus 的服务发现。从官方文档可以发现它支持多种多样的服务发现，consul、file、dns等等，最终我们选择了使用 consul。</p>\n<p>在 API 项目暴露出 /metrics 指标采集接口，并将地址注册到 consul，在 Prometheus 里配置 consul_sd_configs 发现服务，开始采集数据，整个流程都如架构图一样的完美。</p>\n<p>然而，在采集一段时间后，发现监控数据与实际数值差异巨大，比如监控的接口 QPS 是实际的 1/16，仔细回顾了整个过程，发现遗漏一个非常重要的事情，我们 API 使用 pm2 集群模式在单个机器上部署了16个进程，共享同一个端口，Prometheus 每次扒取的数据仅仅是16个进程中的其中一个！</p>\n<p>事情变得没有刚开始想象的那么简单，解决方案想来想去貌似只有两个，一是每个进程都去聚合16个进程的指标数据，Prometheus 不管去哪个进程抓数据，拿到的都是同样的聚合后的数据。二是将每个进程都注册到 consul，Prometheus 分别去抓每个进程的数据。</p>\n<p>刚开始采用方案一，就碰到个棘手的问题，由于使用 pm2 的集群模式，导致 node 进程无法获取集群中 master 信息，进而无法进行进程间通信。幸运的是，pm2 自身提供了与子进程通信的接口，然后调整了方案一，决定编写个 pm2 的模块(<a href=\"https://github.com/redar9/pm2-cluster-prometheus\" target=\"_blank\" rel=\"noopener\">pm2-cluster-prometheus</a>)，通过模块去聚合各个进程的指标数据，并提供 /metrics 接口给 Prometheus，思路理清后发现使用 pm2 模块聚合指标比最初的方案要好很多。</p>\n<p>模块编写完成后，开始上线测试，一切也都很顺利，所有的数据都被采集到 Prometheus，结果又碰到个问题😣，根据指标使用下面查询语句计算的 API 平均延迟高于实际的，非常不准确，而且波动很大</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])</span><br></pre></td></tr></table></figure>\n<p>将近找了一天原因，发现问题出现在指标的聚合运算上，两个进程中名称同样的 Counter 类型指标，聚合时只是将值相加，由于采集值是浮点数，js 进行聚合时因为精度问题，聚合后的结果忽大忽小，最终导致计算的曲线与实际的不否。后面将采集的值调整为整数，解决数据波动问题。</p>\n<p>问题还在继续发生，上线后，随着业务的增上，需要监控的指标越来越多，pm2 模块在聚合指标时计算量越来越大，需要的内存也越来越多，为了减轻模块的压力结合领导的建议，开始考虑当初方案二的可行度，有了pm2 模块的基础，实施也就变得简单点了，pm2 模块将所有进程都注册到 cosnul 并打上 pmId 的 tag，Prometheus 通过 relabel_configs 将 pmId 增加到抓取接口请求参数中，请求到 pm2 模块的链接变为 /metrics?pm_id=1，模块根据 pm_id 到相应的进程拿到指标数据再返回。至此问题总算告一段落，后续碰到再分享给大家。</p>\n<h3 id=\"报警和可视化\"><a href=\"#报警和可视化\" class=\"headerlink\" title=\"报警和可视化\"></a>报警和可视化</h3><p>Prometheus 的报警功能主要是利用 Alertmanager 这个组件，这个组件实现了几个高级的功能，报警分组、报警抑制、报警静默，让我们可以忽视重复的、没用的、级别不高的报警，筛选出真正有用的信息。报警通知的方式也有很多中，emali、微信、slack、webhook等，目前我们使用 webhook 将报警内容发送到一个中间程序中自定义内容格式后再发送到钉钉群。</p>\n<p>可视化，基本使用的都是 Grafana，配置简单，可以做非常多定制化图表。</p>\n","categories":[],"tags":["Prometheus"]},{"title":"Golang 的 for-range 循环中指针和值的区别","url":"http://localhost:4000/2018/04/18/golang-forRang/","content":"<p>我们先看下面的一段代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> field <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *field)</span> <span class=\"title\">print</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(p.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"use values:\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tvalues := []field&#123;&#123;<span class=\"string\">\"one\"</span>&#125;, &#123;<span class=\"string\">\"two\"</span>&#125;, &#123;<span class=\"string\">\"three\"</span>&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> v.<span class=\"built_in\">print</span>()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println()</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"use pointers:\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tponiters := []*field&#123;&#123;<span class=\"string\">\"one\"</span>&#125;, &#123;<span class=\"string\">\"two\"</span>&#125;, &#123;<span class=\"string\">\"three\"</span>&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> poniters &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> v.<span class=\"built_in\">print</span>()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最近在面试过程中，经常会问面试者这道题打印的结果是什么，很多人回答出了正确的答案，但不能清晰的说明为什么会这样。在开始之前，我们可以自己先思考下上述问题的答案，然后在深入分析下具体原因。</p>\n<p>OK！我们现在知道了答案，第一个循环，控制台会打印出 three three three，因为在 goroutines 执行前，for 循环已经执行结束，变量 v 值为切片里的最后一位元素。但是第二个循环呢，如果你尝试将代码运行后，会看到打印的永远是 one two three，可能顺序不一致，但结果是这三个，为什么？</p>\n<p>在上面这两种情况下，每一次的迭代都使用了相同的变量 v ，只是每次的值不相同。在第一个循环中，v 的类型是 field ，go 声明会评估函数的参数和返回值，方法的调用可以看作方法调用者作为一个隐藏参数的函数调用，所以此时，参数被评估为 &amp;v，v.print() 其实就是 (&amp;v).print() 的简写，go 声明创建了 goroutine 将 v 的地址作为第一个参数传入函数等待调用。</p>\n<p>接着，循环将下一个元素赋值给变量 v，这里出现了 data race，goroutine 并不能保证肯定在 for 循环之后执行（第一种结果也有可能出现 two three three），虽然绝大数情况是这样，在循环中给变量 v 赋值和在 goroutine 中引用 v.name 不是同步的操作，所以产生了 data race。</p>\n<p>如果循环结束后，goroutines 才开始执行，变量 v 被赋值为数组最后一个元素，三个 goroutine 里的 &amp;v 指向同一个地址，结果为最开始所描述的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *field)</span> <span class=\"title\">print</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%p \\n\"</span>, p)  <span class=\"comment\">//将 p 的地址打印出来</span></span><br><span class=\"line\">\tfmt.Println(p.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果三次指针指向的地址相同</span></span><br><span class=\"line\">use values:</span><br><span class=\"line\"><span class=\"number\">0xc42000e1d</span>0</span><br><span class=\"line\">three</span><br><span class=\"line\"><span class=\"number\">0xc42000e1d</span>0</span><br><span class=\"line\">three</span><br><span class=\"line\"><span class=\"number\">0xc42000e1d</span>0</span><br><span class=\"line\">three</span><br></pre></td></tr></table></figure>\n<p>在第二种情况中，v 的类型是 *filed，go 声明评估参数为当前 v 的值，也就是 slice 中第一个指针，go 声明创建了 goroutine 将 v 作为第一个参数传入函数等待调用。</p>\n<p>当循环继续给变量 v 重新赋值时，没有改变任何 goroutine 中的参数引用，所以没有产生 data race，goroutines 执行后打印出 slice 中每个元素的 name。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三次指针指向不同的地址</span></span><br><span class=\"line\">use pointers:</span><br><span class=\"line\"><span class=\"number\">0xc4200ae010</span></span><br><span class=\"line\">one</span><br><span class=\"line\"><span class=\"number\">0xc4200ae020</span></span><br><span class=\"line\">two</span><br><span class=\"line\"><span class=\"number\">0xc4200ae030</span></span><br><span class=\"line\">three</span><br></pre></td></tr></table></figure>\n<p>如果第一种情况，我们确实需要将指针传入 goroutine 中，如何保证输出的结果正确呢？有两个解决的办法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, _ := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> values[i].<span class=\"built_in\">print</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时，表达式 values[i].print() 评估传入的第一个隐藏参数为 &amp;values[i]，它是一个指向 slice 底层数组元素的指针，所以每次循环指向了不同元素。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> values &#123; </span><br><span class=\"line\">    w := v </span><br><span class=\"line\">    <span class=\"keyword\">go</span> w.<span class=\"built_in\">print</span>() </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，虽然每次迭代还是重复使用了变量 v ，但是每次会创建一个新的变量 w，循环给 v 赋值，然后复制给 w，现在 go 中函数调用参数被评估为 &amp;w，因为每次迭代会创建新的 w，所以每个 goroutine 创建时复制了不同的 slice 元素作为参数进行函数调用。</p>\n","categories":[],"tags":["Golang"]},{"title":"Kubernetes 架构浅析","url":"http://localhost:4000/2018/03/23/Kubernetes-architecture/","content":"<p>最近研究了一段时间的 Kubernetes，在我们的测试环境上也搭建了一个简单的集群来学习相关的知识。月初的时候在团队做了一次 Kubernetes 架构分享，此次整理成文章记录下。</p>\n<h3 id=\"为什么要用-Kubernetes\"><a href=\"#为什么要用-Kubernetes\" class=\"headerlink\" title=\"为什么要用 Kubernetes ?\"></a>为什么要用 Kubernetes ?</h3><p>Kubernetes 作为一个容器管理平台，优点足够足够的多，在任意的相关文章中都可以看到，比如，自动化容器的部署和复制、服务发现、负载均衡、滚动更新、自动缩放等等… ，但在我看来最根本的一个理由是，IT 从来都是一个由新技术驱动的行业，况且这还是 Google 十几年以来大规模应用容器技术的经验积累和升华的一个重要成果。</p>\n<h3 id=\"Kubernetes-组件\"><a href=\"#Kubernetes-组件\" class=\"headerlink\" title=\"Kubernetes 组件\"></a>Kubernetes 组件</h3><p>为了理解 Kubernetes 的核心原理，我们先大致看下它的整体架构图，主要分为了两个大块，主节点和工作节点，每个大块又运行着不同的组件，下面我们会具体说说每个组件各自的职责。</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178480852096\" alt=\"\"></p>\n<h3 id=\"Mater-Node\"><a href=\"#Mater-Node\" class=\"headerlink\" title=\"Mater Node\"></a>Mater Node</h3><p>主节点负责管理整个 k8s 集群，是所有管理任务的入口，检测并且响应集群事件。</p>\n<h4 id=\"API-Server\"><a href=\"#API-Server\" class=\"headerlink\" title=\"API Server\"></a>API Server</h4><p>顾名思义，提供增删改查及 watch 的 API 接口，服务对象是 Kubernetes 中各类资源，如 Pod、Service 等，在图中可以看到 API Server 是整个集群内部各个功能模块之间数据交互和通信的中心枢纽，是整个系统的数据总线和数据中心。</p>\n<p>​API Server 通过一个名为 kube-apiserver 的进程提供服务，运行在 Master 节点上，默认情况下，是在本机的 8080 端口提供服务，我们也可以同时开启 HTTPS 安全端口加强接口访问的安全性。</p>\n<p>​我们通常情况下使用 kubectl ，或使用 REST 接口访问 API ，当请求到达时，会经历几个阶段，如下图中所示：</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178489225754\" alt=\"\"></p>\n<ul>\n<li><p>Authentication（身份认证）</p>\n<blockquote>\n<p>方式有很多中，可以同时指定多个模块，每个认证模块都会按顺序进行，直到其中一个成功，就会进入下一步。图中我们可以看出，k8s 的客户端有两类，一种是普通用户，一种是集群内的 Pod，虽然这种两种客户端认证机制略有不同，但无论哪一种都需要依次经历三个步骤。</p>\n</blockquote>\n<ul>\n<li><p>证书认证</p>\n</li>\n<li><p>Token 认证</p>\n</li>\n<li><p>用户名密码</p>\n</li>\n<li><p>JWT Token （用于 Service Account ）</p>\n</li>\n</ul>\n</li>\n<li><p>Authorization（授权）</p>\n<blockquote>\n<p>授权策略也支持开启多个授权插件，只要一个验证通过即可。</p>\n</blockquote>\n<ul>\n<li><p>Node  配合 NodeRestriction 准入控制限制 kubelet 访问相关资源</p>\n</li>\n<li><p>ABAC  基于属性的授权策略</p>\n</li>\n<li><p>RBAC  基于角色的授权策略</p>\n</li>\n<li><p>Webhook  通过外部提供的 HTTPS 服务进行授权</p>\n</li>\n</ul>\n</li>\n<li><p>AdmissionControl（准入控制）</p>\n<blockquote>\n<p>准入控制用来对请求做进一步的验证或添加默认参数，是一组插件列表，请求时，每个准入插件按照一定顺序执行，如果有一个拒绝了此次请求，那么请求会立即失败。</p>\n</blockquote>\n<ul>\n<li><p>ServiceAccount  为 Pod 添加相应的认证信息</p>\n</li>\n<li><p>ResourceQuota  Namespace 上的配额管理</p>\n</li>\n<li><p>LimitRanger  Pod和容器的配额管理</p>\n</li>\n<li><p>NamespaceLifecycle</p>\n</li>\n<li><p>… 其他的就不一一列举了</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>上面只是简单介绍了下 API 访问控制涉及到的一些功能模块，具体到每个里面其实还是很深的细节值得挖掘，有机会的话会单独整理一篇文章详细介绍这里的内容。</p>\n<h4 id=\"Controller-Manager\"><a href=\"#Controller-Manager\" class=\"headerlink\" title=\"Controller Manager\"></a>Controller Manager</h4><p>集群内部的管理控制中心，一系列控制器的集合，主要工作是通过 API Server 监控整个集群的状态，并确保集群处于预期的工作状态。</p>\n<p>一个典型的控制器例子就是副本控制器（Replication Controller），它主要负责控制集群中 Pod 的数量（数量由用户配置），如果发现数量超过预设值，则会销毁一些 Pod，反之，创建新的 Pod 副本。</p>\n<p>​还有个例子 Endpoint Controller，在这之前我们先看下 Service、Endpoints 与 Pod 的关系</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178495275310\" alt=\"\"></p>\n<p>如图中所示，Endpoints 表示了一个 Service 对应的所有 Pod 副本的访问地址，而 Endpoints Controller 就是负责监听 Service 和所对应 Pod 副本的变化，进而生成和维护所有 Endpoints 对象的控制器。</p>\n<p>​还有其他的控制器，比如节点控制器、命名空间控制器、配额控制器、令牌控制器等，在这里就不深入说明了。</p>\n<h4 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h4><p>Kubernetes 的调度器，核心功能是监听 API Server 来获取未绑定节点的 Pod，把它绑定到合适的节点上，然后通过 API Server 将绑定信息写入 etcd。调度原理说起来很简单，但是要编写一个优秀的调度器却不容易，有很多问题需要考虑，如何保证每个节点都能分配到资源？如何高效利用集群资源等。</p>\n<p>​Kubernetes Scheduler 当前提供的默认调度流程分为以下两步：</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178500602936\" alt=\"\"></p>\n<ol>\n<li><p>预选调度过程，即遍历所有的目标Node，筛选出符合条件的候选节点。Kubernetes 里内置了多种预选策略供用户选择。</p>\n<ul>\n<li><p>NoDiskConflict   判断 Pod 指定的 Volume 和节点上已经挂载的 Volume 是否冲突</p>\n</li>\n<li><p>PodFitsResource    判断节点的资源是否满足 Pod 的需求（内存和 CPU ）</p>\n</li>\n<li><p>PodSelectorMatches   判断节点是否包含 Pod 的标签选择器指定的标签</p>\n</li>\n<li><p>PodFitsHost   判断 Pod 指定的节点名称与备选节点名称是否一致</p>\n</li>\n<li><p>CheckNodeLabelPresence   （需要用户配置）如果节点存在此策略列出的标签时，根据配置是否选择该节点</p>\n</li>\n<li><p>CheckServiceAffinity    （需要用户配置）判断节点是否包含策略指定的标签，或包含和 Pod 同 Service 和 Namespace 下其他 Pod 所在节点的标签列表</p>\n</li>\n<li><p>PodFitsPorts    判断 Pod 所用端口是否在节点上已被占用</p>\n</li>\n</ul>\n</li>\n<li><p>确定最优节点，在第一步的基础上，采用优选策略计算出每个候选节点的积分，积分最高者胜出。</p>\n<ul>\n<li><p>LeastRequestedPriority   从备选节点列表中选出资源消耗最小的节点（内存和 CPU ）</p>\n</li>\n<li><p>BalancedResourceAllocation   从备选节点列表中选出各项资源使用率最均衡的节点</p>\n</li>\n<li><p>ImageLocalityPriority   倾向于已经有 Pod 要使用镜像的节点，镜像越大，分数越高</p>\n</li>\n<li><p>CalculateNodeLabelPriority   （需要用户配置）如果节点包含策略指定标签时，根据配置是否选择该节点</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Woker-Node\"><a href=\"#Woker-Node\" class=\"headerlink\" title=\"Woker Node\"></a>Woker Node</h3><p>Node 节点是 Kubernetes 集群中的工作负载节点，Pod 就运行在 Node 节点上。</p>\n<h4 id=\"Kubelet\"><a href=\"#Kubelet\" class=\"headerlink\" title=\"Kubelet\"></a>Kubelet</h4><p>每个节点上都会启动一个 Kubelet 服务进程，主要来处理 Master 节点下发到本节点的任务，管理 Pod 及 Pod 中的容器。还会在 API Server 上注册节点自身信息，定期像 Master 汇报节点资源使用情况。</p>\n<ul>\n<li><p>节点管理</p>\n</li>\n<li><p>Pod 管理</p>\n<p>Kubelet 通过三种方式获取自身 Node 上所要运行的 Pod 清单。</p>\n<ol>\n<li><p>文件目录，默认目录是 /etc/kubernetes/manifests/</p>\n</li>\n<li><p>HTTP接口，通过 –manifest-url 参数设置</p>\n</li>\n<li><p>API Server，监听接口，同步自身节点 Pod 目录</p>\n</li>\n</ol>\n<p>前两种情况创建的 Pod 叫做 Static Pod，不受集群管理，但是 Kubelet会将 Static Pod 状态汇报到 API Server，然后 API Server 会创建一个镜像 Pod 与之匹配，可以检测到状态变化，但并不能通过接口去修改操作它。</p>\n</li>\n<li><p>容器健康检查</p>\n<p>通过两类探针来检查容器的健康状态，一个是 LivenessProbe 探针，用于判断容器是否健康，一个是 ReadinessProbe 探针，用于判断容器是否启动完成，并准备接受请求。</p>\n</li>\n</ul>\n<h4 id=\"Kube-Proxy\"><a href=\"#Kube-Proxy\" class=\"headerlink\" title=\"Kube Proxy\"></a>Kube Proxy</h4><p>当我们在集群中创建了 Pod 后，可以获得这个 Pod ip 地址，然后在集群内部可以通过 PodIP:Port 来获取对应的服务，但是 Pod 是经常变化的，每次更新 ip 地址可能发生变化，而且水平扩展后，会有新的 Pod 被创建出来，出现新的 ip 地址，所以为了解决这个问题，Kubernetes 抽象出了 Service 的概念。</p>\n<p>​每个 Service 都有一个固定的虚拟 ip，客户端通过访问这个 ip 来访问服务，Service 则负责将请求转发到后端的 Pod 上，并且能起到负载均衡的作用。</p>\n<p>​实现 Service 这个功能的关键就是 kube-proxy，kube-proxy 通过查询和监听 API Server 中 Service 和 Endpoints 的变化，通过管理 Iptables 来实现网络的转发，所以，由于 kube-proxy 的作用，客户端无需关心后端有几个 Pod，整个通信的过程，负载均衡，水平扩展都是透明的。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>此次从整体的角度介绍了 Kubernetes 中各个组件的作用，一些深入的细节部分有机会在整理出来分享给大家。Kubernetes 各个组件没有复杂的交互，每个模块只做好自己事情，看似简单的设计却支撑着强大分布式系统有序而又稳定的工作，这种设计思想十分值得我们学习。</p>\n","categories":[],"tags":["Kubernetes"]},{"title":"关于","url":"http://localhost:4000/about/index.html","content":"<p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:&#114;&#x75;&#x69;&#x79;&#117;&#x61;&#x6e;&#46;&#119;&#x61;&#110;&#103;&#x40;&#111;&#x75;&#x74;&#x6c;&#111;&#x6f;&#x6b;&#46;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#114;&#x75;&#x69;&#x79;&#117;&#x61;&#x6e;&#46;&#119;&#x61;&#110;&#103;&#x40;&#111;&#x75;&#x74;&#x6c;&#111;&#x6f;&#x6b;&#46;&#99;&#x6f;&#109;</a></p>\n<p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/redar9\" target=\"_blank\" rel=\"noopener\">redar9</a></p>\n","categories":[],"tags":[]},{"title":"category","url":"http://localhost:4000/category/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://localhost:4000/css/personal-style.css","content":"html.page-home{\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-image: url('/images/bg.jpg');\n  background-color: transparent;\n  background-size: cover;\n  background-position: center center;\n  background-repeat: no-repeat;\n  /*background: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);*/\n  /*background-blend-mode: screen;*/\n  /*background: linear-gradient(to left, #5f2c82, #49a09d);*/\n}","categories":[],"tags":[]},{"title":"link","url":"http://localhost:4000/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://localhost:4000/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://localhost:4000/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://localhost:4000/tag/index.html","content":"","categories":[],"tags":[]}]