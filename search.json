[{"title":"Google v8 源码编译","url":"http://localhost:4000/2018/09/04/v8-build/","content":"<p>想深入学习 Node.js 绕不开 v8，要学习 v8 那只能从编译它开始了。我是在 mac 环境下编译的，以下大部分命令都需要在翻墙状态下完成😣。</p>\n<ol>\n<li><p>下载工具 depot_tools</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=`pwd`/depot_tools:\"$PATH\"</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>检查并更新工具</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gclient</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找一个你要下载 v8 源码的目录进去后执行下面操作，时间会有点长</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch v8</span><br><span class=\"line\">cd v8</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确认你在 v8 源码目录中，通过下面命令下载所有构建依赖项</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gclient sync</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>仅在 Linux 环境下</strong>需要此操作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./build/install-build-deps.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成构建文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tools/dev/v8gen.py x64.release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置编译参数，我们需要嵌入 v8 ，需要生成静态库</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gn args out.gn/x64.release</span><br><span class=\"line\"></span><br><span class=\"line\">将下面设置加入配置中</span><br><span class=\"line\">is_component_build = false</span><br><span class=\"line\">v8_static_library = true</span><br><span class=\"line\">use_custom_libcxx = false</span><br><span class=\"line\">use_custom_libcxx_for_host = false</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译源码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ninja -C out.gn/x64.release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译完成后，在 out.gn/x64.release 目录下查看编译产生的二进制文件及静态库</p>\n<p>我们需要下面一些文件来进行嵌入开发</p>\n<ul>\n<li><p>快照文件，用于加快创建 Javascript 引擎</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">natives_blob.bin</span><br><span class=\"line\">snapshot_blob.bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>静态库，位于 out.gn/x64.release/obj 目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libv8_base.a</span><br><span class=\"line\">libv8_external_snapshot.a</span><br><span class=\"line\">libv8_init.a</span><br><span class=\"line\">libv8_initializers.a</span><br><span class=\"line\">libv8_libbase.a</span><br><span class=\"line\">libv8_libplatform.a</span><br><span class=\"line\">libv8_libsampler.a</span><br><span class=\"line\">libv8_nosnapshot.a</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>icu 静态库，out.gn/x64.release/obj/third_party/icu 目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libicui18n.a</span><br><span class=\"line\">libicuuc.a</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调试库，out.gn/x64.release/obj/src/inspector 目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">libinspector.a</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p>上面的流程中，任意一条命令执行有误，都有可能会导致最终编译失败，我们要注意每一条命令的输出信息。</p>\n<p>我在第七步  <code>tools/dev/v8gen.py x64.release</code> 时发生过错误，使用 <code>-vv</code>  查看具体错误信息，发现是系统没有安装  pkg-config 导致的，<code>brew install pkg-config</code> 后解决问题。</p>\n","categories":[],"tags":["v8"]},{"title":"基于 Prometheus 的监控实践","url":"http://localhost:4000/2018/06/14/prometheus/","content":"<h3 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h3><p>之前团队一直使用 APM (newrelic、tingyun等) 去监控应用的状态，分析性能，这些工具不侵入业务，不用埋点，接入简单，是非常好的系统监控解决方案。但是，有些需求是 APM 无法满足的，比如，我们需要监控各个渠道或各平台充值速率，各渠道新用户的增长等等。这种细粒度的监控能帮助我们及时发现以及定位问题，这些指标一般也统称为<strong>应用业务指标</strong>。</p>\n<p>指标采集目前比较常见的方式就是写日志，将日志通过 TCP、UDP 等方式推送到远端（ES、InfluxDB等）进行分析和绘图，虽然可以满足我们的需求，但在指标采集的粒度和维度以及查询上都不太灵活。</p>\n<p>最终我们选择使用 Prometheus ，主要是通过 pull 的方式来采集指标。</p>\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p>下图说明了 Prometheus 及其生态系统组件的一些架构，来自<a href=\"https://prometheus.io/docs/introduction/overview/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p><img src=\"https://prometheus.io/assets/architecture.svg\" alt=\"\"></p>\n<p>Prometheus 可以从配置或用服务发现获取监控目标，然后去调用目标的 /metrics 接口采集数据，将数据存储到硬盘中，采集到的数据最终有两个去向，一个是报警，一个就是可视化。</p>\n<h3 id=\"prometheus-特点\"><a href=\"#prometheus-特点\" class=\"headerlink\" title=\"prometheus 特点\"></a>prometheus 特点</h3><ul>\n<li>多维度的数据模型</li>\n<li>灵活强大的查询语句（PromQL）</li>\n<li>采用 HTTP 协议，主要使用 Pull 方式采集指标</li>\n<li>监控目标，可以采用静态配置和服务发现的方式</li>\n</ul>\n<h3 id=\"数据模型和类型\"><a href=\"#数据模型和类型\" class=\"headerlink\" title=\"数据模型和类型\"></a>数据模型和类型</h3><p>每条指标数据由 metric (指标名称)，一个或一组 label ，以及 float64 的值和毫秒级的时间戳组成。</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">例子：</span><br><span class=\"line\">api_http_requests_total&#123;method=<span class=\"string\">\"<span class=\"keyword\">POST</span>\"</span>, handler=<span class=\"string\">\"/messages\"</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>metric name 需要满足正则 <code>[a-zA-Z_:][a-zA-Z0-9_:]*</code> </li>\n<li>label name 需要满足正则 <code>[a-zA-Z_][a-zA-Z0-9_]*</code></li>\n</ul>\n<p>Prometheus 客户端库目前提供了四种核心度量类型。</p>\n<h4 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h4><p>简单的计数器，不断的增加。比如监控新用户的变化，可以使用 Counter</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span><span class=\"type\">_user_count</span>&#123;platform=<span class=\"string\">\"Weixin\"</span>&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Gauge\"><a href=\"#Gauge\" class=\"headerlink\" title=\"Gauge\"></a>Gauge</h4><p>监控的数据是瞬时的，可以任意变高变低。比如监控 Node.js 内存使用情况</p>\n<h4 id=\"Histogram\"><a href=\"#Histogram\" class=\"headerlink\" title=\"Histogram\"></a>Histogram</h4><p>直方图对观察结果进行采样（通常是请求持续时间或响应大小等），并将其计入可配置桶中，还提供了所有观测值的总和。</p>\n<h4 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h4><p>和 Histogram 十分相似，也是对观察结果进行采样，区别是它按百分比去统计数据。比如统计 API 接口响应时间，可以使用 Summary 或者 Histogram。</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http_request_duration_seconds&#123;quantile=<span class=\"string\">\"0.05\"</span>,method=<span class=\"string\">\"<span class=\"keyword\">GET</span>\"</span>&#125; <span class=\"number\">21</span></span><br><span class=\"line\">http_request_duration_seconds&#123;quantile=<span class=\"string\">\"0.5\"</span>,method=<span class=\"string\">\"<span class=\"keyword\">GET</span>\"</span>&#125; <span class=\"number\">60</span></span><br><span class=\"line\">http_request_duration_seconds&#123;quantile=<span class=\"string\">\"0.99\"</span>,method=<span class=\"string\">\"<span class=\"keyword\">GET</span>\"</span>&#125; <span class=\"number\">80</span></span><br><span class=\"line\">http_request_duration_seconds_sum&#123;method=<span class=\"string\">\"<span class=\"keyword\">GET</span>\"</span>&#125; <span class=\"number\">600</span></span><br><span class=\"line\">http_request_duration_seconds_count&#123;method=<span class=\"string\">\"<span class=\"keyword\">GET</span>\"</span>&#125; <span class=\"number\">112</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><p>Prometheus 提供了一个实用性的查询语言 PromQL，可以让我们实时的选择和汇总时间序列数据，它的语言表现力非常丰富，内置多种函数，满足各个维度的复杂查询。</p>\n<p>在这里简单举个例子，详细的使用参考<a href=\"https://prometheus.io/docs/prometheus/latest/querying/basics/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">比如有以下一组序列数据，每条数据包含三个 label ，渠道、平台及充值类型，值为当时充值总量</span><br><span class=\"line\"></span><br><span class=\"line\">charge_order_price_count&#123;channel=<span class=\"string\">\"ANDROID\"</span>,platform=<span class=\"string\">\"ALI\"</span>,<span class=\"class\"><span class=\"keyword\">type</span></span>=<span class=\"string\">\"CHARGE\"</span>&#125;\t<span class=\"number\">5000</span></span><br><span class=\"line\">charge_order_price_count&#123;channel=<span class=\"string\">\"ANDROID\"</span>,platform=<span class=\"string\">\"ALI\"</span>,<span class=\"class\"><span class=\"keyword\">type</span></span>=<span class=\"string\">\"MONTHLY\"</span>&#125;\t<span class=\"number\">4000</span></span><br><span class=\"line\">charge_order_price_count&#123;channel=<span class=\"string\">\"ANDROID\"</span>,platform=<span class=\"string\">\"WEIXIN\"</span>,<span class=\"class\"><span class=\"keyword\">type</span></span>=<span class=\"string\">\"CHARGE\"</span>&#125; <span class=\"number\">6000</span></span><br><span class=\"line\">charge_order_price_count&#123;channel=<span class=\"string\">\"iOS\"</span>,platform=<span class=\"string\">\"ALI\"</span>,<span class=\"class\"><span class=\"keyword\">type</span></span>=<span class=\"string\">\"CHARGE\"</span>&#125; <span class=\"number\">6000</span></span><br><span class=\"line\">charge_order_price_count&#123;channel=<span class=\"string\">\"iOS\"</span>,platform=<span class=\"string\">\"WEIXIN\"</span>,<span class=\"class\"><span class=\"keyword\">type</span></span>=<span class=\"string\">\"MONTHLY\"</span>&#125; <span class=\"number\">6000</span></span><br><span class=\"line\"></span><br><span class=\"line\">我们想分别统计各个渠道充值速率，可以用如下 query 语句</span><br><span class=\"line\">sum(rate(charge_order_price_count[<span class=\"number\">5</span>m])) by (channel) </span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">&#123;channel=<span class=\"string\">\"iOS\"</span>&#125;\t <span class=\"number\">12</span></span><br><span class=\"line\">&#123;channel=<span class=\"string\">\"ANDROID\"</span>&#125;\t<span class=\"number\">25</span></span><br><span class=\"line\"></span><br><span class=\"line\">想统计各个平台或充值类型，使用同样语句只需要改变 by 的值就可以办到</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务发现和数据采集\"><a href=\"#服务发现和数据采集\" class=\"headerlink\" title=\"服务发现和数据采集\"></a>服务发现和数据采集</h3><p>对 API 进行监控，如果使用 Prometheus 的静态配置，当新增或下线一个实例时，由于配置列表过长，修改起来非常痛苦，极其容易导致误操作，所以从一开始我们就决定了使用 Prometheus 的服务发现。从官方文档可以发现它支持多种多样的服务发现，consul、file、dns等等，最终我们选择了使用 consul。</p>\n<p>在 API 项目暴露出 /metrics 指标采集接口，并将地址注册到 consul，在 Prometheus 里配置 consul_sd_configs 发现服务，开始采集数据，整个流程都如架构图一样的完美。</p>\n<p>然而，在采集一段时间后，发现监控数据与实际数值差异巨大，比如监控的接口 QPS 是实际的 1/16，仔细回顾了整个过程，发现遗漏一个非常重要的事情，我们 API 使用 pm2 集群模式在单个机器上部署了16个进程，共享同一个端口，Prometheus 每次扒取的数据仅仅是16个进程中的其中一个！</p>\n<p>事情变得没有刚开始想象的那么简单，解决方案想来想去貌似只有两个，一是每个进程都去聚合16个进程的指标数据，Prometheus 不管去哪个进程抓数据，拿到的都是同样的聚合后的数据。二是将每个进程都注册到 consul，Prometheus 分别去抓每个进程的数据。</p>\n<p>刚开始采用方案一，就碰到个棘手的问题，由于使用 pm2 的集群模式，导致 node 进程无法获取集群中 master 信息，进而无法进行进程间通信。幸运的是，pm2 自身提供了与子进程通信的接口，然后调整了方案一，决定编写个 pm2 的模块(<a href=\"https://github.com/redar9/pm2-cluster-prometheus\" target=\"_blank\" rel=\"noopener\">pm2-cluster-prometheus</a>)，通过模块去聚合各个进程的指标数据，并提供 /metrics 接口给 Prometheus，思路理清后发现使用 pm2 模块聚合指标比最初的方案要好很多。</p>\n<p>模块编写完成后，开始上线测试，一切也都很顺利，所有的数据都被采集到 Prometheus，结果又碰到个问题😣，根据指标使用下面查询语句计算的 API 平均延迟高于实际的，非常不准确，而且波动很大</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rate(<span class=\"name\">http_request_duration_seconds_sum</span>[<span class=\"number\">5</span>m]) / rate(<span class=\"name\">http_request_duration_seconds_count</span>[<span class=\"number\">5</span>m])</span><br></pre></td></tr></table></figure>\n<p>将近找了一天原因，发现问题出现在指标的聚合运算上，两个进程中名称同样的 Counter 类型指标，聚合时只是将值相加，由于采集值是浮点数，js 进行聚合时因为精度问题，聚合后的结果忽大忽小，最终导致计算的曲线与实际的不否。后面将采集的值调整为整数，解决数据波动问题。</p>\n<p>问题还在继续发生，上线后，随着业务的增上，需要监控的指标越来越多，pm2 模块在聚合指标时计算量越来越大，需要的内存也越来越多，为了减轻模块的压力结合领导的建议，开始考虑当初方案二的可行度，有了pm2 模块的基础，实施也就变得简单点了，pm2 模块将所有进程都注册到 cosnul 并打上 pmId 的 tag，Prometheus 通过 relabel_configs 将 pmId 增加到抓取接口请求参数中，请求到 pm2 模块的链接变为 /metrics?pm_id=1，模块根据 pm_id 到相应的进程拿到指标数据再返回。至此问题总算告一段落，后续碰到再分享给大家。</p>\n<h3 id=\"报警和可视化\"><a href=\"#报警和可视化\" class=\"headerlink\" title=\"报警和可视化\"></a>报警和可视化</h3><p>Prometheus 的报警功能主要是利用 Alertmanager 这个组件，这个组件实现了几个高级的功能，报警分组、报警抑制、报警静默，让我们可以忽视重复的、没用的、级别不高的报警，筛选出真正有用的信息。报警通知的方式也有很多中，emali、微信、slack、webhook等，目前我们使用 webhook 将报警内容发送到一个中间程序中自定义内容格式后再发送到钉钉群。</p>\n<p>可视化，基本使用的都是 Grafana，配置简单，可以做非常多定制化图表。</p>\n","categories":[],"tags":["Prometheus"]},{"title":"Golang 的 for-range 循环中指针和值的区别","url":"http://localhost:4000/2018/04/18/golang-forRang/","content":"<p>我们先看下面的一段代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> field <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *field)</span> <span class=\"title\">print</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(p.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"use values:\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tvalues := []field&#123;&#123;<span class=\"string\">\"one\"</span>&#125;, &#123;<span class=\"string\">\"two\"</span>&#125;, &#123;<span class=\"string\">\"three\"</span>&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> v.<span class=\"built_in\">print</span>()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println()</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"use pointers:\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tponiters := []*field&#123;&#123;<span class=\"string\">\"one\"</span>&#125;, &#123;<span class=\"string\">\"two\"</span>&#125;, &#123;<span class=\"string\">\"three\"</span>&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> poniters &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> v.<span class=\"built_in\">print</span>()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最近在面试过程中，经常会问面试者这道题打印的结果是什么，很多人回答出了正确的答案，但不能清晰的说明为什么会这样。在开始之前，我们可以自己先思考下上述问题的答案，然后在深入分析下具体原因。</p>\n<p>OK！我们现在知道了答案，第一个循环，控制台会打印出 three three three，因为在 goroutines 执行前，for 循环已经执行结束，变量 v 值为切片里的最后一位元素。但是第二个循环呢，如果你尝试将代码运行后，会看到打印的永远是 one two three，可能顺序不一致，但结果是这三个，为什么？</p>\n<p>在上面这两种情况下，每一次的迭代都使用了相同的变量 v ，只是每次的值不相同。在第一个循环中，v 的类型是 field ，go 声明会评估函数的参数和返回值，方法的调用可以看作方法调用者作为一个隐藏参数的函数调用，所以此时，参数被评估为 &amp;v，v.print() 其实就是 (&amp;v).print() 的简写，go 声明创建了 goroutine 将 v 的地址作为第一个参数传入函数等待调用。</p>\n<p>接着，循环将下一个元素赋值给变量 v，这里出现了 data race，goroutine 并不能保证肯定在 for 循环之后执行（第一种结果也有可能出现 two three three），虽然绝大数情况是这样，在循环中给变量 v 赋值和在 goroutine 中引用 v.name 不是同步的操作，所以产生了 data race。</p>\n<p>如果循环结束后，goroutines 才开始执行，变量 v 被赋值为数组最后一个元素，三个 goroutine 里的 &amp;v 指向同一个地址，结果为最开始所描述的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *field)</span> <span class=\"title\">print</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"%p \\n\"</span>, p)  <span class=\"comment\">//将 p 的地址打印出来</span></span><br><span class=\"line\">\tfmt.Println(p.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果三次指针指向的地址相同</span></span><br><span class=\"line\">use values:</span><br><span class=\"line\"><span class=\"number\">0xc42000e1d</span>0</span><br><span class=\"line\">three</span><br><span class=\"line\"><span class=\"number\">0xc42000e1d</span>0</span><br><span class=\"line\">three</span><br><span class=\"line\"><span class=\"number\">0xc42000e1d</span>0</span><br><span class=\"line\">three</span><br></pre></td></tr></table></figure>\n<p>在第二种情况中，v 的类型是 *filed，go 声明评估参数为当前 v 的值，也就是 slice 中第一个指针，go 声明创建了 goroutine 将 v 作为第一个参数传入函数等待调用。</p>\n<p>当循环继续给变量 v 重新赋值时，没有改变任何 goroutine 中的参数引用，所以没有产生 data race，goroutines 执行后打印出 slice 中每个元素的 name。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三次指针指向不同的地址</span></span><br><span class=\"line\">use pointers:</span><br><span class=\"line\"><span class=\"number\">0xc4200ae010</span></span><br><span class=\"line\">one</span><br><span class=\"line\"><span class=\"number\">0xc4200ae020</span></span><br><span class=\"line\">two</span><br><span class=\"line\"><span class=\"number\">0xc4200ae030</span></span><br><span class=\"line\">three</span><br></pre></td></tr></table></figure>\n<p>如果第一种情况，我们确实需要将指针传入 goroutine 中，如何保证输出的结果正确呢？有两个解决的办法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, _ := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> values[i].<span class=\"built_in\">print</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时，表达式 values[i].print() 评估传入的第一个隐藏参数为 &amp;values[i]，它是一个指向 slice 底层数组元素的指针，所以每次循环指向了不同元素。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> values &#123; </span><br><span class=\"line\">    w := v </span><br><span class=\"line\">    <span class=\"keyword\">go</span> w.<span class=\"built_in\">print</span>() </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，虽然每次迭代还是重复使用了变量 v ，但是每次会创建一个新的变量 w，循环给 v 赋值，然后复制给 w，现在 go 中函数调用参数被评估为 &amp;w，因为每次迭代会创建新的 w，所以每个 goroutine 创建时复制了不同的 slice 元素作为参数进行函数调用。</p>\n","categories":[],"tags":["Golang"]},{"title":"Kubernetes 架构浅析","url":"http://localhost:4000/2018/03/23/Kubernetes-architecture/","content":"<p>最近研究了一段时间的 Kubernetes，在我们的测试环境上也搭建了一个简单的集群来学习相关的知识。月初的时候在团队做了一次 Kubernetes 架构分享，此次整理成文章记录下。</p>\n<h3 id=\"为什么要用-Kubernetes\"><a href=\"#为什么要用-Kubernetes\" class=\"headerlink\" title=\"为什么要用 Kubernetes ?\"></a>为什么要用 Kubernetes ?</h3><p>Kubernetes 作为一个容器管理平台，优点足够足够的多，在任意的相关文章中都可以看到，比如，自动化容器的部署和复制、服务发现、负载均衡、滚动更新、自动缩放等等… ，但在我看来最根本的一个理由是，IT 从来都是一个由新技术驱动的行业，况且这还是 Google 十几年以来大规模应用容器技术的经验积累和升华的一个重要成果。</p>\n<h3 id=\"Kubernetes-组件\"><a href=\"#Kubernetes-组件\" class=\"headerlink\" title=\"Kubernetes 组件\"></a>Kubernetes 组件</h3><p>为了理解 Kubernetes 的核心原理，我们先大致看下它的整体架构图，主要分为了两个大块，主节点和工作节点，每个大块又运行着不同的组件，下面我们会具体说说每个组件各自的职责。</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178480852096\" alt=\"\"></p>\n<h3 id=\"Mater-Node\"><a href=\"#Mater-Node\" class=\"headerlink\" title=\"Mater Node\"></a>Mater Node</h3><p>主节点负责管理整个 k8s 集群，是所有管理任务的入口，检测并且响应集群事件。</p>\n<h4 id=\"API-Server\"><a href=\"#API-Server\" class=\"headerlink\" title=\"API Server\"></a>API Server</h4><p>顾名思义，提供增删改查及 watch 的 API 接口，服务对象是 Kubernetes 中各类资源，如 Pod、Service 等，在图中可以看到 API Server 是整个集群内部各个功能模块之间数据交互和通信的中心枢纽，是整个系统的数据总线和数据中心。</p>\n<p>​API Server 通过一个名为 kube-apiserver 的进程提供服务，运行在 Master 节点上，默认情况下，是在本机的 8080 端口提供服务，我们也可以同时开启 HTTPS 安全端口加强接口访问的安全性。</p>\n<p>​我们通常情况下使用 kubectl ，或使用 REST 接口访问 API ，当请求到达时，会经历几个阶段，如下图中所示：</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178489225754\" alt=\"\"></p>\n<ul>\n<li><p>Authentication（身份认证）</p>\n<blockquote>\n<p>方式有很多中，可以同时指定多个模块，每个认证模块都会按顺序进行，直到其中一个成功，就会进入下一步。图中我们可以看出，k8s 的客户端有两类，一种是普通用户，一种是集群内的 Pod，虽然这种两种客户端认证机制略有不同，但无论哪一种都需要依次经历三个步骤。</p>\n</blockquote>\n<ul>\n<li><p>证书认证</p>\n</li>\n<li><p>Token 认证</p>\n</li>\n<li><p>用户名密码</p>\n</li>\n<li><p>JWT Token （用于 Service Account ）</p>\n</li>\n</ul>\n</li>\n<li><p>Authorization（授权）</p>\n<blockquote>\n<p>授权策略也支持开启多个授权插件，只要一个验证通过即可。</p>\n</blockquote>\n<ul>\n<li><p>Node  配合 NodeRestriction 准入控制限制 kubelet 访问相关资源</p>\n</li>\n<li><p>ABAC  基于属性的授权策略</p>\n</li>\n<li><p>RBAC  基于角色的授权策略</p>\n</li>\n<li><p>Webhook  通过外部提供的 HTTPS 服务进行授权</p>\n</li>\n</ul>\n</li>\n<li><p>AdmissionControl（准入控制）</p>\n<blockquote>\n<p>准入控制用来对请求做进一步的验证或添加默认参数，是一组插件列表，请求时，每个准入插件按照一定顺序执行，如果有一个拒绝了此次请求，那么请求会立即失败。</p>\n</blockquote>\n<ul>\n<li><p>ServiceAccount  为 Pod 添加相应的认证信息</p>\n</li>\n<li><p>ResourceQuota  Namespace 上的配额管理</p>\n</li>\n<li><p>LimitRanger  Pod和容器的配额管理</p>\n</li>\n<li><p>NamespaceLifecycle</p>\n</li>\n<li><p>… 其他的就不一一列举了</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>上面只是简单介绍了下 API 访问控制涉及到的一些功能模块，具体到每个里面其实还是很深的细节值得挖掘，有机会的话会单独整理一篇文章详细介绍这里的内容。</p>\n<h4 id=\"Controller-Manager\"><a href=\"#Controller-Manager\" class=\"headerlink\" title=\"Controller Manager\"></a>Controller Manager</h4><p>集群内部的管理控制中心，一系列控制器的集合，主要工作是通过 API Server 监控整个集群的状态，并确保集群处于预期的工作状态。</p>\n<p>一个典型的控制器例子就是副本控制器（Replication Controller），它主要负责控制集群中 Pod 的数量（数量由用户配置），如果发现数量超过预设值，则会销毁一些 Pod，反之，创建新的 Pod 副本。</p>\n<p>​还有个例子 Endpoint Controller，在这之前我们先看下 Service、Endpoints 与 Pod 的关系</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178495275310\" alt=\"\"></p>\n<p>如图中所示，Endpoints 表示了一个 Service 对应的所有 Pod 副本的访问地址，而 Endpoints Controller 就是负责监听 Service 和所对应 Pod 副本的变化，进而生成和维护所有 Endpoints 对象的控制器。</p>\n<p>​还有其他的控制器，比如节点控制器、命名空间控制器、配额控制器、令牌控制器等，在这里就不深入说明了。</p>\n<h4 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h4><p>Kubernetes 的调度器，核心功能是监听 API Server 来获取未绑定节点的 Pod，把它绑定到合适的节点上，然后通过 API Server 将绑定信息写入 etcd。调度原理说起来很简单，但是要编写一个优秀的调度器却不容易，有很多问题需要考虑，如何保证每个节点都能分配到资源？如何高效利用集群资源等。</p>\n<p>​Kubernetes Scheduler 当前提供的默认调度流程分为以下两步：</p>\n<p><img src=\"http://statics.zhuishushenqi.com/post/152178500602936\" alt=\"\"></p>\n<ol>\n<li><p>预选调度过程，即遍历所有的目标Node，筛选出符合条件的候选节点。Kubernetes 里内置了多种预选策略供用户选择。</p>\n<ul>\n<li><p>NoDiskConflict   判断 Pod 指定的 Volume 和节点上已经挂载的 Volume 是否冲突</p>\n</li>\n<li><p>PodFitsResource    判断节点的资源是否满足 Pod 的需求（内存和 CPU ）</p>\n</li>\n<li><p>PodSelectorMatches   判断节点是否包含 Pod 的标签选择器指定的标签</p>\n</li>\n<li><p>PodFitsHost   判断 Pod 指定的节点名称与备选节点名称是否一致</p>\n</li>\n<li><p>CheckNodeLabelPresence   （需要用户配置）如果节点存在此策略列出的标签时，根据配置是否选择该节点</p>\n</li>\n<li><p>CheckServiceAffinity    （需要用户配置）判断节点是否包含策略指定的标签，或包含和 Pod 同 Service 和 Namespace 下其他 Pod 所在节点的标签列表</p>\n</li>\n<li><p>PodFitsPorts    判断 Pod 所用端口是否在节点上已被占用</p>\n</li>\n</ul>\n</li>\n<li><p>确定最优节点，在第一步的基础上，采用优选策略计算出每个候选节点的积分，积分最高者胜出。</p>\n<ul>\n<li><p>LeastRequestedPriority   从备选节点列表中选出资源消耗最小的节点（内存和 CPU ）</p>\n</li>\n<li><p>BalancedResourceAllocation   从备选节点列表中选出各项资源使用率最均衡的节点</p>\n</li>\n<li><p>ImageLocalityPriority   倾向于已经有 Pod 要使用镜像的节点，镜像越大，分数越高</p>\n</li>\n<li><p>CalculateNodeLabelPriority   （需要用户配置）如果节点包含策略指定标签时，根据配置是否选择该节点</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Woker-Node\"><a href=\"#Woker-Node\" class=\"headerlink\" title=\"Woker Node\"></a>Woker Node</h3><p>Node 节点是 Kubernetes 集群中的工作负载节点，Pod 就运行在 Node 节点上。</p>\n<h4 id=\"Kubelet\"><a href=\"#Kubelet\" class=\"headerlink\" title=\"Kubelet\"></a>Kubelet</h4><p>每个节点上都会启动一个 Kubelet 服务进程，主要来处理 Master 节点下发到本节点的任务，管理 Pod 及 Pod 中的容器。还会在 API Server 上注册节点自身信息，定期像 Master 汇报节点资源使用情况。</p>\n<ul>\n<li><p>节点管理</p>\n</li>\n<li><p>Pod 管理</p>\n<p>Kubelet 通过三种方式获取自身 Node 上所要运行的 Pod 清单。</p>\n<ol>\n<li><p>文件目录，默认目录是 /etc/kubernetes/manifests/</p>\n</li>\n<li><p>HTTP接口，通过 –manifest-url 参数设置</p>\n</li>\n<li><p>API Server，监听接口，同步自身节点 Pod 目录</p>\n</li>\n</ol>\n<p>前两种情况创建的 Pod 叫做 Static Pod，不受集群管理，但是 Kubelet会将 Static Pod 状态汇报到 API Server，然后 API Server 会创建一个镜像 Pod 与之匹配，可以检测到状态变化，但并不能通过接口去修改操作它。</p>\n</li>\n<li><p>容器健康检查</p>\n<p>通过两类探针来检查容器的健康状态，一个是 LivenessProbe 探针，用于判断容器是否健康，一个是 ReadinessProbe 探针，用于判断容器是否启动完成，并准备接受请求。</p>\n</li>\n</ul>\n<h4 id=\"Kube-Proxy\"><a href=\"#Kube-Proxy\" class=\"headerlink\" title=\"Kube Proxy\"></a>Kube Proxy</h4><p>当我们在集群中创建了 Pod 后，可以获得这个 Pod ip 地址，然后在集群内部可以通过 PodIP:Port 来获取对应的服务，但是 Pod 是经常变化的，每次更新 ip 地址可能发生变化，而且水平扩展后，会有新的 Pod 被创建出来，出现新的 ip 地址，所以为了解决这个问题，Kubernetes 抽象出了 Service 的概念。</p>\n<p>​每个 Service 都有一个固定的虚拟 ip，客户端通过访问这个 ip 来访问服务，Service 则负责将请求转发到后端的 Pod 上，并且能起到负载均衡的作用。</p>\n<p>​实现 Service 这个功能的关键就是 kube-proxy，kube-proxy 通过查询和监听 API Server 中 Service 和 Endpoints 的变化，通过管理 Iptables 来实现网络的转发，所以，由于 kube-proxy 的作用，客户端无需关心后端有几个 Pod，整个通信的过程，负载均衡，水平扩展都是透明的。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>此次从整体的角度介绍了 Kubernetes 中各个组件的作用，一些深入的细节部分有机会在整理出来分享给大家。Kubernetes 各个组件没有复杂的交互，每个模块只做好自己事情，看似简单的设计却支撑着强大分布式系统有序而又稳定的工作，这种设计思想十分值得我们学习。</p>\n","categories":[],"tags":["Kubernetes"]},{"title":"关于","url":"http://localhost:4000/about/index.html","content":"<p><i class=\"fa fa-envelope\"></i> Email: <a href=\"mailto:&#x72;&#x75;&#x69;&#121;&#117;&#x61;&#110;&#x2e;&#x77;&#97;&#110;&#103;&#x40;&#111;&#x75;&#x74;&#x6c;&#111;&#111;&#x6b;&#x2e;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x72;&#x75;&#x69;&#121;&#117;&#x61;&#110;&#x2e;&#x77;&#97;&#110;&#103;&#x40;&#111;&#x75;&#x74;&#x6c;&#111;&#111;&#x6b;&#x2e;&#x63;&#x6f;&#109;</a></p>\n<p><i class=\"fa fa-github\"></i> Github: <a href=\"https://github.com/redar9\" target=\"_blank\" rel=\"noopener\">redar9</a></p>\n","categories":[],"tags":[]},{"title":"category","url":"http://localhost:4000/category/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://localhost:4000/css/personal-style.css","content":"html.page-home{\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-image: url('/images/bg.jpg');\n  background-color: transparent;\n  background-size: cover;\n  background-position: center center;\n  background-repeat: no-repeat;\n  /*background: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);*/\n  /*background-blend-mode: screen;*/\n  /*background: linear-gradient(to left, #5f2c82, #49a09d);*/\n}","categories":[],"tags":[]},{"title":"link","url":"http://localhost:4000/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://localhost:4000/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://localhost:4000/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://localhost:4000/tag/index.html","content":"","categories":[],"tags":[]}]