<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Node.js Golang DevOps"><title>Golang 源码阅读 - 内存管理 | Ryan's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Golang 源码阅读 - 内存管理</h1><a id="logo" href="/.">Ryan's Blog</a><p class="description">Whole life learning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Golang 源码阅读 - 内存管理</h1><div class="post-meta">Mar 8, 2019</div><a class="disqus-comment-count" data-disqus-identifier="2019/03/08/go-memory/" href="/2019/03/08/go-memory/#disqus_thread"></a><div class="post-content"><p>Go 语言的内存分配算法来自 <code>TCMalloc</code> ，核心的思想就是把内存分为多级管理，从而降低锁的粒度和内存碎片的数量。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Golang 里的堆栈内存和传统意义的堆栈不太相同，传统意义上栈被 Go 的运行时霸占，不对用户代码开放，而传动意义上的堆内存被 Go 分成两个部分，一个是 Go 运行时自身需要的堆内存，称为堆外内存，一个是用于用户代码使用的堆内存，称为 Go 堆。Go 堆负责了用户对象的存放和 goroutine 的执行栈。</p>
<p>Go 在1.11后修改了内存布局，由一系列 <code>arena</code> 组成，这些 <code>arena</code> 合起来就是我们所说的 Go 堆，Go 程序还在堆外分配一个二维数组，里面存放了每个 <code>arena</code> 的元数据，分别指向了对应的堆地址空间，数组的维度和 <code>arena</code> 的大小与寻址的 bit 位数有关。</p>
<p>比如在Linux 64位机器上，使用 48 位地址寻址，单个 <code>arena</code> 的大小为 64M，L1的数量通常为1，根据公式可得出 L2 的数量为 2^22</p>
<blockquote>
<p>(1 &lt;&lt; addr bits) = arena size <em> L1 entries </em> L2 entries</p>
</blockquote>
<p>二维数组的元素表示为 <code>heapArena</code>，里面包含了 <code>bitmap</code> 及 <code>spans</code></p>
<p><code>bitmap</code> 区域一个 byte 对应 <code>arena</code> 4个指针大小（32 byte），每 4 个 bit 位用来表示对应的 <code>arena</code> 地址对象是否包含指针和有没有被 GC 标记过。</p>
<p><code>spans</code> 区域存放着 <code>mspan</code> 的指针，每个指针对应一页，Golang 中一页大小为 8K，假如一个 <code>mspan</code> 有三页，那这三页对应的 <code>spans</code> 区域都为同一个 <code>mspan</code> 指针，主要用于回收对象时根据地址反查所属的 <code>mspan</code>。</p>
<h4 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h4><p><code>mspan</code> 是 Go 中内存管理的基本单元，由一组连续的页组成，里面包含了页的起始地址，规格和数量等内容。它会根据自身的属性 <code>spanclass</code> 声明自己可以存储多少个对象及每个对象的大小。在 Go 中 <code>mspan</code> 的种类共计 67  种，称为 <code>sizeclass</code> ，<code>spanclass</code> 与之对应关系为 <code>sizeclass = spanclass / 2</code>，是它的两倍表示同一个 <code>sizeclass</code> 会有两个 <code>spanclass</code> ，一个分配含有指针的对象，一个分配不含指针的对象，方便后续 GC 操作。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _NumSizeClasses = <span class="number">67</span></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="keyword">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>, <span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> class_to_allocnpages = [_NumSizeClasses]<span class="keyword">uint8</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<p>比如一个 <code>mspan</code> 的 <code>spanclass</code> 为 8，得到它的 <code>sizeclass</code> 为 4，在 <code>class_to_size</code> 中可以看到它存储的对象大小为 48B，在 <code>class_to_allocnpages</code> 得到它的页数为 1 个，那么能存储的对象个数为 8K / 48B = 170 个。</p>
<p>这里面最大的对象是 32K，超过 32K 的对象称为大对象，对其分配是会进行特殊处理，对应的 <code>spanclass</code> 为 0</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">	next *mspan  </span><br><span class="line">	prev *mspan     </span><br><span class="line">	startAddr <span class="keyword">uintptr</span>      <span class="comment">// 起始地址，指向第一个页</span></span><br><span class="line">	npages    <span class="keyword">uintptr</span>      <span class="comment">// 页的数量</span></span><br><span class="line">  </span><br><span class="line">	freeindex <span class="keyword">uintptr</span>      <span class="comment">// 标记已经分配到的位置</span></span><br><span class="line">	nelems <span class="keyword">uintptr</span>         <span class="comment">// 块的个数，表示可分配多少个对象</span></span><br><span class="line">	allocCache <span class="keyword">uint64</span>      <span class="comment">// allocBits的缓存，从freeindex开始</span></span><br><span class="line"></span><br><span class="line">	allocBits  *gcBits     <span class="comment">// 标记块是否被分配对象</span></span><br><span class="line">	gcmarkBits *gcBits     <span class="comment">// 标记对象是否被 GC mark</span></span><br><span class="line"></span><br><span class="line">	allocCount  <span class="keyword">uint16</span>     <span class="comment">// 已分配的块数</span></span><br><span class="line">	spanclass   spanClass  <span class="comment">// class id</span></span><br><span class="line">	elemsize    <span class="keyword">uintptr</span>    <span class="comment">// 对象大小，也就是块的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> spanClass <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 spanClass 获取 sizeclass</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc spanClass)</span> <span class="title">sizeclass</span><span class="params">()</span> <span class="title">int8</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int8</span>(sc &gt;&gt; <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回 spanClass 是否需要扫描，也就是是否分配包含指针的对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc spanClass)</span> <span class="title">noscan</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> sc&amp;<span class="number">1</span> != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h4><p>每个工作线程 M 都会绑定一个 <code>mcache</code> ，里面缓存着可用的 <code>mspan</code> ，这样的好处是在一个线程上没有竞争，可以直接给 goroutine 分配内存而无需加锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 包含所有种类的 mspan，每个种类分两种，共计 134 个</span></span><br><span class="line">  <span class="comment">// [0_scan,0_noscan,1_scan,1_noscan,....]</span></span><br><span class="line">	alloc [numSpanClasses]*mspan</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mcache</code> 在初始化时是没任何 <code>mspan</code> 的，是在使用过程中动态的从 <code>mcentral</code> 中申请，之后缓存下来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">refill</span><span class="params">(spc spanClass)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Return the current cached span to the central lists.</span></span><br><span class="line">	s := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保当前的span所有元素都已分配</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">		throw(<span class="string">"refill of span with free space remaining"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">		<span class="comment">// Mark this span as no longer cached.</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen != mheap_.sweepgen+<span class="number">3</span> &#123;</span><br><span class="line">			throw(<span class="string">"bad sweepgen in refill"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		atomic.Store(&amp;s.sweepgen, mheap_.sweepgen)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向 mcentral 申请一个新的span</span></span><br><span class="line">	s = mheap_.central[spc].mcentral.cacheSpan()</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"out of memory"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">		throw(<span class="string">"span has no free space"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.sweepgen = mheap_.sweepgen + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	c.alloc[spc] = s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h4><p>为所有的 <code>mcache</code> 提供切分好的 <code>mspan</code> ，每个 <code>mcentral</code> 都保存着两个特定类型的全局 <code>mspan</code> 链表。总共有 134 个 <code>mcentral</code> 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock      mutex      <span class="comment">// 全局对象，互斥锁</span></span><br><span class="line">	spanclass spanClass </span><br><span class="line">	nonempty  mSpanList  <span class="comment">// 可用的 mspan 链表</span></span><br><span class="line">	empty     mSpanList  <span class="comment">// 没有空闲对象或已被 mcache 缓存的 mspan 链表</span></span><br><span class="line">	nmalloc <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如需要分配内存时，<code>mcentral</code> 没有可用的 <code>mspan</code> ，此时需要向 <code>mheap</code> 去申请，具体分配逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span> <span class="title">cacheSpan</span><span class="params">()</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	<span class="comment">// 分配时，会让当前的 goroutine 协助一部分 sweep 工作</span></span><br><span class="line">	spanBytes := <span class="keyword">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize</span><br><span class="line">	deductSweepCredit(spanBytes, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	sg := mheap_.sweepgen</span><br><span class="line">  <span class="comment">// sweepgen每次GC都会增加2</span></span><br><span class="line">  <span class="comment">// - sweepgen == 全局sweepgen, 表示span已经sweep过</span></span><br><span class="line">  <span class="comment">// - sweepgen == 全局sweepgen-1, 表示span正在sweep</span></span><br><span class="line">  <span class="comment">// - sweepgen == 全局sweepgen-2, 表示span等待sweep</span></span><br><span class="line">  </span><br><span class="line">retry:</span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">  <span class="comment">// 优先查找 nonempty 链表</span></span><br><span class="line">	<span class="keyword">for</span> s = c.nonempty.first; s != <span class="literal">nil</span>; s = s.next &#123;</span><br><span class="line">    <span class="comment">// 如果 span 等待 sweep，尝试修改状态为 sg-1</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 成功后把它添加到 empty 链表尾部，跳转至 havespan</span></span><br><span class="line">			c.nonempty.remove(s)</span><br><span class="line">			c.empty.insertBack(s)</span><br><span class="line">			unlock(&amp;c.lock)</span><br><span class="line">			s.sweep(<span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">goto</span> havespan</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="comment">// 正在被其他线程 sweep，跳过</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 可以直接使用</span></span><br><span class="line">		c.nonempty.remove(s)</span><br><span class="line">		c.empty.insertBack(s)</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">goto</span> havespan</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找 empty 链表</span></span><br><span class="line">	<span class="keyword">for</span> s = c.empty.first; s != <span class="literal">nil</span>; s = s.next &#123;</span><br><span class="line">    <span class="comment">// 如果 span 等待 sweep，尝试修改状态为 sg-1</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">// 修改成功，移动至链表尾部</span></span><br><span class="line">			c.empty.remove(s)</span><br><span class="line">			c.empty.insertBack(s)</span><br><span class="line">			unlock(&amp;c.lock)</span><br><span class="line">			s.sweep(<span class="literal">true</span>)</span><br><span class="line">      <span class="comment">// 检查是否有空闲位置</span></span><br><span class="line">			freeIndex := s.nextFreeIndex()</span><br><span class="line">			<span class="keyword">if</span> freeIndex != s.nelems &#123;</span><br><span class="line">				s.freeindex = freeIndex</span><br><span class="line">				<span class="keyword">goto</span> havespan</span><br><span class="line">			&#125;</span><br><span class="line">			lock(&amp;c.lock)</span><br><span class="line">			<span class="keyword">goto</span> retry</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 未找到 span，向 mheap 申请</span></span><br><span class="line">	s = c.grow()</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	c.empty.insertBack(s)</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">havespan:</span><br><span class="line"></span><br><span class="line">	n := <span class="keyword">int</span>(s.nelems) - <span class="keyword">int</span>(s.allocCount)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> || s.freeindex == s.nelems || <span class="keyword">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">		throw(<span class="string">"span has no free objects"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	atomic.Xadd64(&amp;c.nmalloc, <span class="keyword">int64</span>(n))</span><br><span class="line">	usedBytes := <span class="keyword">uintptr</span>(s.allocCount) * s.elemsize</span><br><span class="line">	atomic.Xadd64(&amp;memstats.heap_live, <span class="keyword">int64</span>(spanBytes)-<span class="keyword">int64</span>(usedBytes))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// heap_live changed.</span></span><br><span class="line">		gcController.revise()</span><br><span class="line">	&#125;</span><br><span class="line">	freeByteBase := s.freeindex &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">	whichByte := freeByteBase / <span class="number">8</span></span><br><span class="line">	<span class="comment">// Init alloc bits cache.</span></span><br><span class="line">	s.refillAllocCache(whichByte)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adjust the allocCache so that s.freeindex corresponds to the low bit in</span></span><br><span class="line">	<span class="comment">// s.allocCache.</span></span><br><span class="line">	s.allocCache &gt;&gt;= s.freeindex % <span class="number">64</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h4><p><code>mheap</code> 可以认为是 Go 程序持有的整个堆空间，<code>mheap_</code> 为唯一全局对象用来管理堆内存，里面的数据会在程序启动时初始化完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mheap_ mheap</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock      mutex</span><br><span class="line">  </span><br><span class="line">  free      mTreap <span class="comment">// free and non-scavenged spans</span></span><br><span class="line">	scav      mTreap <span class="comment">// free and scavenged spans</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存放所有产生的 mspan</span></span><br><span class="line">	allspans []*mspan </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// arenas 是个二维数组，元素为 heapArena，里面存放着 arena 的 metadata</span></span><br><span class="line">  <span class="comment">// 每个 arena 都有一个对应的 heapArena</span></span><br><span class="line">	arenas [<span class="number">1</span> &lt;&lt; arenaL1Bits]*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// arena 链表，保存了起始地址、是否为最后一个 arena</span></span><br><span class="line">  arenaHints *arenaHint</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 全部的 mcentral，共计134个</span></span><br><span class="line">	central [numSpanClasses]<span class="keyword">struct</span> &#123;</span><br><span class="line">		mcentral mcentral</span><br><span class="line">		pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="keyword">byte</span></span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 每 2 个 bit 对应 arena 里一个指针大小的数据</span></span><br><span class="line">	bitmap [heapArenaBitmapBytes]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// spans 将 page 对应到 mspan</span></span><br><span class="line">	spans [pagesPerArena]*mspan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mheap</code> 分配 <code>mspan</code> 的函数是 alloc，这个函数会在 g0 栈空间中调用 alloc_m 函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npage <span class="keyword">uintptr</span>, spanclass spanClass, large <span class="keyword">bool</span>, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s = h.alloc_m(npage, spanclass, large)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> needzero &amp;&amp; s.needzero != <span class="number">0</span> &#123;</span><br><span class="line">			memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)</span><br><span class="line">		&#125;</span><br><span class="line">		s.needzero = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc_m</span><span class="params">(npage <span class="keyword">uintptr</span>, spanclass spanClass, large <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 防止 heap 增长过快，分配前清扫回收等量的 page</span></span><br><span class="line">	<span class="keyword">if</span> h.sweepdone == <span class="number">0</span> &#123;</span><br><span class="line">		h.reclaim(npage)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;h.lock)</span><br><span class="line">	<span class="comment">// transfer stats from cache to global</span></span><br><span class="line">	memstats.heap_scan += <span class="keyword">uint64</span>(_g_.m.mcache.local_scan)</span><br><span class="line">	_g_.m.mcache.local_scan = <span class="number">0</span></span><br><span class="line">	memstats.tinyallocs += <span class="keyword">uint64</span>(_g_.m.mcache.local_tinyallocs)</span><br><span class="line">	_g_.m.mcache.local_tinyallocs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配 span </span></span><br><span class="line">	s := h.allocSpanLocked(npage, &amp;memstats.heap_inuse)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">  	... <span class="comment">// 记录 span 的信息</span></span><br><span class="line">  &#125;</span><br><span class="line">	unlock(&amp;h.lock)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">allocSpanLocked</span><span class="params">(npage <span class="keyword">uintptr</span>, stat *<span class="keyword">uint64</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从 free 链表分配</span></span><br><span class="line">	s = h.pickFreeSpan(npage)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> HaveSpan</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 失败的话，向系统申请内存</span></span><br><span class="line">	<span class="keyword">if</span> !h.grow(npage) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 再试一次</span></span><br><span class="line">	s = h.pickFreeSpan(npage)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> HaveSpan</span><br><span class="line">	&#125;</span><br><span class="line">	throw(<span class="string">"grew heap, but no adequate free span found"</span>)</span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">	<span class="comment">// Mark span in use.</span></span><br><span class="line">	<span class="keyword">if</span> s.state != mSpanFree &#123;</span><br><span class="line">		throw(<span class="string">"candidate mspan for allocation is not free"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.npages &lt; npage &#123;</span><br><span class="line">		throw(<span class="string">"candidate mspan for allocation is too small"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	memstats.heap_released -= <span class="keyword">uint64</span>(s.released())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到的页数多于申请的，分割剩余的页数到另一个 span 并放入 free 链表</span></span><br><span class="line">	<span class="keyword">if</span> s.npages &gt; npage &#123;</span><br><span class="line">		<span class="comment">// Trim extra and put it back in the heap.</span></span><br><span class="line">		t := (*mspan)(h.spanalloc.alloc())</span><br><span class="line">		t.init(s.base()+npage&lt;&lt;_PageShift, s.npages-npage)</span><br><span class="line">		s.npages = npage</span><br><span class="line">		h.setSpan(t.base()<span class="number">-1</span>, s)</span><br><span class="line">		h.setSpan(t.base(), t)</span><br><span class="line">		h.setSpan(t.base()+t.npages*pageSize<span class="number">-1</span>, t)</span><br><span class="line">		t.needzero = s.needzero</span><br><span class="line">		<span class="comment">// If s was scavenged, then t may be scavenged.</span></span><br><span class="line">		start, end := t.physPageBounds()</span><br><span class="line">		<span class="keyword">if</span> s.scavenged &amp;&amp; start &lt; end &#123;</span><br><span class="line">			memstats.heap_released += <span class="keyword">uint64</span>(end - start)</span><br><span class="line">			t.scavenged = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		s.state = mSpanManual <span class="comment">// prevent coalescing with s</span></span><br><span class="line">		t.state = mSpanManual</span><br><span class="line">		h.freeSpanLocked(t, <span class="literal">false</span>, <span class="literal">false</span>, s.unusedsince)</span><br><span class="line">		s.state = mSpanFree</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.scavenged &#123;</span><br><span class="line">		sysUsed(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)</span><br><span class="line">		s.scavenged = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.unusedsince = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 span 位置</span></span><br><span class="line">	h.setSpans(s.base(), npage, s)</span><br><span class="line"></span><br><span class="line">	*stat += <span class="keyword">uint64</span>(npage &lt;&lt; _PageShift)</span><br><span class="line">	memstats.heap_idle -= <span class="keyword">uint64</span>(npage &lt;&lt; _PageShift)</span><br><span class="line">	<span class="keyword">if</span> s.inList() &#123;</span><br><span class="line">		throw(<span class="string">"still in list"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>堆上的内存分配调用了 runtime 包里的 newobject 函数，此函数调用了 mallocgc 函数，Go 语言在分配内存时，会根据对象的大小将对象分成三类：</p>
<ul>
<li>大对象，大于 32K，在 mheap 上分配</li>
<li>微对象，小于 16B 且不是指针，使用 mcache 的 tiny 分配</li>
<li>小对象，使用 mcache 对应的规格大小的 mspan 分配</li>
</ul>
<h4 id="小对象"><a href="#小对象" class="headerlink" title="小对象"></a>小对象</h4><p>小对象的分配流程大致如下：</p>
<ol>
<li>根据对象大小确定 size class 和 span class</li>
<li>尝试从 mcache 找到可用空间，有的话直接分配</li>
<li>若没有向 mcentral 申请一个 mspan</li>
<li>若 mcentral 也没有，向 mheap 申请</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码 </span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">			<span class="comment">// 微对象分配</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line">			<span class="comment">// 根据对象的大小找到合适的 sizeClass</span></span><br><span class="line">      <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">				sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 根据 sizeClass 找到 spanClass</span></span><br><span class="line">			size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">			spc := makeSpanClass(sizeclass, noscan)</span><br><span class="line">      <span class="comment">// 从 mcache 拿到 mspan</span></span><br><span class="line">			span := c.alloc[spc]</span><br><span class="line">      <span class="comment">// 利用 mspan.allocCache 尝试快速找到可用空间</span></span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 从整个 mspan 中查找可用空间，如果没有，向 mcentral 要一个新的 mspan</span></span><br><span class="line">				v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">			<span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">				memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 大对象分配</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//... 后续处理</span></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span> <span class="title">gclinkptr</span></span> &#123;</span><br><span class="line">	theBit := sys.Ctz64(s.allocCache) <span class="comment">// Is there a free object in the allocCache?</span></span><br><span class="line">	<span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">		result := s.freeindex + <span class="keyword">uintptr</span>(theBit)</span><br><span class="line">		<span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">			freeidx := result + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			s.allocCache &gt;&gt;= <span class="keyword">uint</span>(theBit + <span class="number">1</span>)</span><br><span class="line">			s.freeindex = freeidx</span><br><span class="line">			s.allocCount++</span><br><span class="line">			<span class="keyword">return</span> gclinkptr(result*s.elemsize + s.base())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">nextFree</span><span class="params">(spc spanClass)</span> <span class="params">(v gclinkptr, s *mspan, shouldhelpgc <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	s = c.alloc[spc]</span><br><span class="line">	shouldhelpgc = <span class="literal">false</span></span><br><span class="line">	freeIndex := s.nextFreeIndex()</span><br><span class="line">	<span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">		<span class="comment">// mspan 已满</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"runtime: s.allocCount="</span>, s.allocCount, <span class="string">"s.nelems="</span>, s.nelems)</span><br><span class="line">			throw(<span class="string">"s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		c.refill(spc) <span class="comment">// 向 mcentral 申请一个新的替换旧的</span></span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		s = c.alloc[spc]</span><br><span class="line"></span><br><span class="line">		freeIndex = s.nextFreeIndex()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> freeIndex &gt;= s.nelems &#123;</span><br><span class="line">		throw(<span class="string">"freeIndex is not valid"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v = gclinkptr(freeIndex*s.elemsize + s.base())</span><br><span class="line">	s.allocCount++</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) &gt; s.nelems &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"s.allocCount="</span>, s.allocCount, <span class="string">"s.nelems="</span>, s.nelems)</span><br><span class="line">		throw(<span class="string">"s.allocCount &gt; s.nelems"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="微对象"><a href="#微对象" class="headerlink" title="微对象"></a>微对象</h4><p>微对象的分配流程大致如下：</p>
<ol>
<li>将对象的大小对齐在 2、4、8 字节上</li>
<li>如果 mcache 有 tiny block 并且有合适的空间，直接分配</li>
<li>如果没有，在 mcache 里寻找其他 mspan</li>
<li>若没有，向 mcentral 申请</li>
<li>也没有，向 mheap 申请</li>
<li>调整 mcache 的 tiny block 和 tinyoffset</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="comment">// 省略部分代码</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">	</span><br><span class="line">			off := c.tinyoffset</span><br><span class="line">			<span class="comment">// 根据要分配的对象对齐字节</span></span><br><span class="line">			<span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">8</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">4</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 检查 mcache 有没有 tiny block</span></span><br><span class="line">      <span class="comment">// 有且有空间，直接分配，调整 tinyoffset</span></span><br><span class="line">			<span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">				x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">				c.tinyoffset = off + size</span><br><span class="line">				c.local_tinyallocs++</span><br><span class="line">				mp.mallocing = <span class="number">0</span></span><br><span class="line">				releasem(mp)</span><br><span class="line">				<span class="keyword">return</span> x</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 下面一段和普通对象分配流程一样</span></span><br><span class="line">			span := c.alloc[tinySpanClass]</span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">				v, _, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">			(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">			(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">			<span class="comment">// 更新 mcache 的 tiny 和 tinyoffset 字段</span></span><br><span class="line">			<span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">				c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">				c.tinyoffset = size</span><br><span class="line">			&#125;</span><br><span class="line">			size = maxTinySize</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 小对象分配</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 大对象分配</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后续处理</span></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h4><p>大对象分配流程相对简单，跳过了 mcache 和 mcentral 阶段直接通过 mheap 分配</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="comment">// 省略部分代码</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">			<span class="comment">// 微对象分配</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 小对象分配</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 大对象分配</span></span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			s = largeAlloc(size, needzero, noscan)</span><br><span class="line">		&#125;)</span><br><span class="line">		s.freeindex = <span class="number">1</span></span><br><span class="line">		s.allocCount = <span class="number">1</span></span><br><span class="line">		x = unsafe.Pointer(s.base())</span><br><span class="line">		size = s.elemsize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后续处理</span></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largeAlloc</span><span class="params">(size <span class="keyword">uintptr</span>, needzero <span class="keyword">bool</span>, noscan <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> size+_PageSize &lt; size &#123;</span><br><span class="line">		throw(<span class="string">"out of memory"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	npages := size &gt;&gt; _PageShift</span><br><span class="line">	<span class="keyword">if</span> size&amp;_PageMask != <span class="number">0</span> &#123;</span><br><span class="line">		npages++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	deductSweepCredit(npages*_PageSize, npages)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 mheap 进行分配</span></span><br><span class="line">	s := mheap_.alloc(npages, makeSpanClass(<span class="number">0</span>, noscan), <span class="literal">true</span>, needzero)</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"out of memory"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	s.limit = s.base() + size</span><br><span class="line">	heapBitsForAddr(s.base()).initSpan(s)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Golang 的内存分配是个相当复杂的过程，并且里面还掺杂了 GC 的处理，这里仅对一些关键性的数据结构及流程进行了梳理说明，这在整个 Golang 内存分配策略的多样性里只是冰山一角。</p>
<ul>
<li>程序在启动时申请了一块内存，之后自行管理</li>
<li>mspan 是内存分配的基本单元，由若干个页组成，每个 mspan 分配特定大小的对象</li>
<li>mcache、mcentral、mheap 内存管理三大组件，层层递进</li>
<li>分配对象时根据大小分为三类，使用对应的分配器分配内存，节省资源</li>
</ul>
</div><div class="tags"><a href="/tags/Golang/">Golang</a></div><div class="post-nav"><a class="pre" href="/2019/03/20/go-gc/">Golang 源码阅读 - GC</a><a class="next" href="/2018/12/19/helm-security/">当我们使用 Helm 时，可能需要考虑一些安全问题</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://localhost:4000/2019/03/08/go-memory/';
    this.page.identifier = '2019/03/08/go-memory/';
    this.page.title = 'Golang 源码阅读 - 内存管理';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//daivd.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//daivd.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://daivd.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://localhost:4000"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/Kubernetes/" style="font-size: 15px;">Kubernetes</a> <a href="/tags/Helm/" style="font-size: 15px;">Helm</a> <a href="/tags/Prometheus/" style="font-size: 15px;">Prometheus</a> <a href="/tags/v8/" style="font-size: 15px;">v8</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/go-sudog/">Golang 源码阅读 - 等待队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/go-sync/">Golang 源码阅读 - sync</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/02/go-timer/">Golang 源码阅读 - timer</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/go-netpoll/">Golang 源码阅读 - netpoll</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/14/go-context/">Golang 源码阅读 - context</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/21/go-unsafe/">Golang 源码阅读 - unsafe</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/go-reflect/">Golang 源码阅读 - reflect</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/go-range/">Golang 源码阅读 - for range</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/go-interface/">Golang 源码阅读 - interface</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/27/go-select/">Golang 源码阅读 - channel</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//daivd.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Ruiyuan Wang.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>