<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Node.js Golang DevOps"><title>Golang 源码阅读 - 并发模型 | Ryan's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Golang 源码阅读 - 并发模型</h1><a id="logo" href="/.">Ryan's Blog</a><p class="description">Whole life learning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Golang 源码阅读 - 并发模型</h1><div class="post-meta">May 10, 2019</div><a class="disqus-comment-count" data-disqus-identifier="2019/05/10/go-gmp/" href="/2019/05/10/go-gmp/#disqus_thread"></a><div class="post-content"><p>Go 语言中的并发模型有三个核心结构 G M P ，下面会简单回顾下基本概念，之后会详细介绍它们的实现原理及运行时的状态切换。</p>
<ol>
<li><strong>G</strong> 表示一个 goroutine，它的生命周期受 Go 运行时管理</li>
<li><strong>M</strong> 等同于系统线程，可以运行 go 代码（即 goroutine 需要一个 P）和原生代码（syscall，不需要 P）</li>
<li><strong>P</strong>  可以看作是运行在 M 上的一个本地调度器</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>runtime2.go</code> 里有详细的定义，这里只列出一些比较重要的字段</p>
<h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack          stack    <span class="comment">// 当前 g 使用的栈空间，有 lo 和 hi 两个成员变量</span></span><br><span class="line">	stackguard0    <span class="keyword">uintptr</span>  <span class="comment">// 检测 g 的栈是否需要扩张</span></span><br><span class="line">	stackguard1    <span class="keyword">uintptr</span>  <span class="comment">// 检测 c 的栈是否需要扩张</span></span><br><span class="line">  m              *m       <span class="comment">// 当前 g 对应的 m</span></span><br><span class="line">  sched          gobuf    <span class="comment">// g 的调度数据，当 g 中断时保存当前栈的 pc sp bp 等</span></span><br><span class="line">  atomicstatus   <span class="keyword">uint32</span>   <span class="comment">// 当前 g 的状态 _Gidle/_Grunnable...</span></span><br><span class="line">  schedlink      guintptr <span class="comment">// 当 g 在链表结构中表示下一个 g</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// G status</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// _Gidle means this goroutine was just allocated and has not</span></span><br><span class="line">	<span class="comment">// yet been initialized.</span></span><br><span class="line">	_Gidle = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Grunnable means this goroutine is on a run queue. It is</span></span><br><span class="line">	<span class="comment">// not currently executing user code. The stack is not owned.</span></span><br><span class="line">	_Grunnable <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Grunning means this goroutine may execute user code. The</span></span><br><span class="line">	<span class="comment">// stack is owned by this goroutine. It is not on a run queue.</span></span><br><span class="line">	<span class="comment">// It is assigned an M and a P.</span></span><br><span class="line">	_Grunning <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Gsyscall means this goroutine is executing a system call.</span></span><br><span class="line">	<span class="comment">// It is not executing user code. The stack is owned by this</span></span><br><span class="line">	<span class="comment">// goroutine. It is not on a run queue. It is assigned an M.</span></span><br><span class="line">	_Gsyscall <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Gwaiting means this goroutine is blocked in the runtime.</span></span><br><span class="line">	<span class="comment">// It is not executing user code. It is not on a run queue,</span></span><br><span class="line">	<span class="comment">// but should be recorded somewhere (e.g., a channel wait</span></span><br><span class="line">	<span class="comment">// queue) so it can be ready()d when necessary. The stack is</span></span><br><span class="line">	<span class="comment">// not owned *except* that a channel operation may read or</span></span><br><span class="line">	<span class="comment">// write parts of the stack under the appropriate channel</span></span><br><span class="line">	<span class="comment">// lock. Otherwise, it is not safe to access the stack after a</span></span><br><span class="line">	<span class="comment">// goroutine enters _Gwaiting (e.g., it may get moved).</span></span><br><span class="line">	_Gwaiting <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Gmoribund_unused is currently unused, but hardcoded in gdb</span></span><br><span class="line">	<span class="comment">// scripts.</span></span><br><span class="line">	_Gmoribund_unused <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Gdead means this goroutine is currently unused. It may be</span></span><br><span class="line">	<span class="comment">// just exited, on a free list, or just being initialized. It</span></span><br><span class="line">	<span class="comment">// is not executing user code. It may or may not have a stack</span></span><br><span class="line">	<span class="comment">// allocated. The G and its stack (if any) are owned by the M</span></span><br><span class="line">	<span class="comment">// that is exiting the G or that obtained the G from the free</span></span><br><span class="line">	<span class="comment">// list.</span></span><br><span class="line">	_Gdead <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Genqueue_unused is currently unused.</span></span><br><span class="line">	_Genqueue_unused <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Gcopystack means this goroutine's stack is being moved. It</span></span><br><span class="line">	<span class="comment">// is not executing user code and is not on a run queue. The</span></span><br><span class="line">	<span class="comment">// stack is owned by the goroutine that put it in _Gcopystack.</span></span><br><span class="line">	_Gcopystack <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Gscan combined with one of the above states other than</span></span><br><span class="line">	<span class="comment">// _Grunning indicates that GC is scanning the stack. The</span></span><br><span class="line">	<span class="comment">// goroutine is not executing user code and the stack is owned</span></span><br><span class="line">	<span class="comment">// by the goroutine that set the _Gscan bit.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// _Gscanrunning is different: it is used to briefly block</span></span><br><span class="line">	<span class="comment">// state transitions while GC signals the G to scan its own</span></span><br><span class="line">	<span class="comment">// stack. This is otherwise like _Grunning.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// atomicstatus&amp;~Gscan gives the state the goroutine will</span></span><br><span class="line">	<span class="comment">// return to when the scan completes.</span></span><br><span class="line">	_Gscan         = <span class="number">0x1000</span></span><br><span class="line">	_Gscanrunnable = _Gscan + _Grunnable <span class="comment">// 0x1001</span></span><br><span class="line">	_Gscanrunning  = _Gscan + _Grunning  <span class="comment">// 0x1002</span></span><br><span class="line">	_Gscansyscall  = _Gscan + _Gsyscall  <span class="comment">// 0x1003</span></span><br><span class="line">	_Gscanwaiting  = _Gscan + _Gwaiting  <span class="comment">// 0x1004</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">	g0            *g        <span class="comment">// 调度和执行系统调用时会切换到 g0</span></span><br><span class="line">  tls           [<span class="number">6</span>]<span class="keyword">uintptr</span><span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">	curg          *g        <span class="comment">// 当前运行的 g</span></span><br><span class="line">	p             puintptr  <span class="comment">// 当前拥有的 P</span></span><br><span class="line">	nextp         puintptr  <span class="comment">// 唤醒时，会拥有这个 P</span></span><br><span class="line">	oldp          puintptr  <span class="comment">// 系统调用之前拥有的 P</span></span><br><span class="line">	park          note      <span class="comment">// M 休眠时的信号量，唤醒时使用</span></span><br><span class="line">	schedlink     muintptr  <span class="comment">// 在链表结构时，表示下一个 M</span></span><br><span class="line">	mcache        *mcache   <span class="comment">// 小对象的内存分配器，不需要加锁，因为它属于单独一个 M 或 P</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>M 虽然没有像 G 或 P 的状态值表示，但我们可以认为一个 M 有以下的状态</p>
<ul>
<li>自旋中(spinning)：M 正在从运行队列获取 G，此时拥有一个 P</li>
<li>正在执行 Go 代码：此时也会拥有一个 P</li>
<li>正在执行原生代码或阻塞的 syscall：此时不拥有 P</li>
<li>休眠中：M 发现无等待运行的 G 时会进入休眠，此时不拥有 P</li>
</ul>
<h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">	status      <span class="keyword">uint32</span>     <span class="comment">// 当前的状态 pidle/prunning/...</span></span><br><span class="line">	link        puintptr   <span class="comment">// 当 p 在链表结构中，表示下一个 p</span></span><br><span class="line">	m           muintptr   <span class="comment">// 拥有这个 p 的 m</span></span><br><span class="line">  mcache      *mcache    <span class="comment">// 同 M 的 mcache</span></span><br><span class="line">  </span><br><span class="line">  runqhead    <span class="keyword">uint32</span>         <span class="comment">// 本地运行队列头</span></span><br><span class="line">	runqtail    <span class="keyword">uint32</span>         <span class="comment">// 本地运行队列尾</span></span><br><span class="line">	runq        [<span class="number">256</span>]guintptr  <span class="comment">// 本地运行队列数组，可以保存 256 个 g</span></span><br><span class="line">  runnext     guintptr       <span class="comment">// 下一个要运行的 g</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Available G's (status == Gdead) 保存着可以复用的 g</span></span><br><span class="line">	gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">		gList</span><br><span class="line">		n <span class="keyword">int32</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// P status</span></span><br><span class="line">	_Pidle    = <span class="literal">iota</span></span><br><span class="line">	_Prunning <span class="comment">// Only this P is allowed to change from _Prunning.</span></span><br><span class="line">	_Psyscall</span><br><span class="line">	_Pgcstop</span><br><span class="line">	_Pdead</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="程序初始化"><a href="#程序初始化" class="headerlink" title="程序初始化"></a>程序初始化</h4><p>Go 程序的入口是在 <code>runtime.rt0_go</code> 汇编语言中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$0</span><br><span class="line">	// 省略分配栈空间，参数处理等代码</span><br><span class="line">	...</span><br><span class="line">	// 全局g0实例放入 DI 寄存器中</span><br><span class="line">	MOVQ	$runtime·g0(SB), DI    </span><br><span class="line">	LEAQ	(-64*1024+104)(SP), BX </span><br><span class="line">	// 设置 g0 的 stackguard0/stackguard1/stack 三个字段</span><br><span class="line">	MOVQ	BX, g_stackguard0(DI)</span><br><span class="line">	MOVQ	BX, g_stackguard1(DI)</span><br><span class="line">	MOVQ	BX, (g_stack+stack_lo)(DI)</span><br><span class="line">	MOVQ	SP, (g_stack+stack_hi)(DI)</span><br><span class="line"></span><br><span class="line">	// 省略获取当前 CPU 的信息代码</span><br><span class="line">	...</span><br><span class="line">nocpuinfo:</span><br><span class="line">	// if there is an _cgo_init, call it.</span><br><span class="line">	MOVQ	_cgo_init(SB), AX</span><br><span class="line">	TESTQ	AX, AX</span><br><span class="line">	JZ	needtls</span><br><span class="line">	// g0 already in DI</span><br><span class="line">	MOVQ	DI, CX	// Win64 uses CX for first parameter</span><br><span class="line">	MOVQ	$setg_gcc&lt;&gt;(SB), SI</span><br><span class="line">	CALL	AX</span><br><span class="line"></span><br><span class="line">	// update stackguard after _cgo_init</span><br><span class="line">	MOVQ	$runtime·g0(SB), CX</span><br><span class="line">	MOVQ	(g_stack+stack_lo)(CX), AX</span><br><span class="line">	ADDQ	$const__StackGuard, AX</span><br><span class="line">	MOVQ	AX, g_stackguard0(CX)</span><br><span class="line">	MOVQ	AX, g_stackguard1(CX)</span><br><span class="line"></span><br><span class="line">needtls:</span><br><span class="line">	// 省略预编译的代码</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	// 设置 m0 实例的 tls</span><br><span class="line">	LEAQ	runtime·m0+m_tls(SB), DI</span><br><span class="line">	CALL	runtime·settls(SB)</span><br><span class="line"></span><br><span class="line">	// store through it, to make sure it works</span><br><span class="line">	// 经过上面的settls后，需要验证get_tls和g()作用是否符合预期。失败的话，就引发abort</span><br><span class="line">	get_tls(BX)</span><br><span class="line">	MOVQ	$0x123, g(BX)</span><br><span class="line">	MOVQ	runtime·m0+m_tls(SB), AX</span><br><span class="line">	CMPQ	AX, $0x123</span><br><span class="line">	JEQ 2(PC)</span><br><span class="line">	CALL	runtime·abort(SB)</span><br><span class="line">ok:</span><br><span class="line">	// set the per-goroutine and per-mach &quot;registers&quot;</span><br><span class="line">	// 验证成功后，把全局g0实例放进tls，并且将g0和m0互相引用</span><br><span class="line">	get_tls(BX)</span><br><span class="line">	LEAQ	runtime·g0(SB), CX</span><br><span class="line">	MOVQ	CX, g(BX)</span><br><span class="line">	LEAQ	runtime·m0(SB), AX</span><br><span class="line"></span><br><span class="line">	// save m-&gt;g0 = g0</span><br><span class="line">	MOVQ	CX, m_g0(AX)</span><br><span class="line">	// save m0 to g0-&gt;m</span><br><span class="line">	MOVQ	AX, g_m(CX)</span><br><span class="line"></span><br><span class="line">	CLD				// convention is D is always left cleared</span><br><span class="line">	CALL	runtime·check(SB)</span><br><span class="line"></span><br><span class="line">	MOVL	16(SP), AX		// copy argc</span><br><span class="line">	MOVL	AX, 0(SP)</span><br><span class="line">	MOVQ	24(SP), AX		// copy argv</span><br><span class="line">	MOVQ	AX, 8(SP)</span><br><span class="line">	// 保存传入的argc和argv到全局变量，找到执行文件的绝对路径</span><br><span class="line">	CALL	runtime·args(SB)</span><br><span class="line">	// 根据系统执行不同的初始化，cpu个数和内存页大小等</span><br><span class="line">	CALL	runtime·osinit(SB)</span><br><span class="line">	// 命令行参数、环境变量、gc、栈空间、内存管理、所有P实例、HASH算法等初始化</span><br><span class="line">	CALL	runtime·schedinit(SB)</span><br><span class="line"></span><br><span class="line">	// runtime.main函数地址放进AX</span><br><span class="line">	MOVQ	$runtime·mainPC(SB), AX		// entry</span><br><span class="line">	PUSHQ	AX</span><br><span class="line">	PUSHQ	$0			// arg size</span><br><span class="line">	// 新建一个goroutine，该goroutine绑定runtime.main，放在P的本地队列，等待调度</span><br><span class="line">	CALL	runtime·newproc(SB)</span><br><span class="line">	POPQ	AX</span><br><span class="line">	POPQ	AX</span><br><span class="line"></span><br><span class="line">	// 启动M，开始调度goroutine</span><br><span class="line">	CALL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">	CALL	runtime·abort(SB)	// mstart should never return</span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">	// Prevent dead-code elimination of debugCallV1, which is</span><br><span class="line">	// intended to be called by debuggers.</span><br><span class="line">	MOVQ	$runtime·debugCallV1(SB), AX</span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">DATA	runtime·mainPC+0(SB)/8,$runtime·main(SB)</span><br><span class="line">GLOBL	runtime·mainPC(SB),RODATA,$8</span><br></pre></td></tr></table></figure>
<p> 来看下<code>runtime.schedinit</code> 函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从 tls 中获取当前的 g</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置全局线程数上限</span></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化一系列函数所在的PC计数器，用于traceback</span></span><br><span class="line">	tracebackinit()</span><br><span class="line">	moduledataverify()</span><br><span class="line">	stackinit()</span><br><span class="line">  <span class="comment">// 内存分配器初始化</span></span><br><span class="line">	mallocinit()</span><br><span class="line">	mcommoninit(_g_.m)</span><br><span class="line">	cpuinit()       <span class="comment">// must run before alginit</span></span><br><span class="line">	alginit()       <span class="comment">// maps must not be used before this call</span></span><br><span class="line">	modulesinit()   <span class="comment">// provides activeModules</span></span><br><span class="line">	typelinksinit() <span class="comment">// uses maps, activeModules</span></span><br><span class="line">	itabsinit()     <span class="comment">// uses activeModules</span></span><br><span class="line"></span><br><span class="line">	msigsave(_g_.m)</span><br><span class="line">	initSigmask = _g_.m.sigmask</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取命令行参数</span></span><br><span class="line">	goargs()</span><br><span class="line">	goenvs()</span><br><span class="line">	parsedebugvars()</span><br><span class="line">  <span class="comment">// gc 初始化</span></span><br><span class="line">	gcinit()</span><br><span class="line"></span><br><span class="line">	sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span><br><span class="line">  <span class="comment">// p 个数检查</span></span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 所有 p 初始化</span></span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看下持有  <code>runtime.main</code>  的 groutine 执行后的流程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := getg()</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 标记主函数已被调用</span></span><br><span class="line">	mainStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动一个新的M执行sysmon函数, 这个函数会监控全局的状态并对运行时间过长的G进行抢占</span></span><br><span class="line">	<span class="keyword">if</span> GOARCH != <span class="string">"wasm"</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要求G必须在当前M(系统主线程)上执行</span></span><br><span class="line">	lockOSThread()</span><br><span class="line">	<span class="keyword">if</span> g.m != &amp;m0 &#123;</span><br><span class="line">		throw(<span class="string">"runtime.main not on m0"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	... <span class="comment">// 省略部分代码</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 调用 main.init ，如果存在</span></span><br><span class="line">	fn := main_init</span><br><span class="line">	fn()</span><br><span class="line">	<span class="built_in">close</span>(main_init_done)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不再要求G必须在当前M上运行</span></span><br><span class="line">	needUnlock = <span class="literal">false</span></span><br><span class="line">	unlockOSThread()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果程序是作为c的类库编译的, 在这里返回</span></span><br><span class="line">	<span class="keyword">if</span> isarchive || islibrary &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用main.main函数</span></span><br><span class="line">	fn = main_main</span><br><span class="line">	fn()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前发生了panic, 则等待panic处理</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;runningPanicDefers) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Running deferred functions should not take long.</span></span><br><span class="line">		<span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line">			<span class="keyword">if</span> atomic.Load(&amp;runningPanicDefers) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;panicking) != <span class="number">0</span> &#123;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonPanicWait, traceEvGoStop, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 退出</span></span><br><span class="line">	exit(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> x *<span class="keyword">int32</span></span><br><span class="line">		*x = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用 <code>runtime.mstart</code> 函数，经过初始化和检查最终会调用到 <code>schedule</code> 方法，我们会在下面的调度器实现中详细介绍。</p>
<p>经过上述一系列步骤，程序进入到 main.main 方法中，了解了程序初始化的流程，下面就开始介绍 goroutine 的创建，调度等操作。</p>
<h4 id="创建-Goroutine"><a href="#创建-Goroutine" class="headerlink" title="创建 Goroutine"></a>创建 Goroutine</h4><p>在 Go 语言中使用 <code>go</code> 关键字创建一个新的 goroutine，这个关键字在编译期间通过 stmt 和 call 两个方法转换成 <code>newproc</code> 的函数调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// siz 是 fn+其他参数的长度，fn 函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取其他参数地址</span></span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">  <span class="comment">// 获取当前的 g</span></span><br><span class="line">	gp := getg()</span><br><span class="line">  <span class="comment">// 获取调用方的程序计数器（返回地址）</span></span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">  <span class="comment">// 切换至 g0 堆栈调用 fn 再切回来</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 真正创建 goroutine 的方法</span></span><br><span class="line">		newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argp 参数起始地址，narg 参数长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前的g，这里会获取到 g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">		_g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">		throw(<span class="string">"go of nil func value"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	_g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">	siz := narg</span><br><span class="line">	siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We could allocate a larger initial stack if necessary.</span></span><br><span class="line">	<span class="comment">// Not worth it: this is almost always an error.</span></span><br><span class="line">	<span class="comment">// 4*sizeof(uintreg): extra space added below</span></span><br><span class="line">	<span class="comment">// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</span></span><br><span class="line">	<span class="keyword">if</span> siz &gt;= _StackMin<span class="number">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class="line">		throw(<span class="string">"newproc: function arguments too large for new goroutine"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 m 持有的 p</span></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">  <span class="comment">// 调用 gfget 从 p.gFree 里获取 g，如果之前有g被回收在这里就可以复用（状态为 _Gdead）</span></span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 获取不到时调用 malg 分配一个 g，初始化栈空间大小为 2k</span></span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">    <span class="comment">// 将状态从 _Gidle 转成 _Gdead</span></span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"newproc1: newg missing stack"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">		throw(<span class="string">"newproc1: new g is not Gdead"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面一段是将 fn 的参数拷贝到新 g 的栈上</span></span><br><span class="line">	totalSize := <span class="number">4</span>*sys.RegSize + <span class="keyword">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">	totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span><br><span class="line">	sp := newg.stack.hi - totalSize</span><br><span class="line">	spArg := sp</span><br><span class="line">	<span class="keyword">if</span> usesLR &#123;</span><br><span class="line">		<span class="comment">// caller's LR</span></span><br><span class="line">		*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">		prepGoExitFrame(sp)</span><br><span class="line">		spArg += sys.MinFrameSize</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;</span><br><span class="line">		memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(narg))</span><br><span class="line">		<span class="comment">// This is a stack-to-stack copy. If write barriers</span></span><br><span class="line">		<span class="comment">// are enabled and the source stack is grey (the</span></span><br><span class="line">		<span class="comment">// destination is always black), then perform a</span></span><br><span class="line">		<span class="comment">// barrier copy. We do this *after* the memmove</span></span><br><span class="line">		<span class="comment">// because the destination stack may have garbage on</span></span><br><span class="line">		<span class="comment">// it.</span></span><br><span class="line">		<span class="keyword">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class="line">			f := findfunc(fn.fn)</span><br><span class="line">			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class="line">			<span class="keyword">if</span> stkmap.nbit &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// We're in the prologue, so it's always stack map index 0.</span></span><br><span class="line">				bv := stackmapdata(stkmap, <span class="number">0</span>)</span><br><span class="line">				bulkBarrierBitmap(spArg, spArg, <span class="keyword">uintptr</span>(bv.n)*sys.PtrSize, <span class="number">0</span>, bv.bytedata)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置新 g 的栈指针，指令地址等属性</span></span><br><span class="line">	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">	newg.sched.sp = sp</span><br><span class="line">	newg.stktopsp = sp</span><br><span class="line">	newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">	newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">  <span class="comment">// 将 goexit 函数地址放入 g 的栈底，pc 设置为 g 的地址</span></span><br><span class="line">	gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">	newg.gopc = callerpc</span><br><span class="line">	newg.ancestors = saveAncestors(callergp)</span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line">	<span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">		newg.labels = _g_.m.curg.labels</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	newg.gcscanvalid = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 将新 g 的状态改为 _Grunnable</span></span><br><span class="line">	casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class="line">		<span class="comment">// Sched.goidgen is the last allocated id,</span></span><br><span class="line">		<span class="comment">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class="line">		<span class="comment">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class="line">		_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class="line">		_p_.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class="line">	&#125;</span><br><span class="line">	newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">	_p_.goidcache++</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		newg.racectx = racegostart(callerpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoCreate(newg, newg.startpc)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 把 g 放入运行队列</span></span><br><span class="line">  <span class="comment">// 1. 如果新 g 放入 p.runnext ，旧的g代替新g执行下面步骤</span></span><br><span class="line">  <span class="comment">// 2. 将 g 放入 p 的本地可运行队列 runq</span></span><br><span class="line">  <span class="comment">// 3. 如果满了，则调用 runqputslow 把 g 放到全局运行队列，顺便还把本地运行队列的一半放入全局队列中</span></span><br><span class="line">	runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有空闲的 P，但无自旋的 M，并且主函数已执行，则唤醒或新建一个 M</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">		wakep()</span><br><span class="line">	&#125;</span><br><span class="line">	_g_.m.locks--</span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class="line">		_g_.stackguard0 = stackPreempt</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调度-Goroutine"><a href="#调度-Goroutine" class="headerlink" title="调度 Goroutine"></a>调度 Goroutine</h4><p>在程序初始化小节中，最后调用了 <code>mstart</code> 方法，方法中首先给 g0 分配栈空间，然后调用 <code>mstart1</code> ，在 <code>mstart1</code> 中保存一些调度数据，设置信号量后，调用 <code>schedule</code> 方法，进入调度循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">		stoplockedm()</span><br><span class="line">		execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class="line">	<span class="comment">// since the cgo call is using the m's g0 stack.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">		throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">  <span class="comment">// GC 需要 STW，则休眠当前的 M</span></span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取等待运行的 goroutine，依次有以下几个步骤</span></span><br><span class="line">	<span class="keyword">var</span> gp *g</span><br><span class="line">	<span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class="line">    <span class="comment">// 1. 如果有运行时追踪事件触发或 traceReader 尚未处理完成，则获取 trace.reader</span></span><br><span class="line">		gp = traceReader()</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 如果当前 GC 正在标记阶段，则查找等待运行的 GC Worker。</span></span><br><span class="line">		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 3. 公平起见，每61次调度从全局运行队列获取一次 g</span></span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 4. 调用 runqget 从本地运行队列获取 g</span></span><br><span class="line">		gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">			throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 5. 都失败后，调用 findrunnable 获取待运行的 g，会阻塞到获取成功为止。</span></span><br><span class="line">		gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处，成功获取到一个等待运行的 goroutine</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 让当前 M 离开自旋状态，同时判断如果无自旋 M，并且有空闲的 P，则唤醒或新建一个 M</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		resetspinning()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">		<span class="comment">// 当前 g 被禁止调度，放入禁止调度的待运行队列，返回顶部重试</span></span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sched.disable.runnable.pushBack(gp)</span><br><span class="line">			sched.disable.n++</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">goto</span> top</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// g 要求返回到指定的 M，调用 startlockedm 把 g 和 p 交给该 M，自己进入休眠</span></span><br><span class="line">		startlockedm(gp)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 goroutine</span></span><br><span class="line">	execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来详细看下 <code>findrunnable</code> 函数内部的实现逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">  <span class="comment">// GC 需要 STW，休眠当前 M</span></span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">		<span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">		asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// local runq</span></span><br><span class="line">	<span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> gp, inheritTime</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// global runq</span></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Poll network.</span></span><br><span class="line">	<span class="comment">// 从 netpoll 获取 g，非阻塞调用</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> list := netpoll(<span class="literal">false</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">			gp := list.pop()</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Steal work from other P's.</span></span><br><span class="line">  <span class="comment">// 调用 runqsteal 尝试从其他P的本地运行队列盗取一半的G，如果还是获取不到，就需要休眠 M</span></span><br><span class="line">	procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Either GOMAXPROCS=1 or everybody, except for us, is idle already.</span></span><br><span class="line">		<span class="comment">// New work can appear from returning syscall/cgocall, network or timers.</span></span><br><span class="line">		<span class="comment">// Neither of that submits to local run queues, so no point in stealing.</span></span><br><span class="line">		<span class="keyword">goto</span> stop</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If number of spinning M's &gt;= number of busy P's, block.</span></span><br><span class="line">	<span class="comment">// This is necessary to prevent excessive CPU consumption</span></span><br><span class="line">	<span class="comment">// when GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</span></span><br><span class="line">	<span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">		<span class="keyword">goto</span> stop</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">		_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">		atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">			<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> top</span><br><span class="line">			&#125;</span><br><span class="line">			stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span><br><span class="line">			<span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; _p_.gcBgMarkWorker != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">		_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">		gp := _p_.gcBgMarkWorker.ptr()</span><br><span class="line">		casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> beforeIdle() &#123;</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	allpSnapshot := allp</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return P and block</span></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 再次检查全局待运行队列</span></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 释放当前 M 拥有的 P，P状态变为 _Pidle</span></span><br><span class="line">	<span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">		throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 把 P 加入空闲 P 链表中</span></span><br><span class="line">	pidleput(_p_)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 减少表示当前自旋中 M 数量的全局变量 nmspinning</span></span><br><span class="line">	wasSpinning := _g_.m.spinning</span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		_g_.m.spinning = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再次检查所有 P 的本地dai运行队列</span></span><br><span class="line">	<span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">		<span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			_p_ = pidleget()</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">				acquirep(_p_)</span><br><span class="line">				<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">					_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">					atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">goto</span> top</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再次检查 GC Worker</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		_p_ = pidleget()</span><br><span class="line">		<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &amp;&amp; _p_.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line">			pidleput(_p_)</span><br><span class="line">			_p_ = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">			acquirep(_p_)</span><br><span class="line">			<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">				_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">				atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Go back to idle GC check.</span></span><br><span class="line">			<span class="keyword">goto</span> stop</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再次检查 netpoll，此处调用阻塞，直到某个 fd 收到事件</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: netpoll with p"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		list := netpoll(<span class="literal">true</span>) <span class="comment">// block until new work is available</span></span><br><span class="line">		atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime()))</span><br><span class="line">		<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			_p_ = pidleget()</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">				acquirep(_p_)</span><br><span class="line">				gp := list.pop()</span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">				<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">					traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 休眠当前 M，等待被唤醒</span></span><br><span class="line">	stopm()</span><br><span class="line">	<span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 <code>execute</code> 函数内部实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改 g 的状态</span></span><br><span class="line">	casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">	gp.waitsince = <span class="number">0</span></span><br><span class="line">	gp.preempt = <span class="literal">false</span></span><br><span class="line">	gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">	<span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line">		_g_.m.p.ptr().schedtick++ <span class="comment">//增加 P 记录的调度次数</span></span><br><span class="line">	&#125;</span><br><span class="line">	_g_.m.curg = gp</span><br><span class="line">	gp.m = _g_.m</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check whether the profiler needs to be turned on or off.</span></span><br><span class="line">	hz := sched.profilehz</span><br><span class="line">	<span class="keyword">if</span> _g_.m.profilehz != hz &#123;</span><br><span class="line">		setThreadCPUProfiler(hz)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// gogo 方法在不同的处理器架构实现不同，但也差不太多，下面的汇编是 amd64 上的实现 </span></span><br><span class="line">	gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $16-8</span><br><span class="line">	MOVQ	buf+0(FP), BX		// gobuf</span><br><span class="line">	MOVQ	gobuf_g(BX), DX</span><br><span class="line">	MOVQ	0(DX), CX		// make sure g != nil</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	DX, g(CX)</span><br><span class="line">	MOVQ	gobuf_sp(BX), SP	// restore SP</span><br><span class="line">	MOVQ	gobuf_ret(BX), AX</span><br><span class="line">	MOVQ	gobuf_ctxt(BX), DX</span><br><span class="line">	MOVQ	gobuf_bp(BX), BP</span><br><span class="line">	MOVQ	$0, gobuf_sp(BX)	// clear to help garbage collector</span><br><span class="line">	MOVQ	$0, gobuf_ret(BX)</span><br><span class="line">	MOVQ	$0, gobuf_ctxt(BX)</span><br><span class="line">	MOVQ	$0, gobuf_bp(BX)</span><br><span class="line">	MOVQ	gobuf_pc(BX), BX</span><br><span class="line">	JMP	BX</span><br></pre></td></tr></table></figure>
<p>这个函数会根据 g.sched 中保存的状态恢复各个寄存器的值，跳转至 pc ，也就是 g 的地址开始执行代码。目标函数执行完后会调用 goexit 函数，goexit 会调用 goexit1，goexit1 会通过 mcall 调用 goexit0 函数。</p>
<p>mcall 会保存当前的运行状态到 g.sched，然后切换到 g0 和 g0 的栈空间，再调用 goexit0。在这里 mcall 的保存状态无意义，因为 g 已经结束了，但是当 g 被抢占或等待资源而进入休眠时，会在休眠前使用 mcall 保存状态，在唤醒后可以继续执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 g0 当栈空间运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改状态至 _Gdead</span></span><br><span class="line">	casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">	<span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, <span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 清除相关成员数据</span></span><br><span class="line">	gp.m = <span class="literal">nil</span></span><br><span class="line">	locked := gp.lockedm != <span class="number">0</span></span><br><span class="line">	gp.lockedm = <span class="number">0</span></span><br><span class="line">	_g_.m.lockedg = <span class="number">0</span></span><br><span class="line">	gp.paniconfault = <span class="literal">false</span></span><br><span class="line">	gp._defer = <span class="literal">nil</span> <span class="comment">// should be true already but just in case.</span></span><br><span class="line">	gp._panic = <span class="literal">nil</span> <span class="comment">// non-nil for Goexit during panic. points at stack-allocated data.</span></span><br><span class="line">	gp.writebuf = <span class="literal">nil</span></span><br><span class="line">	gp.waitreason = <span class="number">0</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gp.labels = <span class="literal">nil</span></span><br><span class="line">	gp.timer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">		scanCredit := <span class="keyword">int64</span>(gcController.assistWorkPerByte * <span class="keyword">float64</span>(gp.gcAssistBytes))</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</span><br><span class="line">		gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gp.gcscanvalid = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 解除 M 和 g 的关联</span></span><br><span class="line">	dropg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> GOARCH == <span class="string">"wasm"</span> &#123; <span class="comment">// no threads yet on wasm</span></span><br><span class="line">		gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">		schedule() <span class="comment">// never returns</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedInt != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"invalid m-&gt;lockedInt = "</span>, _g_.m.lockedInt, <span class="string">"\n"</span>)</span><br><span class="line">		throw(<span class="string">"internal lockOSThread error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 把 g 放入 P 的 gFree 列表中，下次创建 g 时可以复用</span></span><br><span class="line">	gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">	<span class="comment">// 继续调度</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个调度流程可以简单总结为：</p>
<ol>
<li>schedule 从各个地方获取 goroutine，都没有后进入 findrunnable</li>
<li>在 findrunnable 中也获取不到后进入休眠，唤醒后返回函数顶部继续</li>
<li>得到 goroutine 后，调用 execute 执行</li>
<li>执行完成后调用 goexit ，然后重新执行 schedule</li>
</ol>
<p>当然触发重新调度的地方并不止上面的正常流程，在当前 goroutine 被抢占或者等待资源时也会重新进行调度。比如在 channel 里阻塞接受或发送数据时，会调用 goparkunlock -&gt; gopark -&gt; mcall(park_m) 这些函数将 goroutine 状态变为等待，最后调用 schedule 重新调度。</p>
</div><div class="tags"><a href="/tags/Golang/">Golang</a></div><div class="post-nav"><a class="pre" href="/2019/05/24/go-channel/">Golang 源码阅读 - channel</a><a class="next" href="/2019/03/20/go-gc/">Golang 源码阅读 - GC</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://localhost:4000/2019/05/10/go-gmp/';
    this.page.identifier = '2019/05/10/go-gmp/';
    this.page.title = 'Golang 源码阅读 - 并发模型';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//daivd.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//daivd.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://daivd.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://localhost:4000"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/Kubernetes/" style="font-size: 15px;">Kubernetes</a> <a href="/tags/Helm/" style="font-size: 15px;">Helm</a> <a href="/tags/Prometheus/" style="font-size: 15px;">Prometheus</a> <a href="/tags/v8/" style="font-size: 15px;">v8</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/go-sudog/">Golang 源码阅读 - 等待队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/16/go-sync/">Golang 源码阅读 - sync</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/02/go-timer/">Golang 源码阅读 - timer</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/go-netpoll/">Golang 源码阅读 - netpoll</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/14/go-context/">Golang 源码阅读 - context</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/21/go-unsafe/">Golang 源码阅读 - unsafe</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/go-reflect/">Golang 源码阅读 - reflect</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/go-range/">Golang 源码阅读 - for range</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/go-interface/">Golang 源码阅读 - interface</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/27/go-select/">Golang 源码阅读 - channel</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//daivd.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Ruiyuan Wang.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>