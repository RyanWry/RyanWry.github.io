<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Node.js Golang DevOps"><title>基于 Prometheus 的监控实践 | Yuan's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">基于 Prometheus 的监控实践</h1><a id="logo" href="/.">Yuan's Blog</a><p class="description">Whole life learning</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">基于 Prometheus 的监控实践</h1><div class="post-meta">Jun 14, 2018</div><a class="disqus-comment-count" data-disqus-identifier="2018/06/14/prometheus/" href="/2018/06/14/prometheus/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#初衷"><span class="toc-number">1.</span> <span class="toc-text">初衷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#架构"><span class="toc-number">2.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prometheus-特点"><span class="toc-number">3.</span> <span class="toc-text">prometheus 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据模型和类型"><span class="toc-number">4.</span> <span class="toc-text">数据模型和类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Counter"><span class="toc-number">4.1.</span> <span class="toc-text">Counter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gauge"><span class="toc-number">4.2.</span> <span class="toc-text">Gauge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Histogram"><span class="toc-number">4.3.</span> <span class="toc-text">Histogram</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Summary"><span class="toc-number">4.4.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查询"><span class="toc-number">5.</span> <span class="toc-text">查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务发现和数据采集"><span class="toc-number">6.</span> <span class="toc-text">服务发现和数据采集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#报警和可视化"><span class="toc-number">7.</span> <span class="toc-text">报警和可视化</span></a></li></ol></div></div><div class="post-content"><h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>之前团队一直使用 APM (newrelic、tingyun等) 去监控应用的状态，分析性能，这些工具不侵入业务，不用埋点，接入简单，是非常好的系统监控解决方案。但是，有些需求是 APM 无法满足的，比如，我们需要监控各个渠道或各平台充值速率，各渠道新用户的增长等等。这种细粒度的监控能帮助我们及时发现以及定位问题，这些指标一般也统称为<strong>应用业务指标</strong>。</p>
<p>指标采集目前比较常见的方式就是写日志，将日志通过 TCP、UDP 等方式推送到远端（ES、InfluxDB等）进行分析和绘图，虽然可以满足我们的需求，但在指标采集的粒度和维度以及查询上都不太灵活。</p>
<p>最终我们选择使用 Prometheus ，主要是通过 pull 的方式来采集指标。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>下图说明了 Prometheus 及其生态系统组件的一些架构，来自<a href="https://prometheus.io/docs/introduction/overview/" target="_blank" rel="noopener">官方文档</a></p>
<p><img src="https://prometheus.io/assets/architecture.svg" alt=""></p>
<p>Prometheus 可以从配置或用服务发现获取监控目标，然后去调用目标的 /metrics 接口采集数据，将数据存储到硬盘中，采集到的数据最终有两个去向，一个是报警，一个就是可视化。</p>
<h3 id="prometheus-特点"><a href="#prometheus-特点" class="headerlink" title="prometheus 特点"></a>prometheus 特点</h3><ul>
<li>多维度的数据模型</li>
<li>灵活强大的查询语句（PromQL）</li>
<li>采用 HTTP 协议，主要使用 Pull 方式采集指标</li>
<li>监控目标，可以采用静态配置和服务发现的方式</li>
</ul>
<h3 id="数据模型和类型"><a href="#数据模型和类型" class="headerlink" title="数据模型和类型"></a>数据模型和类型</h3><p>每条指标数据由 metric (指标名称)，一个或一组 label ，以及 float64 的值和毫秒级的时间戳组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">api_http_requests_total&#123;method=&quot;POST&quot;, handler=&quot;/messages&quot;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>metric name 需要满足正则 <code>[a-zA-Z_:][a-zA-Z0-9_:]*</code> </li>
<li>label name 需要满足正则 <code>[a-zA-Z_][a-zA-Z0-9_]*</code></li>
</ul>
<p>Prometheus 客户端库目前提供了四种核心度量类型。</p>
<h4 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h4><p>简单的计数器，不断的增加。比如监控新用户的变化，可以使用 Counter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_user_count&#123;platform=&quot;Weixin&quot;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Gauge"><a href="#Gauge" class="headerlink" title="Gauge"></a>Gauge</h4><p>监控的数据是瞬时的，可以任意变高变低。比如监控 Node.js 内存使用情况</p>
<h4 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h4><p>直方图对观察结果进行采样（通常是请求持续时间或响应大小等），并将其计入可配置桶中，还提供了所有观测值的总和。</p>
<h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>和 Histogram 十分相似，也是对观察结果进行采样，区别是它按百分比去统计数据。比如统计 API 接口响应时间，可以使用 Summary 或者 Histogram。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http_request_duration_seconds&#123;quantile=&quot;0.05&quot;,method=&quot;GET&quot;&#125; 21</span><br><span class="line">http_request_duration_seconds&#123;quantile=&quot;0.5&quot;,method=&quot;GET&quot;&#125; 60</span><br><span class="line">http_request_duration_seconds&#123;quantile=&quot;0.99&quot;,method=&quot;GET&quot;&#125; 80</span><br><span class="line">http_request_duration_seconds_sum&#123;method=&quot;GET&quot;&#125; 600</span><br><span class="line">http_request_duration_seconds_count&#123;method=&quot;GET&quot;&#125; 112</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>Prometheus 提供了一个实用性的查询语言 PromQL，可以让我们实时的选择和汇总时间序列数据，它的语言表现力非常丰富，内置多种函数，满足各个维度的复杂查询。</p>
<p>在这里简单举个例子，详细的使用参考<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">比如有以下一组序列数据，每条数据包含三个 label ，渠道、平台及充值类型，值为当时充值总量</span><br><span class="line"></span><br><span class="line">charge_order_price_count&#123;channel=&quot;ANDROID&quot;,platform=&quot;ALI&quot;,type=&quot;CHARGE&quot;&#125;	5000</span><br><span class="line">charge_order_price_count&#123;channel=&quot;ANDROID&quot;,platform=&quot;ALI&quot;,type=&quot;MONTHLY&quot;&#125;	4000</span><br><span class="line">charge_order_price_count&#123;channel=&quot;ANDROID&quot;,platform=&quot;WEIXIN&quot;,type=&quot;CHARGE&quot;&#125; 6000</span><br><span class="line">charge_order_price_count&#123;channel=&quot;iOS&quot;,platform=&quot;ALI&quot;,type=&quot;CHARGE&quot;&#125; 6000</span><br><span class="line">charge_order_price_count&#123;channel=&quot;iOS&quot;,platform=&quot;WEIXIN&quot;,type=&quot;MONTHLY&quot;&#125; 6000</span><br><span class="line"></span><br><span class="line">我们想分别统计各个渠道充值速率，可以用如下 query 语句</span><br><span class="line">sum(rate(charge_order_price_count[5m])) by (channel) </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&#123;channel=&quot;iOS&quot;&#125;	 12</span><br><span class="line">&#123;channel=&quot;ANDROID&quot;&#125;	25</span><br><span class="line"></span><br><span class="line">想统计各个平台或充值类型，使用同样语句只需要改变 by 的值就可以办到</span><br></pre></td></tr></table></figure>
<h3 id="服务发现和数据采集"><a href="#服务发现和数据采集" class="headerlink" title="服务发现和数据采集"></a>服务发现和数据采集</h3><p>对 API 进行监控，如果使用 Prometheus 的静态配置，当新增或下线一个实例时，由于配置列表过长，修改起来非常痛苦，极其容易导致误操作，所以从一开始我们就决定了使用 Prometheus 的服务发现。从官方文档可以发现它支持多种多样的服务发现，consul、file、dns等等，最终我们选择了使用 consul。</p>
<p>在 API 项目暴露出 /metrics 指标采集接口，并将地址注册到 consul，在 Prometheus 里配置 consul_sd_configs 发现服务，开始采集数据，整个流程都如架构图一样的完美。</p>
<p>然而，在采集一段时间后，发现监控数据与实际数值差异巨大，比如监控的接口 QPS 是实际的 1/16，仔细回顾了整个过程，发现遗漏一个非常重要的事情，我们 API 使用 pm2 集群模式在单个机器上部署了16个进程，共享同一个端口，Prometheus 每次扒取的数据仅仅是16个进程中的其中一个！</p>
<p>事情变得没有刚开始想象的那么简单，解决方案想来想去貌似只有两个，一是每个进程都去聚合16个进程的指标数据，Prometheus 不管去哪个进程抓数据，拿到的都是同样的聚合后的数据。二是将每个进程都注册到 consul，Prometheus 分别去抓每个进程的数据。</p>
<p>刚开始采用方案一，就碰到个棘手的问题，由于使用 pm2 的集群模式，导致 node 进程无法获取集群中 master 信息，进而无法进行进程间通信。幸运的是，pm2 自身提供了与子进程通信的接口，然后调整了方案一，决定编写个 pm2 的模块(<a href="https://github.com/redar9/pm2-cluster-prometheus" target="_blank" rel="noopener">pm2-cluster-prometheus</a>)，通过模块去聚合各个进程的指标数据，并提供 /metrics 接口给 Prometheus，思路理清后发现使用 pm2 模块聚合指标比最初的方案要好很多。</p>
<p>模块编写完成后，开始上线测试，一切也都很顺利，所有的数据都被采集到 Prometheus，结果又碰到个问题😣，根据指标使用下面查询语句计算的 API 平均延迟高于实际的，非常不准确，而且波动很大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])</span><br></pre></td></tr></table></figure>
<p>将近找了一天原因，发现问题出现在指标的聚合运算上，两个进程中名称同样的 Counter 类型指标，聚合时只是将值相加，由于采集值是浮点数，js 进行聚合时因为精度问题，聚合后的结果忽大忽小，最终导致计算的曲线与实际的不否。后面将采集的值调整为整数，解决数据波动问题。</p>
<p>问题还在继续发生，上线后，随着业务的增上，需要监控的指标越来越多，pm2 模块在聚合指标时计算量越来越大，需要的内存也越来越多，为了减轻模块的压力结合领导的建议，开始考虑当初方案二的可行度，有了pm2 模块的基础，实施也就变得简单点了，pm2 模块将所有进程都注册到 cosnul 并打上 pmId 的 tag，Prometheus 通过 relabel_configs 将 pmId 增加到抓取接口请求参数中，请求到 pm2 模块的链接变为 /metrics?pm_id=1，模块根据 pm_id 到相应的进程拿到指标数据再返回。至此问题总算告一段落，后续碰到再分享给大家。</p>
<h3 id="报警和可视化"><a href="#报警和可视化" class="headerlink" title="报警和可视化"></a>报警和可视化</h3><p>Prometheus 的报警功能主要是利用 Alertmanager 这个组件，这个组件实现了几个高级的功能，报警分组、报警抑制、报警静默，让我们可以忽视重复的、没用的、级别不高的报警，筛选出真正有用的信息。报警通知的方式也有很多中，emali、微信、slack、webhook等，目前我们使用 webhook 将报警内容发送到一个中间程序中自定义内容格式后再发送到钉钉群。</p>
<p>可视化，基本使用的都是 Grafana，配置简单，可以做非常多定制化图表。</p>
</div><div class="tags"><a href="/tags/Prometheus/">Prometheus</a></div><div class="post-nav"><a class="pre" href="/2018/09/04/v8-build/">Google v8 源码编译</a><a class="next" href="/2018/04/18/golang-forRang/">Golang 的 for-range 循环中指针和值的区别</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://localhost:4000/2018/06/14/prometheus/';
    this.page.identifier = '2018/06/14/prometheus/';
    this.page.title = '基于 Prometheus 的监控实践';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//daivd.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//daivd.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://daivd.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://localhost:4000"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Kubernetes/" style="font-size: 15px;">Kubernetes</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/Helm/" style="font-size: 15px;">Helm</a> <a href="/tags/Prometheus/" style="font-size: 15px;">Prometheus</a> <a href="/tags/v8/" style="font-size: 15px;">v8</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/helm-security/">当我们使用 Helm 时，可能需要考虑一些安全问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/18/k8s-admission/">访问 Kubernetes API - Admission Control（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/02/k8s-authorization/">访问 Kubernetes API - Authorization（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/15/k8s-authentication/">访问 Kubernetes API - Authentication（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/04/v8-build/">Google v8 源码编译</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/prometheus/">基于 Prometheus 的监控实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/golang-forRang/">Golang 的 for-range 循环中指针和值的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/Kubernetes-architecture/">Kubernetes 架构浅析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//daivd.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Ruiyuan Wang.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>